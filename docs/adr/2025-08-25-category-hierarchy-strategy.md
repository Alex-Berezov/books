# ADR: Стратегия иерархии категорий (adjacency list vs materialized path)

Дата: 2025-08-25
Статус: accepted
Контекст: категориям нужна иерархия (родитель/дети) для группировки жанров и разделов.

## Варианты

1. Adjacency List (текущий подход)

- Модель: `Category.parentId` (self FK), индекс по `parentId`.
- Чтение дерева: один `findMany` + сборка в оперативной памяти.
- Плюсы: простая схема, лёгкие CRUD, дешёвые мутации (перенос ветки = один update).
- Минусы: сложные запросы к поддереву/пути в чистом SQL; дерево строится в приложении; потенциально больше данных в памяти при больших объёмах.

2. Materialized Path (строка пути или массив предков)

- Модель: `path` (например, `/root/parent/child`), индексы по `path` (btree/prefix/GIN-опции).
- Чтение дерева/поддерева быстро через `LIKE 'path/%'` или по массиву.
- Плюсы: быстрый выбор поддерева/предков, простые запросы для навигации.
- Минусы: перенос узла требует обновления `path` для всех потомков (bulk update), риск гонок/частичных обновлений без транзакций.

3. Closure Table (таблица предок-потомок)

- Модель: `CategoryClosure (ancestorId, descendantId, depth)` + индексы.
- Плюсы: гибкие и быстрые запросы для путей/поддеревьев/проверки потомков; простые агрегаты.
- Минусы: сложнее CRUD, требуется сопровождение таблицы при изменениях, дополнительная сложность миграций.

## Решение

Для текущего объёма и требований используется Adjacency List с in-memory сборкой дерева. Это даёт простую схему, дешёвые мутации и минимальные изменения кода/БД. Ограничения касаются запросов для глубоких деревьев и больших объёмов данных.

## Последствия

- Добавлен `Category.parentId` (FK ON DELETE SET NULL) и индекс по `parentId` (миграция `20250825140000_add_category_hierarchy`).
- В сервисе реализована защита от циклов/самопривязки и запрет удаления родителя с детьми.
- Возвращаем дерево и прямых детей эндпоинтами `GET /categories/tree` и `GET /categories/:id/children`.

## План масштабирования (критерии переключения)

Рассмотреть переход на Materialized Path или Closure Table при выполнении одного или нескольких критериев:

- Количество категорий > 50k или средняя глубина дерева > 6, а время сборки дерева > 150 мс и/или размер ответа > 1 МБ.
- Частые выборки поддеревьев/хлебных крошек вызывают тяжёлые запросы/кэш-промахи.
- Потребность в фильтрации по поддеревьям на стороне БД (JOIN к версиям по поддереву).

Наметки по миграции:

- Materialized Path: добавить столбец `path`, бэкфилл из parentId, индексы (btree по `path` и/или trigram для префиксных запросов), поддержка в коде, затем удаление parentId опционально.
- Closure Table: создать `CategoryClosure`, бэкфилл транзитивного замыкания, триггеры/сервисная логика для вноса изменений при CRUD.

## Риски и смягчение

- In-memory сборка может стать узким местом — смягчаем кэшированием дерева и инвалидацией при изменениях.
- Перенос на другую стратегию потребует запланированного окна миграции и дополнительных e2e тестов.
