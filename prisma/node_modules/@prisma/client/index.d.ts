
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Book
 * 
 */
export type Book = $Result.DefaultSelection<Prisma.$BookPayload>
/**
 * Model BookVersion
 * 
 */
export type BookVersion = $Result.DefaultSelection<Prisma.$BookVersionPayload>
/**
 * Model BookSummary
 * 
 */
export type BookSummary = $Result.DefaultSelection<Prisma.$BookSummaryPayload>
/**
 * Model Chapter
 * 
 */
export type Chapter = $Result.DefaultSelection<Prisma.$ChapterPayload>
/**
 * Model AudioChapter
 * 
 */
export type AudioChapter = $Result.DefaultSelection<Prisma.$AudioChapterPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Bookshelf
 * 
 */
export type Bookshelf = $Result.DefaultSelection<Prisma.$BookshelfPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Like
 * 
 */
export type Like = $Result.DefaultSelection<Prisma.$LikePayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model BookCategory
 * 
 */
export type BookCategory = $Result.DefaultSelection<Prisma.$BookCategoryPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model BookTag
 * 
 */
export type BookTag = $Result.DefaultSelection<Prisma.$BookTagPayload>
/**
 * Model ViewStat
 * 
 */
export type ViewStat = $Result.DefaultSelection<Prisma.$ViewStatPayload>
/**
 * Model ReadingProgress
 * 
 */
export type ReadingProgress = $Result.DefaultSelection<Prisma.$ReadingProgressPayload>
/**
 * Model Seo
 * 
 */
export type Seo = $Result.DefaultSelection<Prisma.$SeoPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Language: {
  en: 'en',
  es: 'es',
  fr: 'fr',
  pt: 'pt'
};

export type Language = (typeof Language)[keyof typeof Language]


export const BookType: {
  text: 'text',
  audio: 'audio',
  referral: 'referral'
};

export type BookType = (typeof BookType)[keyof typeof BookType]


export const LikeTarget: {
  comment: 'comment',
  bookVersion: 'bookVersion'
};

export type LikeTarget = (typeof LikeTarget)[keyof typeof LikeTarget]


export const CategoryType: {
  genre: 'genre',
  author: 'author',
  popular: 'popular',
  etc: 'etc'
};

export type CategoryType = (typeof CategoryType)[keyof typeof CategoryType]


export const ViewSource: {
  text: 'text',
  audio: 'audio',
  referral: 'referral'
};

export type ViewSource = (typeof ViewSource)[keyof typeof ViewSource]


export const RoleName: {
  user: 'user',
  admin: 'admin',
  content_manager: 'content_manager'
};

export type RoleName = (typeof RoleName)[keyof typeof RoleName]


export const PublicationStatus: {
  draft: 'draft',
  published: 'published'
};

export type PublicationStatus = (typeof PublicationStatus)[keyof typeof PublicationStatus]

}

export type Language = $Enums.Language

export const Language: typeof $Enums.Language

export type BookType = $Enums.BookType

export const BookType: typeof $Enums.BookType

export type LikeTarget = $Enums.LikeTarget

export const LikeTarget: typeof $Enums.LikeTarget

export type CategoryType = $Enums.CategoryType

export const CategoryType: typeof $Enums.CategoryType

export type ViewSource = $Enums.ViewSource

export const ViewSource: typeof $Enums.ViewSource

export type RoleName = $Enums.RoleName

export const RoleName: typeof $Enums.RoleName

export type PublicationStatus = $Enums.PublicationStatus

export const PublicationStatus: typeof $Enums.PublicationStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Books
 * const books = await prisma.book.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Books
   * const books = await prisma.book.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.book`: Exposes CRUD operations for the **Book** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Books
    * const books = await prisma.book.findMany()
    * ```
    */
  get book(): Prisma.BookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookVersion`: Exposes CRUD operations for the **BookVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookVersions
    * const bookVersions = await prisma.bookVersion.findMany()
    * ```
    */
  get bookVersion(): Prisma.BookVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookSummary`: Exposes CRUD operations for the **BookSummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookSummaries
    * const bookSummaries = await prisma.bookSummary.findMany()
    * ```
    */
  get bookSummary(): Prisma.BookSummaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chapter`: Exposes CRUD operations for the **Chapter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chapters
    * const chapters = await prisma.chapter.findMany()
    * ```
    */
  get chapter(): Prisma.ChapterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audioChapter`: Exposes CRUD operations for the **AudioChapter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AudioChapters
    * const audioChapters = await prisma.audioChapter.findMany()
    * ```
    */
  get audioChapter(): Prisma.AudioChapterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookshelf`: Exposes CRUD operations for the **Bookshelf** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookshelves
    * const bookshelves = await prisma.bookshelf.findMany()
    * ```
    */
  get bookshelf(): Prisma.BookshelfDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.like`: Exposes CRUD operations for the **Like** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Likes
    * const likes = await prisma.like.findMany()
    * ```
    */
  get like(): Prisma.LikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookCategory`: Exposes CRUD operations for the **BookCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookCategories
    * const bookCategories = await prisma.bookCategory.findMany()
    * ```
    */
  get bookCategory(): Prisma.BookCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookTag`: Exposes CRUD operations for the **BookTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookTags
    * const bookTags = await prisma.bookTag.findMany()
    * ```
    */
  get bookTag(): Prisma.BookTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.viewStat`: Exposes CRUD operations for the **ViewStat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViewStats
    * const viewStats = await prisma.viewStat.findMany()
    * ```
    */
  get viewStat(): Prisma.ViewStatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.readingProgress`: Exposes CRUD operations for the **ReadingProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReadingProgresses
    * const readingProgresses = await prisma.readingProgress.findMany()
    * ```
    */
  get readingProgress(): Prisma.ReadingProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seo`: Exposes CRUD operations for the **Seo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seos
    * const seos = await prisma.seo.findMany()
    * ```
    */
  get seo(): Prisma.SeoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Book: 'Book',
    BookVersion: 'BookVersion',
    BookSummary: 'BookSummary',
    Chapter: 'Chapter',
    AudioChapter: 'AudioChapter',
    User: 'User',
    Bookshelf: 'Bookshelf',
    Comment: 'Comment',
    Like: 'Like',
    Category: 'Category',
    BookCategory: 'BookCategory',
    Tag: 'Tag',
    BookTag: 'BookTag',
    ViewStat: 'ViewStat',
    ReadingProgress: 'ReadingProgress',
    Seo: 'Seo',
    Role: 'Role',
    UserRole: 'UserRole'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "book" | "bookVersion" | "bookSummary" | "chapter" | "audioChapter" | "user" | "bookshelf" | "comment" | "like" | "category" | "bookCategory" | "tag" | "bookTag" | "viewStat" | "readingProgress" | "seo" | "role" | "userRole"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Book: {
        payload: Prisma.$BookPayload<ExtArgs>
        fields: Prisma.BookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          findFirst: {
            args: Prisma.BookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          findMany: {
            args: Prisma.BookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>[]
          }
          create: {
            args: Prisma.BookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          createMany: {
            args: Prisma.BookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>[]
          }
          delete: {
            args: Prisma.BookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          update: {
            args: Prisma.BookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          deleteMany: {
            args: Prisma.BookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>[]
          }
          upsert: {
            args: Prisma.BookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          aggregate: {
            args: Prisma.BookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBook>
          }
          groupBy: {
            args: Prisma.BookGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookCountArgs<ExtArgs>
            result: $Utils.Optional<BookCountAggregateOutputType> | number
          }
        }
      }
      BookVersion: {
        payload: Prisma.$BookVersionPayload<ExtArgs>
        fields: Prisma.BookVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookVersionPayload>
          }
          findFirst: {
            args: Prisma.BookVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookVersionPayload>
          }
          findMany: {
            args: Prisma.BookVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookVersionPayload>[]
          }
          create: {
            args: Prisma.BookVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookVersionPayload>
          }
          createMany: {
            args: Prisma.BookVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookVersionPayload>[]
          }
          delete: {
            args: Prisma.BookVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookVersionPayload>
          }
          update: {
            args: Prisma.BookVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookVersionPayload>
          }
          deleteMany: {
            args: Prisma.BookVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookVersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookVersionPayload>[]
          }
          upsert: {
            args: Prisma.BookVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookVersionPayload>
          }
          aggregate: {
            args: Prisma.BookVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookVersion>
          }
          groupBy: {
            args: Prisma.BookVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookVersionCountArgs<ExtArgs>
            result: $Utils.Optional<BookVersionCountAggregateOutputType> | number
          }
        }
      }
      BookSummary: {
        payload: Prisma.$BookSummaryPayload<ExtArgs>
        fields: Prisma.BookSummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookSummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookSummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSummaryPayload>
          }
          findFirst: {
            args: Prisma.BookSummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookSummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSummaryPayload>
          }
          findMany: {
            args: Prisma.BookSummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSummaryPayload>[]
          }
          create: {
            args: Prisma.BookSummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSummaryPayload>
          }
          createMany: {
            args: Prisma.BookSummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookSummaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSummaryPayload>[]
          }
          delete: {
            args: Prisma.BookSummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSummaryPayload>
          }
          update: {
            args: Prisma.BookSummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSummaryPayload>
          }
          deleteMany: {
            args: Prisma.BookSummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookSummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookSummaryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSummaryPayload>[]
          }
          upsert: {
            args: Prisma.BookSummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSummaryPayload>
          }
          aggregate: {
            args: Prisma.BookSummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookSummary>
          }
          groupBy: {
            args: Prisma.BookSummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookSummaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookSummaryCountArgs<ExtArgs>
            result: $Utils.Optional<BookSummaryCountAggregateOutputType> | number
          }
        }
      }
      Chapter: {
        payload: Prisma.$ChapterPayload<ExtArgs>
        fields: Prisma.ChapterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChapterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChapterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          findFirst: {
            args: Prisma.ChapterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChapterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          findMany: {
            args: Prisma.ChapterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          create: {
            args: Prisma.ChapterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          createMany: {
            args: Prisma.ChapterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChapterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          delete: {
            args: Prisma.ChapterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          update: {
            args: Prisma.ChapterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          deleteMany: {
            args: Prisma.ChapterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChapterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChapterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          upsert: {
            args: Prisma.ChapterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          aggregate: {
            args: Prisma.ChapterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapter>
          }
          groupBy: {
            args: Prisma.ChapterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChapterCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterCountAggregateOutputType> | number
          }
        }
      }
      AudioChapter: {
        payload: Prisma.$AudioChapterPayload<ExtArgs>
        fields: Prisma.AudioChapterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AudioChapterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChapterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AudioChapterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChapterPayload>
          }
          findFirst: {
            args: Prisma.AudioChapterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChapterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AudioChapterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChapterPayload>
          }
          findMany: {
            args: Prisma.AudioChapterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChapterPayload>[]
          }
          create: {
            args: Prisma.AudioChapterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChapterPayload>
          }
          createMany: {
            args: Prisma.AudioChapterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AudioChapterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChapterPayload>[]
          }
          delete: {
            args: Prisma.AudioChapterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChapterPayload>
          }
          update: {
            args: Prisma.AudioChapterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChapterPayload>
          }
          deleteMany: {
            args: Prisma.AudioChapterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AudioChapterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AudioChapterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChapterPayload>[]
          }
          upsert: {
            args: Prisma.AudioChapterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioChapterPayload>
          }
          aggregate: {
            args: Prisma.AudioChapterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudioChapter>
          }
          groupBy: {
            args: Prisma.AudioChapterGroupByArgs<ExtArgs>
            result: $Utils.Optional<AudioChapterGroupByOutputType>[]
          }
          count: {
            args: Prisma.AudioChapterCountArgs<ExtArgs>
            result: $Utils.Optional<AudioChapterCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Bookshelf: {
        payload: Prisma.$BookshelfPayload<ExtArgs>
        fields: Prisma.BookshelfFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookshelfFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookshelfPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookshelfFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookshelfPayload>
          }
          findFirst: {
            args: Prisma.BookshelfFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookshelfPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookshelfFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookshelfPayload>
          }
          findMany: {
            args: Prisma.BookshelfFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookshelfPayload>[]
          }
          create: {
            args: Prisma.BookshelfCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookshelfPayload>
          }
          createMany: {
            args: Prisma.BookshelfCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookshelfCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookshelfPayload>[]
          }
          delete: {
            args: Prisma.BookshelfDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookshelfPayload>
          }
          update: {
            args: Prisma.BookshelfUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookshelfPayload>
          }
          deleteMany: {
            args: Prisma.BookshelfDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookshelfUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookshelfUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookshelfPayload>[]
          }
          upsert: {
            args: Prisma.BookshelfUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookshelfPayload>
          }
          aggregate: {
            args: Prisma.BookshelfAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookshelf>
          }
          groupBy: {
            args: Prisma.BookshelfGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookshelfGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookshelfCountArgs<ExtArgs>
            result: $Utils.Optional<BookshelfCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Like: {
        payload: Prisma.$LikePayload<ExtArgs>
        fields: Prisma.LikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findFirst: {
            args: Prisma.LikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findMany: {
            args: Prisma.LikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          create: {
            args: Prisma.LikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          createMany: {
            args: Prisma.LikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          delete: {
            args: Prisma.LikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          update: {
            args: Prisma.LikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          deleteMany: {
            args: Prisma.LikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LikeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          upsert: {
            args: Prisma.LikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          aggregate: {
            args: Prisma.LikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLike>
          }
          groupBy: {
            args: Prisma.LikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LikeCountArgs<ExtArgs>
            result: $Utils.Optional<LikeCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      BookCategory: {
        payload: Prisma.$BookCategoryPayload<ExtArgs>
        fields: Prisma.BookCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookCategoryPayload>
          }
          findFirst: {
            args: Prisma.BookCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookCategoryPayload>
          }
          findMany: {
            args: Prisma.BookCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookCategoryPayload>[]
          }
          create: {
            args: Prisma.BookCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookCategoryPayload>
          }
          createMany: {
            args: Prisma.BookCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookCategoryPayload>[]
          }
          delete: {
            args: Prisma.BookCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookCategoryPayload>
          }
          update: {
            args: Prisma.BookCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookCategoryPayload>
          }
          deleteMany: {
            args: Prisma.BookCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookCategoryPayload>[]
          }
          upsert: {
            args: Prisma.BookCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookCategoryPayload>
          }
          aggregate: {
            args: Prisma.BookCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookCategory>
          }
          groupBy: {
            args: Prisma.BookCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<BookCategoryCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      BookTag: {
        payload: Prisma.$BookTagPayload<ExtArgs>
        fields: Prisma.BookTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookTagPayload>
          }
          findFirst: {
            args: Prisma.BookTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookTagPayload>
          }
          findMany: {
            args: Prisma.BookTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookTagPayload>[]
          }
          create: {
            args: Prisma.BookTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookTagPayload>
          }
          createMany: {
            args: Prisma.BookTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookTagPayload>[]
          }
          delete: {
            args: Prisma.BookTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookTagPayload>
          }
          update: {
            args: Prisma.BookTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookTagPayload>
          }
          deleteMany: {
            args: Prisma.BookTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookTagPayload>[]
          }
          upsert: {
            args: Prisma.BookTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookTagPayload>
          }
          aggregate: {
            args: Prisma.BookTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookTag>
          }
          groupBy: {
            args: Prisma.BookTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookTagCountArgs<ExtArgs>
            result: $Utils.Optional<BookTagCountAggregateOutputType> | number
          }
        }
      }
      ViewStat: {
        payload: Prisma.$ViewStatPayload<ExtArgs>
        fields: Prisma.ViewStatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViewStatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewStatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViewStatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewStatPayload>
          }
          findFirst: {
            args: Prisma.ViewStatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewStatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViewStatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewStatPayload>
          }
          findMany: {
            args: Prisma.ViewStatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewStatPayload>[]
          }
          create: {
            args: Prisma.ViewStatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewStatPayload>
          }
          createMany: {
            args: Prisma.ViewStatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViewStatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewStatPayload>[]
          }
          delete: {
            args: Prisma.ViewStatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewStatPayload>
          }
          update: {
            args: Prisma.ViewStatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewStatPayload>
          }
          deleteMany: {
            args: Prisma.ViewStatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViewStatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ViewStatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewStatPayload>[]
          }
          upsert: {
            args: Prisma.ViewStatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewStatPayload>
          }
          aggregate: {
            args: Prisma.ViewStatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViewStat>
          }
          groupBy: {
            args: Prisma.ViewStatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViewStatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViewStatCountArgs<ExtArgs>
            result: $Utils.Optional<ViewStatCountAggregateOutputType> | number
          }
        }
      }
      ReadingProgress: {
        payload: Prisma.$ReadingProgressPayload<ExtArgs>
        fields: Prisma.ReadingProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReadingProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReadingProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingProgressPayload>
          }
          findFirst: {
            args: Prisma.ReadingProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReadingProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingProgressPayload>
          }
          findMany: {
            args: Prisma.ReadingProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingProgressPayload>[]
          }
          create: {
            args: Prisma.ReadingProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingProgressPayload>
          }
          createMany: {
            args: Prisma.ReadingProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReadingProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingProgressPayload>[]
          }
          delete: {
            args: Prisma.ReadingProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingProgressPayload>
          }
          update: {
            args: Prisma.ReadingProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingProgressPayload>
          }
          deleteMany: {
            args: Prisma.ReadingProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReadingProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReadingProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingProgressPayload>[]
          }
          upsert: {
            args: Prisma.ReadingProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingProgressPayload>
          }
          aggregate: {
            args: Prisma.ReadingProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReadingProgress>
          }
          groupBy: {
            args: Prisma.ReadingProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReadingProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReadingProgressCountArgs<ExtArgs>
            result: $Utils.Optional<ReadingProgressCountAggregateOutputType> | number
          }
        }
      }
      Seo: {
        payload: Prisma.$SeoPayload<ExtArgs>
        fields: Prisma.SeoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload>
          }
          findFirst: {
            args: Prisma.SeoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload>
          }
          findMany: {
            args: Prisma.SeoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload>[]
          }
          create: {
            args: Prisma.SeoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload>
          }
          createMany: {
            args: Prisma.SeoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload>[]
          }
          delete: {
            args: Prisma.SeoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload>
          }
          update: {
            args: Prisma.SeoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload>
          }
          deleteMany: {
            args: Prisma.SeoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload>[]
          }
          upsert: {
            args: Prisma.SeoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoPayload>
          }
          aggregate: {
            args: Prisma.SeoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeo>
          }
          groupBy: {
            args: Prisma.SeoGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeoGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeoCountArgs<ExtArgs>
            result: $Utils.Optional<SeoCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    book?: BookOmit
    bookVersion?: BookVersionOmit
    bookSummary?: BookSummaryOmit
    chapter?: ChapterOmit
    audioChapter?: AudioChapterOmit
    user?: UserOmit
    bookshelf?: BookshelfOmit
    comment?: CommentOmit
    like?: LikeOmit
    category?: CategoryOmit
    bookCategory?: BookCategoryOmit
    tag?: TagOmit
    bookTag?: BookTagOmit
    viewStat?: ViewStatOmit
    readingProgress?: ReadingProgressOmit
    seo?: SeoOmit
    role?: RoleOmit
    userRole?: UserRoleOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BookCountOutputType
   */

  export type BookCountOutputType = {
    versions: number
  }

  export type BookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | BookCountOutputTypeCountVersionsArgs
  }

  // Custom InputTypes
  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCountOutputType
     */
    select?: BookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookVersionWhereInput
  }


  /**
   * Count Type BookVersionCountOutputType
   */

  export type BookVersionCountOutputType = {
    summaries: number
    chapters: number
    audioChapters: number
    bookshelf: number
    comments: number
    likes: number
    categories: number
    tags: number
    viewStats: number
    readingProgress: number
  }

  export type BookVersionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    summaries?: boolean | BookVersionCountOutputTypeCountSummariesArgs
    chapters?: boolean | BookVersionCountOutputTypeCountChaptersArgs
    audioChapters?: boolean | BookVersionCountOutputTypeCountAudioChaptersArgs
    bookshelf?: boolean | BookVersionCountOutputTypeCountBookshelfArgs
    comments?: boolean | BookVersionCountOutputTypeCountCommentsArgs
    likes?: boolean | BookVersionCountOutputTypeCountLikesArgs
    categories?: boolean | BookVersionCountOutputTypeCountCategoriesArgs
    tags?: boolean | BookVersionCountOutputTypeCountTagsArgs
    viewStats?: boolean | BookVersionCountOutputTypeCountViewStatsArgs
    readingProgress?: boolean | BookVersionCountOutputTypeCountReadingProgressArgs
  }

  // Custom InputTypes
  /**
   * BookVersionCountOutputType without action
   */
  export type BookVersionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookVersionCountOutputType
     */
    select?: BookVersionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookVersionCountOutputType without action
   */
  export type BookVersionCountOutputTypeCountSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookSummaryWhereInput
  }

  /**
   * BookVersionCountOutputType without action
   */
  export type BookVersionCountOutputTypeCountChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
  }

  /**
   * BookVersionCountOutputType without action
   */
  export type BookVersionCountOutputTypeCountAudioChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioChapterWhereInput
  }

  /**
   * BookVersionCountOutputType without action
   */
  export type BookVersionCountOutputTypeCountBookshelfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookshelfWhereInput
  }

  /**
   * BookVersionCountOutputType without action
   */
  export type BookVersionCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * BookVersionCountOutputType without action
   */
  export type BookVersionCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }

  /**
   * BookVersionCountOutputType without action
   */
  export type BookVersionCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookCategoryWhereInput
  }

  /**
   * BookVersionCountOutputType without action
   */
  export type BookVersionCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookTagWhereInput
  }

  /**
   * BookVersionCountOutputType without action
   */
  export type BookVersionCountOutputTypeCountViewStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewStatWhereInput
  }

  /**
   * BookVersionCountOutputType without action
   */
  export type BookVersionCountOutputTypeCountReadingProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReadingProgressWhereInput
  }


  /**
   * Count Type ChapterCountOutputType
   */

  export type ChapterCountOutputType = {
    comments: number
  }

  export type ChapterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | ChapterCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterCountOutputType
     */
    select?: ChapterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type AudioChapterCountOutputType
   */

  export type AudioChapterCountOutputType = {
    comments: number
  }

  export type AudioChapterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | AudioChapterCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * AudioChapterCountOutputType without action
   */
  export type AudioChapterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChapterCountOutputType
     */
    select?: AudioChapterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AudioChapterCountOutputType without action
   */
  export type AudioChapterCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    bookshelves: number
    comments: number
    likes: number
    viewStats: number
    readingProgress: number
    roles: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookshelves?: boolean | UserCountOutputTypeCountBookshelvesArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    likes?: boolean | UserCountOutputTypeCountLikesArgs
    viewStats?: boolean | UserCountOutputTypeCountViewStatsArgs
    readingProgress?: boolean | UserCountOutputTypeCountReadingProgressArgs
    roles?: boolean | UserCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookshelvesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookshelfWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountViewStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewStatWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReadingProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReadingProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    children: number
    likes: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CommentCountOutputTypeCountChildrenArgs
    likes?: boolean | CommentCountOutputTypeCountLikesArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    books: number
    children: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | CategoryCountOutputTypeCountBooksArgs
    children?: boolean | CategoryCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookCategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    books: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | TagCountOutputTypeCountBooksArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookTagWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Book
   */

  export type AggregateBook = {
    _count: BookCountAggregateOutputType | null
    _min: BookMinAggregateOutputType | null
    _max: BookMaxAggregateOutputType | null
  }

  export type BookMinAggregateOutputType = {
    id: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookCountAggregateOutputType = {
    id: number
    slug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookMinAggregateInputType = {
    id?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookMaxAggregateInputType = {
    id?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookCountAggregateInputType = {
    id?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Book to aggregate.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Books
    **/
    _count?: true | BookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookMaxAggregateInputType
  }

  export type GetBookAggregateType<T extends BookAggregateArgs> = {
        [P in keyof T & keyof AggregateBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook[P]>
      : GetScalarType<T[P], AggregateBook[P]>
  }




  export type BookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookWhereInput
    orderBy?: BookOrderByWithAggregationInput | BookOrderByWithAggregationInput[]
    by: BookScalarFieldEnum[] | BookScalarFieldEnum
    having?: BookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookCountAggregateInputType | true
    _min?: BookMinAggregateInputType
    _max?: BookMaxAggregateInputType
  }

  export type BookGroupByOutputType = {
    id: string
    slug: string
    createdAt: Date
    updatedAt: Date
    _count: BookCountAggregateOutputType | null
    _min: BookMinAggregateOutputType | null
    _max: BookMaxAggregateOutputType | null
  }

  type GetBookGroupByPayload<T extends BookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookGroupByOutputType[P]>
            : GetScalarType<T[P], BookGroupByOutputType[P]>
        }
      >
    >


  export type BookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    versions?: boolean | Book$versionsArgs<ExtArgs>
    _count?: boolean | BookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book"]>

  export type BookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["book"]>

  export type BookSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["book"]>

  export type BookSelectScalar = {
    id?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "createdAt" | "updatedAt", ExtArgs["result"]["book"]>
  export type BookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | Book$versionsArgs<ExtArgs>
    _count?: boolean | BookCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BookIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Book"
    objects: {
      versions: Prisma.$BookVersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["book"]>
    composites: {}
  }

  type BookGetPayload<S extends boolean | null | undefined | BookDefaultArgs> = $Result.GetResult<Prisma.$BookPayload, S>

  type BookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookCountAggregateInputType | true
    }

  export interface BookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Book'], meta: { name: 'Book' } }
    /**
     * Find zero or one Book that matches the filter.
     * @param {BookFindUniqueArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookFindUniqueArgs>(args: SelectSubset<T, BookFindUniqueArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Book that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookFindUniqueOrThrowArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookFindUniqueOrThrowArgs>(args: SelectSubset<T, BookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindFirstArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookFindFirstArgs>(args?: SelectSubset<T, BookFindFirstArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindFirstOrThrowArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookFindFirstOrThrowArgs>(args?: SelectSubset<T, BookFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Books
     * const books = await prisma.book.findMany()
     * 
     * // Get first 10 Books
     * const books = await prisma.book.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookWithIdOnly = await prisma.book.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookFindManyArgs>(args?: SelectSubset<T, BookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Book.
     * @param {BookCreateArgs} args - Arguments to create a Book.
     * @example
     * // Create one Book
     * const Book = await prisma.book.create({
     *   data: {
     *     // ... data to create a Book
     *   }
     * })
     * 
     */
    create<T extends BookCreateArgs>(args: SelectSubset<T, BookCreateArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Books.
     * @param {BookCreateManyArgs} args - Arguments to create many Books.
     * @example
     * // Create many Books
     * const book = await prisma.book.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookCreateManyArgs>(args?: SelectSubset<T, BookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Books and returns the data saved in the database.
     * @param {BookCreateManyAndReturnArgs} args - Arguments to create many Books.
     * @example
     * // Create many Books
     * const book = await prisma.book.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Books and only return the `id`
     * const bookWithIdOnly = await prisma.book.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookCreateManyAndReturnArgs>(args?: SelectSubset<T, BookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Book.
     * @param {BookDeleteArgs} args - Arguments to delete one Book.
     * @example
     * // Delete one Book
     * const Book = await prisma.book.delete({
     *   where: {
     *     // ... filter to delete one Book
     *   }
     * })
     * 
     */
    delete<T extends BookDeleteArgs>(args: SelectSubset<T, BookDeleteArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Book.
     * @param {BookUpdateArgs} args - Arguments to update one Book.
     * @example
     * // Update one Book
     * const book = await prisma.book.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookUpdateArgs>(args: SelectSubset<T, BookUpdateArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Books.
     * @param {BookDeleteManyArgs} args - Arguments to filter Books to delete.
     * @example
     * // Delete a few Books
     * const { count } = await prisma.book.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookDeleteManyArgs>(args?: SelectSubset<T, BookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Books
     * const book = await prisma.book.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookUpdateManyArgs>(args: SelectSubset<T, BookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books and returns the data updated in the database.
     * @param {BookUpdateManyAndReturnArgs} args - Arguments to update many Books.
     * @example
     * // Update many Books
     * const book = await prisma.book.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Books and only return the `id`
     * const bookWithIdOnly = await prisma.book.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookUpdateManyAndReturnArgs>(args: SelectSubset<T, BookUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Book.
     * @param {BookUpsertArgs} args - Arguments to update or create a Book.
     * @example
     * // Update or create a Book
     * const book = await prisma.book.upsert({
     *   create: {
     *     // ... data to create a Book
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book we want to update
     *   }
     * })
     */
    upsert<T extends BookUpsertArgs>(args: SelectSubset<T, BookUpsertArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCountArgs} args - Arguments to filter Books to count.
     * @example
     * // Count the number of Books
     * const count = await prisma.book.count({
     *   where: {
     *     // ... the filter for the Books we want to count
     *   }
     * })
    **/
    count<T extends BookCountArgs>(
      args?: Subset<T, BookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookAggregateArgs>(args: Subset<T, BookAggregateArgs>): Prisma.PrismaPromise<GetBookAggregateType<T>>

    /**
     * Group by Book.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookGroupByArgs['orderBy'] }
        : { orderBy?: BookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Book model
   */
  readonly fields: BookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Book.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    versions<T extends Book$versionsArgs<ExtArgs> = {}>(args?: Subset<T, Book$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Book model
   */
  interface BookFieldRefs {
    readonly id: FieldRef<"Book", 'String'>
    readonly slug: FieldRef<"Book", 'String'>
    readonly createdAt: FieldRef<"Book", 'DateTime'>
    readonly updatedAt: FieldRef<"Book", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Book findUnique
   */
  export type BookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book findUniqueOrThrow
   */
  export type BookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book findFirst
   */
  export type BookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Books.
     */
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Book findFirstOrThrow
   */
  export type BookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Books.
     */
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Book findMany
   */
  export type BookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Books to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Book create
   */
  export type BookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * The data needed to create a Book.
     */
    data: XOR<BookCreateInput, BookUncheckedCreateInput>
  }

  /**
   * Book createMany
   */
  export type BookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Books.
     */
    data: BookCreateManyInput | BookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Book createManyAndReturn
   */
  export type BookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * The data used to create many Books.
     */
    data: BookCreateManyInput | BookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Book update
   */
  export type BookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * The data needed to update a Book.
     */
    data: XOR<BookUpdateInput, BookUncheckedUpdateInput>
    /**
     * Choose, which Book to update.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book updateMany
   */
  export type BookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Books.
     */
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyInput>
    /**
     * Filter which Books to update
     */
    where?: BookWhereInput
    /**
     * Limit how many Books to update.
     */
    limit?: number
  }

  /**
   * Book updateManyAndReturn
   */
  export type BookUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * The data used to update Books.
     */
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyInput>
    /**
     * Filter which Books to update
     */
    where?: BookWhereInput
    /**
     * Limit how many Books to update.
     */
    limit?: number
  }

  /**
   * Book upsert
   */
  export type BookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * The filter to search for the Book to update in case it exists.
     */
    where: BookWhereUniqueInput
    /**
     * In case the Book found by the `where` argument doesn't exist, create a new Book with this data.
     */
    create: XOR<BookCreateInput, BookUncheckedCreateInput>
    /**
     * In case the Book was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookUpdateInput, BookUncheckedUpdateInput>
  }

  /**
   * Book delete
   */
  export type BookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter which Book to delete.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book deleteMany
   */
  export type BookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Books to delete
     */
    where?: BookWhereInput
    /**
     * Limit how many Books to delete.
     */
    limit?: number
  }

  /**
   * Book.versions
   */
  export type Book$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookVersion
     */
    select?: BookVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookVersion
     */
    omit?: BookVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookVersionInclude<ExtArgs> | null
    where?: BookVersionWhereInput
    orderBy?: BookVersionOrderByWithRelationInput | BookVersionOrderByWithRelationInput[]
    cursor?: BookVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookVersionScalarFieldEnum | BookVersionScalarFieldEnum[]
  }

  /**
   * Book without action
   */
  export type BookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
  }


  /**
   * Model BookVersion
   */

  export type AggregateBookVersion = {
    _count: BookVersionCountAggregateOutputType | null
    _avg: BookVersionAvgAggregateOutputType | null
    _sum: BookVersionSumAggregateOutputType | null
    _min: BookVersionMinAggregateOutputType | null
    _max: BookVersionMaxAggregateOutputType | null
  }

  export type BookVersionAvgAggregateOutputType = {
    seoId: number | null
  }

  export type BookVersionSumAggregateOutputType = {
    seoId: number | null
  }

  export type BookVersionMinAggregateOutputType = {
    id: string | null
    bookId: string | null
    language: $Enums.Language | null
    title: string | null
    author: string | null
    description: string | null
    coverImageUrl: string | null
    type: $Enums.BookType | null
    isFree: boolean | null
    referralUrl: string | null
    status: $Enums.PublicationStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    seoId: number | null
  }

  export type BookVersionMaxAggregateOutputType = {
    id: string | null
    bookId: string | null
    language: $Enums.Language | null
    title: string | null
    author: string | null
    description: string | null
    coverImageUrl: string | null
    type: $Enums.BookType | null
    isFree: boolean | null
    referralUrl: string | null
    status: $Enums.PublicationStatus | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    seoId: number | null
  }

  export type BookVersionCountAggregateOutputType = {
    id: number
    bookId: number
    language: number
    title: number
    author: number
    description: number
    coverImageUrl: number
    type: number
    isFree: number
    referralUrl: number
    status: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    seoId: number
    _all: number
  }


  export type BookVersionAvgAggregateInputType = {
    seoId?: true
  }

  export type BookVersionSumAggregateInputType = {
    seoId?: true
  }

  export type BookVersionMinAggregateInputType = {
    id?: true
    bookId?: true
    language?: true
    title?: true
    author?: true
    description?: true
    coverImageUrl?: true
    type?: true
    isFree?: true
    referralUrl?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    seoId?: true
  }

  export type BookVersionMaxAggregateInputType = {
    id?: true
    bookId?: true
    language?: true
    title?: true
    author?: true
    description?: true
    coverImageUrl?: true
    type?: true
    isFree?: true
    referralUrl?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    seoId?: true
  }

  export type BookVersionCountAggregateInputType = {
    id?: true
    bookId?: true
    language?: true
    title?: true
    author?: true
    description?: true
    coverImageUrl?: true
    type?: true
    isFree?: true
    referralUrl?: true
    status?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    seoId?: true
    _all?: true
  }

  export type BookVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookVersion to aggregate.
     */
    where?: BookVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookVersions to fetch.
     */
    orderBy?: BookVersionOrderByWithRelationInput | BookVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookVersions
    **/
    _count?: true | BookVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookVersionMaxAggregateInputType
  }

  export type GetBookVersionAggregateType<T extends BookVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateBookVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookVersion[P]>
      : GetScalarType<T[P], AggregateBookVersion[P]>
  }




  export type BookVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookVersionWhereInput
    orderBy?: BookVersionOrderByWithAggregationInput | BookVersionOrderByWithAggregationInput[]
    by: BookVersionScalarFieldEnum[] | BookVersionScalarFieldEnum
    having?: BookVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookVersionCountAggregateInputType | true
    _avg?: BookVersionAvgAggregateInputType
    _sum?: BookVersionSumAggregateInputType
    _min?: BookVersionMinAggregateInputType
    _max?: BookVersionMaxAggregateInputType
  }

  export type BookVersionGroupByOutputType = {
    id: string
    bookId: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl: string | null
    status: $Enums.PublicationStatus
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    seoId: number | null
    _count: BookVersionCountAggregateOutputType | null
    _avg: BookVersionAvgAggregateOutputType | null
    _sum: BookVersionSumAggregateOutputType | null
    _min: BookVersionMinAggregateOutputType | null
    _max: BookVersionMaxAggregateOutputType | null
  }

  type GetBookVersionGroupByPayload<T extends BookVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookVersionGroupByOutputType[P]>
            : GetScalarType<T[P], BookVersionGroupByOutputType[P]>
        }
      >
    >


  export type BookVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookId?: boolean
    language?: boolean
    title?: boolean
    author?: boolean
    description?: boolean
    coverImageUrl?: boolean
    type?: boolean
    isFree?: boolean
    referralUrl?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seoId?: boolean
    book?: boolean | BookDefaultArgs<ExtArgs>
    summaries?: boolean | BookVersion$summariesArgs<ExtArgs>
    chapters?: boolean | BookVersion$chaptersArgs<ExtArgs>
    audioChapters?: boolean | BookVersion$audioChaptersArgs<ExtArgs>
    bookshelf?: boolean | BookVersion$bookshelfArgs<ExtArgs>
    comments?: boolean | BookVersion$commentsArgs<ExtArgs>
    likes?: boolean | BookVersion$likesArgs<ExtArgs>
    categories?: boolean | BookVersion$categoriesArgs<ExtArgs>
    tags?: boolean | BookVersion$tagsArgs<ExtArgs>
    viewStats?: boolean | BookVersion$viewStatsArgs<ExtArgs>
    readingProgress?: boolean | BookVersion$readingProgressArgs<ExtArgs>
    seo?: boolean | BookVersion$seoArgs<ExtArgs>
    _count?: boolean | BookVersionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookVersion"]>

  export type BookVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookId?: boolean
    language?: boolean
    title?: boolean
    author?: boolean
    description?: boolean
    coverImageUrl?: boolean
    type?: boolean
    isFree?: boolean
    referralUrl?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seoId?: boolean
    book?: boolean | BookDefaultArgs<ExtArgs>
    seo?: boolean | BookVersion$seoArgs<ExtArgs>
  }, ExtArgs["result"]["bookVersion"]>

  export type BookVersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookId?: boolean
    language?: boolean
    title?: boolean
    author?: boolean
    description?: boolean
    coverImageUrl?: boolean
    type?: boolean
    isFree?: boolean
    referralUrl?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seoId?: boolean
    book?: boolean | BookDefaultArgs<ExtArgs>
    seo?: boolean | BookVersion$seoArgs<ExtArgs>
  }, ExtArgs["result"]["bookVersion"]>

  export type BookVersionSelectScalar = {
    id?: boolean
    bookId?: boolean
    language?: boolean
    title?: boolean
    author?: boolean
    description?: boolean
    coverImageUrl?: boolean
    type?: boolean
    isFree?: boolean
    referralUrl?: boolean
    status?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seoId?: boolean
  }

  export type BookVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookId" | "language" | "title" | "author" | "description" | "coverImageUrl" | "type" | "isFree" | "referralUrl" | "status" | "publishedAt" | "createdAt" | "updatedAt" | "seoId", ExtArgs["result"]["bookVersion"]>
  export type BookVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BookDefaultArgs<ExtArgs>
    summaries?: boolean | BookVersion$summariesArgs<ExtArgs>
    chapters?: boolean | BookVersion$chaptersArgs<ExtArgs>
    audioChapters?: boolean | BookVersion$audioChaptersArgs<ExtArgs>
    bookshelf?: boolean | BookVersion$bookshelfArgs<ExtArgs>
    comments?: boolean | BookVersion$commentsArgs<ExtArgs>
    likes?: boolean | BookVersion$likesArgs<ExtArgs>
    categories?: boolean | BookVersion$categoriesArgs<ExtArgs>
    tags?: boolean | BookVersion$tagsArgs<ExtArgs>
    viewStats?: boolean | BookVersion$viewStatsArgs<ExtArgs>
    readingProgress?: boolean | BookVersion$readingProgressArgs<ExtArgs>
    seo?: boolean | BookVersion$seoArgs<ExtArgs>
    _count?: boolean | BookVersionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BookDefaultArgs<ExtArgs>
    seo?: boolean | BookVersion$seoArgs<ExtArgs>
  }
  export type BookVersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BookDefaultArgs<ExtArgs>
    seo?: boolean | BookVersion$seoArgs<ExtArgs>
  }

  export type $BookVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookVersion"
    objects: {
      book: Prisma.$BookPayload<ExtArgs>
      summaries: Prisma.$BookSummaryPayload<ExtArgs>[]
      chapters: Prisma.$ChapterPayload<ExtArgs>[]
      audioChapters: Prisma.$AudioChapterPayload<ExtArgs>[]
      bookshelf: Prisma.$BookshelfPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      likes: Prisma.$LikePayload<ExtArgs>[]
      categories: Prisma.$BookCategoryPayload<ExtArgs>[]
      tags: Prisma.$BookTagPayload<ExtArgs>[]
      viewStats: Prisma.$ViewStatPayload<ExtArgs>[]
      readingProgress: Prisma.$ReadingProgressPayload<ExtArgs>[]
      seo: Prisma.$SeoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookId: string
      language: $Enums.Language
      title: string
      author: string
      description: string
      coverImageUrl: string
      type: $Enums.BookType
      isFree: boolean
      referralUrl: string | null
      status: $Enums.PublicationStatus
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
      seoId: number | null
    }, ExtArgs["result"]["bookVersion"]>
    composites: {}
  }

  type BookVersionGetPayload<S extends boolean | null | undefined | BookVersionDefaultArgs> = $Result.GetResult<Prisma.$BookVersionPayload, S>

  type BookVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookVersionCountAggregateInputType | true
    }

  export interface BookVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookVersion'], meta: { name: 'BookVersion' } }
    /**
     * Find zero or one BookVersion that matches the filter.
     * @param {BookVersionFindUniqueArgs} args - Arguments to find a BookVersion
     * @example
     * // Get one BookVersion
     * const bookVersion = await prisma.bookVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookVersionFindUniqueArgs>(args: SelectSubset<T, BookVersionFindUniqueArgs<ExtArgs>>): Prisma__BookVersionClient<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookVersionFindUniqueOrThrowArgs} args - Arguments to find a BookVersion
     * @example
     * // Get one BookVersion
     * const bookVersion = await prisma.bookVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, BookVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookVersionClient<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookVersionFindFirstArgs} args - Arguments to find a BookVersion
     * @example
     * // Get one BookVersion
     * const bookVersion = await prisma.bookVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookVersionFindFirstArgs>(args?: SelectSubset<T, BookVersionFindFirstArgs<ExtArgs>>): Prisma__BookVersionClient<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookVersionFindFirstOrThrowArgs} args - Arguments to find a BookVersion
     * @example
     * // Get one BookVersion
     * const bookVersion = await prisma.bookVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, BookVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookVersionClient<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookVersions
     * const bookVersions = await prisma.bookVersion.findMany()
     * 
     * // Get first 10 BookVersions
     * const bookVersions = await prisma.bookVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookVersionWithIdOnly = await prisma.bookVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookVersionFindManyArgs>(args?: SelectSubset<T, BookVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookVersion.
     * @param {BookVersionCreateArgs} args - Arguments to create a BookVersion.
     * @example
     * // Create one BookVersion
     * const BookVersion = await prisma.bookVersion.create({
     *   data: {
     *     // ... data to create a BookVersion
     *   }
     * })
     * 
     */
    create<T extends BookVersionCreateArgs>(args: SelectSubset<T, BookVersionCreateArgs<ExtArgs>>): Prisma__BookVersionClient<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookVersions.
     * @param {BookVersionCreateManyArgs} args - Arguments to create many BookVersions.
     * @example
     * // Create many BookVersions
     * const bookVersion = await prisma.bookVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookVersionCreateManyArgs>(args?: SelectSubset<T, BookVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookVersions and returns the data saved in the database.
     * @param {BookVersionCreateManyAndReturnArgs} args - Arguments to create many BookVersions.
     * @example
     * // Create many BookVersions
     * const bookVersion = await prisma.bookVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookVersions and only return the `id`
     * const bookVersionWithIdOnly = await prisma.bookVersion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, BookVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookVersion.
     * @param {BookVersionDeleteArgs} args - Arguments to delete one BookVersion.
     * @example
     * // Delete one BookVersion
     * const BookVersion = await prisma.bookVersion.delete({
     *   where: {
     *     // ... filter to delete one BookVersion
     *   }
     * })
     * 
     */
    delete<T extends BookVersionDeleteArgs>(args: SelectSubset<T, BookVersionDeleteArgs<ExtArgs>>): Prisma__BookVersionClient<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookVersion.
     * @param {BookVersionUpdateArgs} args - Arguments to update one BookVersion.
     * @example
     * // Update one BookVersion
     * const bookVersion = await prisma.bookVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookVersionUpdateArgs>(args: SelectSubset<T, BookVersionUpdateArgs<ExtArgs>>): Prisma__BookVersionClient<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookVersions.
     * @param {BookVersionDeleteManyArgs} args - Arguments to filter BookVersions to delete.
     * @example
     * // Delete a few BookVersions
     * const { count } = await prisma.bookVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookVersionDeleteManyArgs>(args?: SelectSubset<T, BookVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookVersions
     * const bookVersion = await prisma.bookVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookVersionUpdateManyArgs>(args: SelectSubset<T, BookVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookVersions and returns the data updated in the database.
     * @param {BookVersionUpdateManyAndReturnArgs} args - Arguments to update many BookVersions.
     * @example
     * // Update many BookVersions
     * const bookVersion = await prisma.bookVersion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookVersions and only return the `id`
     * const bookVersionWithIdOnly = await prisma.bookVersion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookVersionUpdateManyAndReturnArgs>(args: SelectSubset<T, BookVersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookVersion.
     * @param {BookVersionUpsertArgs} args - Arguments to update or create a BookVersion.
     * @example
     * // Update or create a BookVersion
     * const bookVersion = await prisma.bookVersion.upsert({
     *   create: {
     *     // ... data to create a BookVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookVersion we want to update
     *   }
     * })
     */
    upsert<T extends BookVersionUpsertArgs>(args: SelectSubset<T, BookVersionUpsertArgs<ExtArgs>>): Prisma__BookVersionClient<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookVersionCountArgs} args - Arguments to filter BookVersions to count.
     * @example
     * // Count the number of BookVersions
     * const count = await prisma.bookVersion.count({
     *   where: {
     *     // ... the filter for the BookVersions we want to count
     *   }
     * })
    **/
    count<T extends BookVersionCountArgs>(
      args?: Subset<T, BookVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookVersionAggregateArgs>(args: Subset<T, BookVersionAggregateArgs>): Prisma.PrismaPromise<GetBookVersionAggregateType<T>>

    /**
     * Group by BookVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookVersionGroupByArgs['orderBy'] }
        : { orderBy?: BookVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookVersion model
   */
  readonly fields: BookVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    book<T extends BookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookDefaultArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    summaries<T extends BookVersion$summariesArgs<ExtArgs> = {}>(args?: Subset<T, BookVersion$summariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chapters<T extends BookVersion$chaptersArgs<ExtArgs> = {}>(args?: Subset<T, BookVersion$chaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    audioChapters<T extends BookVersion$audioChaptersArgs<ExtArgs> = {}>(args?: Subset<T, BookVersion$audioChaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookshelf<T extends BookVersion$bookshelfArgs<ExtArgs> = {}>(args?: Subset<T, BookVersion$bookshelfArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookshelfPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends BookVersion$commentsArgs<ExtArgs> = {}>(args?: Subset<T, BookVersion$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends BookVersion$likesArgs<ExtArgs> = {}>(args?: Subset<T, BookVersion$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends BookVersion$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, BookVersion$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends BookVersion$tagsArgs<ExtArgs> = {}>(args?: Subset<T, BookVersion$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    viewStats<T extends BookVersion$viewStatsArgs<ExtArgs> = {}>(args?: Subset<T, BookVersion$viewStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewStatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    readingProgress<T extends BookVersion$readingProgressArgs<ExtArgs> = {}>(args?: Subset<T, BookVersion$readingProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadingProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seo<T extends BookVersion$seoArgs<ExtArgs> = {}>(args?: Subset<T, BookVersion$seoArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookVersion model
   */
  interface BookVersionFieldRefs {
    readonly id: FieldRef<"BookVersion", 'String'>
    readonly bookId: FieldRef<"BookVersion", 'String'>
    readonly language: FieldRef<"BookVersion", 'Language'>
    readonly title: FieldRef<"BookVersion", 'String'>
    readonly author: FieldRef<"BookVersion", 'String'>
    readonly description: FieldRef<"BookVersion", 'String'>
    readonly coverImageUrl: FieldRef<"BookVersion", 'String'>
    readonly type: FieldRef<"BookVersion", 'BookType'>
    readonly isFree: FieldRef<"BookVersion", 'Boolean'>
    readonly referralUrl: FieldRef<"BookVersion", 'String'>
    readonly status: FieldRef<"BookVersion", 'PublicationStatus'>
    readonly publishedAt: FieldRef<"BookVersion", 'DateTime'>
    readonly createdAt: FieldRef<"BookVersion", 'DateTime'>
    readonly updatedAt: FieldRef<"BookVersion", 'DateTime'>
    readonly seoId: FieldRef<"BookVersion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BookVersion findUnique
   */
  export type BookVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookVersion
     */
    select?: BookVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookVersion
     */
    omit?: BookVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookVersionInclude<ExtArgs> | null
    /**
     * Filter, which BookVersion to fetch.
     */
    where: BookVersionWhereUniqueInput
  }

  /**
   * BookVersion findUniqueOrThrow
   */
  export type BookVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookVersion
     */
    select?: BookVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookVersion
     */
    omit?: BookVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookVersionInclude<ExtArgs> | null
    /**
     * Filter, which BookVersion to fetch.
     */
    where: BookVersionWhereUniqueInput
  }

  /**
   * BookVersion findFirst
   */
  export type BookVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookVersion
     */
    select?: BookVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookVersion
     */
    omit?: BookVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookVersionInclude<ExtArgs> | null
    /**
     * Filter, which BookVersion to fetch.
     */
    where?: BookVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookVersions to fetch.
     */
    orderBy?: BookVersionOrderByWithRelationInput | BookVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookVersions.
     */
    cursor?: BookVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookVersions.
     */
    distinct?: BookVersionScalarFieldEnum | BookVersionScalarFieldEnum[]
  }

  /**
   * BookVersion findFirstOrThrow
   */
  export type BookVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookVersion
     */
    select?: BookVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookVersion
     */
    omit?: BookVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookVersionInclude<ExtArgs> | null
    /**
     * Filter, which BookVersion to fetch.
     */
    where?: BookVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookVersions to fetch.
     */
    orderBy?: BookVersionOrderByWithRelationInput | BookVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookVersions.
     */
    cursor?: BookVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookVersions.
     */
    distinct?: BookVersionScalarFieldEnum | BookVersionScalarFieldEnum[]
  }

  /**
   * BookVersion findMany
   */
  export type BookVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookVersion
     */
    select?: BookVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookVersion
     */
    omit?: BookVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookVersionInclude<ExtArgs> | null
    /**
     * Filter, which BookVersions to fetch.
     */
    where?: BookVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookVersions to fetch.
     */
    orderBy?: BookVersionOrderByWithRelationInput | BookVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookVersions.
     */
    cursor?: BookVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookVersions.
     */
    skip?: number
    distinct?: BookVersionScalarFieldEnum | BookVersionScalarFieldEnum[]
  }

  /**
   * BookVersion create
   */
  export type BookVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookVersion
     */
    select?: BookVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookVersion
     */
    omit?: BookVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a BookVersion.
     */
    data: XOR<BookVersionCreateInput, BookVersionUncheckedCreateInput>
  }

  /**
   * BookVersion createMany
   */
  export type BookVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookVersions.
     */
    data: BookVersionCreateManyInput | BookVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookVersion createManyAndReturn
   */
  export type BookVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookVersion
     */
    select?: BookVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookVersion
     */
    omit?: BookVersionOmit<ExtArgs> | null
    /**
     * The data used to create many BookVersions.
     */
    data: BookVersionCreateManyInput | BookVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookVersion update
   */
  export type BookVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookVersion
     */
    select?: BookVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookVersion
     */
    omit?: BookVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a BookVersion.
     */
    data: XOR<BookVersionUpdateInput, BookVersionUncheckedUpdateInput>
    /**
     * Choose, which BookVersion to update.
     */
    where: BookVersionWhereUniqueInput
  }

  /**
   * BookVersion updateMany
   */
  export type BookVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookVersions.
     */
    data: XOR<BookVersionUpdateManyMutationInput, BookVersionUncheckedUpdateManyInput>
    /**
     * Filter which BookVersions to update
     */
    where?: BookVersionWhereInput
    /**
     * Limit how many BookVersions to update.
     */
    limit?: number
  }

  /**
   * BookVersion updateManyAndReturn
   */
  export type BookVersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookVersion
     */
    select?: BookVersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookVersion
     */
    omit?: BookVersionOmit<ExtArgs> | null
    /**
     * The data used to update BookVersions.
     */
    data: XOR<BookVersionUpdateManyMutationInput, BookVersionUncheckedUpdateManyInput>
    /**
     * Filter which BookVersions to update
     */
    where?: BookVersionWhereInput
    /**
     * Limit how many BookVersions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookVersionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookVersion upsert
   */
  export type BookVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookVersion
     */
    select?: BookVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookVersion
     */
    omit?: BookVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the BookVersion to update in case it exists.
     */
    where: BookVersionWhereUniqueInput
    /**
     * In case the BookVersion found by the `where` argument doesn't exist, create a new BookVersion with this data.
     */
    create: XOR<BookVersionCreateInput, BookVersionUncheckedCreateInput>
    /**
     * In case the BookVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookVersionUpdateInput, BookVersionUncheckedUpdateInput>
  }

  /**
   * BookVersion delete
   */
  export type BookVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookVersion
     */
    select?: BookVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookVersion
     */
    omit?: BookVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookVersionInclude<ExtArgs> | null
    /**
     * Filter which BookVersion to delete.
     */
    where: BookVersionWhereUniqueInput
  }

  /**
   * BookVersion deleteMany
   */
  export type BookVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookVersions to delete
     */
    where?: BookVersionWhereInput
    /**
     * Limit how many BookVersions to delete.
     */
    limit?: number
  }

  /**
   * BookVersion.summaries
   */
  export type BookVersion$summariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSummary
     */
    select?: BookSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSummary
     */
    omit?: BookSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSummaryInclude<ExtArgs> | null
    where?: BookSummaryWhereInput
    orderBy?: BookSummaryOrderByWithRelationInput | BookSummaryOrderByWithRelationInput[]
    cursor?: BookSummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookSummaryScalarFieldEnum | BookSummaryScalarFieldEnum[]
  }

  /**
   * BookVersion.chapters
   */
  export type BookVersion$chaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    cursor?: ChapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * BookVersion.audioChapters
   */
  export type BookVersion$audioChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChapter
     */
    select?: AudioChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioChapter
     */
    omit?: AudioChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChapterInclude<ExtArgs> | null
    where?: AudioChapterWhereInput
    orderBy?: AudioChapterOrderByWithRelationInput | AudioChapterOrderByWithRelationInput[]
    cursor?: AudioChapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudioChapterScalarFieldEnum | AudioChapterScalarFieldEnum[]
  }

  /**
   * BookVersion.bookshelf
   */
  export type BookVersion$bookshelfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookshelf
     */
    select?: BookshelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookshelf
     */
    omit?: BookshelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookshelfInclude<ExtArgs> | null
    where?: BookshelfWhereInput
    orderBy?: BookshelfOrderByWithRelationInput | BookshelfOrderByWithRelationInput[]
    cursor?: BookshelfWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookshelfScalarFieldEnum | BookshelfScalarFieldEnum[]
  }

  /**
   * BookVersion.comments
   */
  export type BookVersion$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * BookVersion.likes
   */
  export type BookVersion$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * BookVersion.categories
   */
  export type BookVersion$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCategory
     */
    omit?: BookCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCategoryInclude<ExtArgs> | null
    where?: BookCategoryWhereInput
    orderBy?: BookCategoryOrderByWithRelationInput | BookCategoryOrderByWithRelationInput[]
    cursor?: BookCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookCategoryScalarFieldEnum | BookCategoryScalarFieldEnum[]
  }

  /**
   * BookVersion.tags
   */
  export type BookVersion$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookTag
     */
    select?: BookTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookTag
     */
    omit?: BookTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookTagInclude<ExtArgs> | null
    where?: BookTagWhereInput
    orderBy?: BookTagOrderByWithRelationInput | BookTagOrderByWithRelationInput[]
    cursor?: BookTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookTagScalarFieldEnum | BookTagScalarFieldEnum[]
  }

  /**
   * BookVersion.viewStats
   */
  export type BookVersion$viewStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewStat
     */
    select?: ViewStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewStat
     */
    omit?: ViewStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewStatInclude<ExtArgs> | null
    where?: ViewStatWhereInput
    orderBy?: ViewStatOrderByWithRelationInput | ViewStatOrderByWithRelationInput[]
    cursor?: ViewStatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViewStatScalarFieldEnum | ViewStatScalarFieldEnum[]
  }

  /**
   * BookVersion.readingProgress
   */
  export type BookVersion$readingProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingProgress
     */
    select?: ReadingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadingProgress
     */
    omit?: ReadingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingProgressInclude<ExtArgs> | null
    where?: ReadingProgressWhereInput
    orderBy?: ReadingProgressOrderByWithRelationInput | ReadingProgressOrderByWithRelationInput[]
    cursor?: ReadingProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReadingProgressScalarFieldEnum | ReadingProgressScalarFieldEnum[]
  }

  /**
   * BookVersion.seo
   */
  export type BookVersion$seoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    where?: SeoWhereInput
  }

  /**
   * BookVersion without action
   */
  export type BookVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookVersion
     */
    select?: BookVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookVersion
     */
    omit?: BookVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookVersionInclude<ExtArgs> | null
  }


  /**
   * Model BookSummary
   */

  export type AggregateBookSummary = {
    _count: BookSummaryCountAggregateOutputType | null
    _min: BookSummaryMinAggregateOutputType | null
    _max: BookSummaryMaxAggregateOutputType | null
  }

  export type BookSummaryMinAggregateOutputType = {
    id: string | null
    bookVersionId: string | null
    summary: string | null
    analysis: string | null
    themes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookSummaryMaxAggregateOutputType = {
    id: string | null
    bookVersionId: string | null
    summary: string | null
    analysis: string | null
    themes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookSummaryCountAggregateOutputType = {
    id: number
    bookVersionId: number
    summary: number
    analysis: number
    themes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookSummaryMinAggregateInputType = {
    id?: true
    bookVersionId?: true
    summary?: true
    analysis?: true
    themes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookSummaryMaxAggregateInputType = {
    id?: true
    bookVersionId?: true
    summary?: true
    analysis?: true
    themes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookSummaryCountAggregateInputType = {
    id?: true
    bookVersionId?: true
    summary?: true
    analysis?: true
    themes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookSummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookSummary to aggregate.
     */
    where?: BookSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookSummaries to fetch.
     */
    orderBy?: BookSummaryOrderByWithRelationInput | BookSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookSummaries
    **/
    _count?: true | BookSummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookSummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookSummaryMaxAggregateInputType
  }

  export type GetBookSummaryAggregateType<T extends BookSummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateBookSummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookSummary[P]>
      : GetScalarType<T[P], AggregateBookSummary[P]>
  }




  export type BookSummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookSummaryWhereInput
    orderBy?: BookSummaryOrderByWithAggregationInput | BookSummaryOrderByWithAggregationInput[]
    by: BookSummaryScalarFieldEnum[] | BookSummaryScalarFieldEnum
    having?: BookSummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookSummaryCountAggregateInputType | true
    _min?: BookSummaryMinAggregateInputType
    _max?: BookSummaryMaxAggregateInputType
  }

  export type BookSummaryGroupByOutputType = {
    id: string
    bookVersionId: string
    summary: string
    analysis: string | null
    themes: string | null
    createdAt: Date
    updatedAt: Date
    _count: BookSummaryCountAggregateOutputType | null
    _min: BookSummaryMinAggregateOutputType | null
    _max: BookSummaryMaxAggregateOutputType | null
  }

  type GetBookSummaryGroupByPayload<T extends BookSummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookSummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookSummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookSummaryGroupByOutputType[P]>
            : GetScalarType<T[P], BookSummaryGroupByOutputType[P]>
        }
      >
    >


  export type BookSummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookVersionId?: boolean
    summary?: boolean
    analysis?: boolean
    themes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookSummary"]>

  export type BookSummarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookVersionId?: boolean
    summary?: boolean
    analysis?: boolean
    themes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookSummary"]>

  export type BookSummarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookVersionId?: boolean
    summary?: boolean
    analysis?: boolean
    themes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookSummary"]>

  export type BookSummarySelectScalar = {
    id?: boolean
    bookVersionId?: boolean
    summary?: boolean
    analysis?: boolean
    themes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookSummaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookVersionId" | "summary" | "analysis" | "themes" | "createdAt" | "updatedAt", ExtArgs["result"]["bookSummary"]>
  export type BookSummaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }
  export type BookSummaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }
  export type BookSummaryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }

  export type $BookSummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookSummary"
    objects: {
      bookVersion: Prisma.$BookVersionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookVersionId: string
      summary: string
      analysis: string | null
      themes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bookSummary"]>
    composites: {}
  }

  type BookSummaryGetPayload<S extends boolean | null | undefined | BookSummaryDefaultArgs> = $Result.GetResult<Prisma.$BookSummaryPayload, S>

  type BookSummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookSummaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookSummaryCountAggregateInputType | true
    }

  export interface BookSummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookSummary'], meta: { name: 'BookSummary' } }
    /**
     * Find zero or one BookSummary that matches the filter.
     * @param {BookSummaryFindUniqueArgs} args - Arguments to find a BookSummary
     * @example
     * // Get one BookSummary
     * const bookSummary = await prisma.bookSummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookSummaryFindUniqueArgs>(args: SelectSubset<T, BookSummaryFindUniqueArgs<ExtArgs>>): Prisma__BookSummaryClient<$Result.GetResult<Prisma.$BookSummaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookSummary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookSummaryFindUniqueOrThrowArgs} args - Arguments to find a BookSummary
     * @example
     * // Get one BookSummary
     * const bookSummary = await prisma.bookSummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookSummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, BookSummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookSummaryClient<$Result.GetResult<Prisma.$BookSummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookSummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookSummaryFindFirstArgs} args - Arguments to find a BookSummary
     * @example
     * // Get one BookSummary
     * const bookSummary = await prisma.bookSummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookSummaryFindFirstArgs>(args?: SelectSubset<T, BookSummaryFindFirstArgs<ExtArgs>>): Prisma__BookSummaryClient<$Result.GetResult<Prisma.$BookSummaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookSummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookSummaryFindFirstOrThrowArgs} args - Arguments to find a BookSummary
     * @example
     * // Get one BookSummary
     * const bookSummary = await prisma.bookSummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookSummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, BookSummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookSummaryClient<$Result.GetResult<Prisma.$BookSummaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookSummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookSummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookSummaries
     * const bookSummaries = await prisma.bookSummary.findMany()
     * 
     * // Get first 10 BookSummaries
     * const bookSummaries = await prisma.bookSummary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookSummaryWithIdOnly = await prisma.bookSummary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookSummaryFindManyArgs>(args?: SelectSubset<T, BookSummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookSummary.
     * @param {BookSummaryCreateArgs} args - Arguments to create a BookSummary.
     * @example
     * // Create one BookSummary
     * const BookSummary = await prisma.bookSummary.create({
     *   data: {
     *     // ... data to create a BookSummary
     *   }
     * })
     * 
     */
    create<T extends BookSummaryCreateArgs>(args: SelectSubset<T, BookSummaryCreateArgs<ExtArgs>>): Prisma__BookSummaryClient<$Result.GetResult<Prisma.$BookSummaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookSummaries.
     * @param {BookSummaryCreateManyArgs} args - Arguments to create many BookSummaries.
     * @example
     * // Create many BookSummaries
     * const bookSummary = await prisma.bookSummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookSummaryCreateManyArgs>(args?: SelectSubset<T, BookSummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookSummaries and returns the data saved in the database.
     * @param {BookSummaryCreateManyAndReturnArgs} args - Arguments to create many BookSummaries.
     * @example
     * // Create many BookSummaries
     * const bookSummary = await prisma.bookSummary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookSummaries and only return the `id`
     * const bookSummaryWithIdOnly = await prisma.bookSummary.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookSummaryCreateManyAndReturnArgs>(args?: SelectSubset<T, BookSummaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookSummaryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookSummary.
     * @param {BookSummaryDeleteArgs} args - Arguments to delete one BookSummary.
     * @example
     * // Delete one BookSummary
     * const BookSummary = await prisma.bookSummary.delete({
     *   where: {
     *     // ... filter to delete one BookSummary
     *   }
     * })
     * 
     */
    delete<T extends BookSummaryDeleteArgs>(args: SelectSubset<T, BookSummaryDeleteArgs<ExtArgs>>): Prisma__BookSummaryClient<$Result.GetResult<Prisma.$BookSummaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookSummary.
     * @param {BookSummaryUpdateArgs} args - Arguments to update one BookSummary.
     * @example
     * // Update one BookSummary
     * const bookSummary = await prisma.bookSummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookSummaryUpdateArgs>(args: SelectSubset<T, BookSummaryUpdateArgs<ExtArgs>>): Prisma__BookSummaryClient<$Result.GetResult<Prisma.$BookSummaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookSummaries.
     * @param {BookSummaryDeleteManyArgs} args - Arguments to filter BookSummaries to delete.
     * @example
     * // Delete a few BookSummaries
     * const { count } = await prisma.bookSummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookSummaryDeleteManyArgs>(args?: SelectSubset<T, BookSummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookSummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookSummaries
     * const bookSummary = await prisma.bookSummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookSummaryUpdateManyArgs>(args: SelectSubset<T, BookSummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookSummaries and returns the data updated in the database.
     * @param {BookSummaryUpdateManyAndReturnArgs} args - Arguments to update many BookSummaries.
     * @example
     * // Update many BookSummaries
     * const bookSummary = await prisma.bookSummary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookSummaries and only return the `id`
     * const bookSummaryWithIdOnly = await prisma.bookSummary.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookSummaryUpdateManyAndReturnArgs>(args: SelectSubset<T, BookSummaryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookSummaryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookSummary.
     * @param {BookSummaryUpsertArgs} args - Arguments to update or create a BookSummary.
     * @example
     * // Update or create a BookSummary
     * const bookSummary = await prisma.bookSummary.upsert({
     *   create: {
     *     // ... data to create a BookSummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookSummary we want to update
     *   }
     * })
     */
    upsert<T extends BookSummaryUpsertArgs>(args: SelectSubset<T, BookSummaryUpsertArgs<ExtArgs>>): Prisma__BookSummaryClient<$Result.GetResult<Prisma.$BookSummaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookSummaryCountArgs} args - Arguments to filter BookSummaries to count.
     * @example
     * // Count the number of BookSummaries
     * const count = await prisma.bookSummary.count({
     *   where: {
     *     // ... the filter for the BookSummaries we want to count
     *   }
     * })
    **/
    count<T extends BookSummaryCountArgs>(
      args?: Subset<T, BookSummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookSummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookSummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookSummaryAggregateArgs>(args: Subset<T, BookSummaryAggregateArgs>): Prisma.PrismaPromise<GetBookSummaryAggregateType<T>>

    /**
     * Group by BookSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookSummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookSummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookSummaryGroupByArgs['orderBy'] }
        : { orderBy?: BookSummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookSummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookSummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookSummary model
   */
  readonly fields: BookSummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookSummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookSummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookVersion<T extends BookVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookVersionDefaultArgs<ExtArgs>>): Prisma__BookVersionClient<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookSummary model
   */
  interface BookSummaryFieldRefs {
    readonly id: FieldRef<"BookSummary", 'String'>
    readonly bookVersionId: FieldRef<"BookSummary", 'String'>
    readonly summary: FieldRef<"BookSummary", 'String'>
    readonly analysis: FieldRef<"BookSummary", 'String'>
    readonly themes: FieldRef<"BookSummary", 'String'>
    readonly createdAt: FieldRef<"BookSummary", 'DateTime'>
    readonly updatedAt: FieldRef<"BookSummary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookSummary findUnique
   */
  export type BookSummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSummary
     */
    select?: BookSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSummary
     */
    omit?: BookSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSummaryInclude<ExtArgs> | null
    /**
     * Filter, which BookSummary to fetch.
     */
    where: BookSummaryWhereUniqueInput
  }

  /**
   * BookSummary findUniqueOrThrow
   */
  export type BookSummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSummary
     */
    select?: BookSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSummary
     */
    omit?: BookSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSummaryInclude<ExtArgs> | null
    /**
     * Filter, which BookSummary to fetch.
     */
    where: BookSummaryWhereUniqueInput
  }

  /**
   * BookSummary findFirst
   */
  export type BookSummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSummary
     */
    select?: BookSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSummary
     */
    omit?: BookSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSummaryInclude<ExtArgs> | null
    /**
     * Filter, which BookSummary to fetch.
     */
    where?: BookSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookSummaries to fetch.
     */
    orderBy?: BookSummaryOrderByWithRelationInput | BookSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookSummaries.
     */
    cursor?: BookSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookSummaries.
     */
    distinct?: BookSummaryScalarFieldEnum | BookSummaryScalarFieldEnum[]
  }

  /**
   * BookSummary findFirstOrThrow
   */
  export type BookSummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSummary
     */
    select?: BookSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSummary
     */
    omit?: BookSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSummaryInclude<ExtArgs> | null
    /**
     * Filter, which BookSummary to fetch.
     */
    where?: BookSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookSummaries to fetch.
     */
    orderBy?: BookSummaryOrderByWithRelationInput | BookSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookSummaries.
     */
    cursor?: BookSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookSummaries.
     */
    distinct?: BookSummaryScalarFieldEnum | BookSummaryScalarFieldEnum[]
  }

  /**
   * BookSummary findMany
   */
  export type BookSummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSummary
     */
    select?: BookSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSummary
     */
    omit?: BookSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSummaryInclude<ExtArgs> | null
    /**
     * Filter, which BookSummaries to fetch.
     */
    where?: BookSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookSummaries to fetch.
     */
    orderBy?: BookSummaryOrderByWithRelationInput | BookSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookSummaries.
     */
    cursor?: BookSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookSummaries.
     */
    skip?: number
    distinct?: BookSummaryScalarFieldEnum | BookSummaryScalarFieldEnum[]
  }

  /**
   * BookSummary create
   */
  export type BookSummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSummary
     */
    select?: BookSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSummary
     */
    omit?: BookSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSummaryInclude<ExtArgs> | null
    /**
     * The data needed to create a BookSummary.
     */
    data: XOR<BookSummaryCreateInput, BookSummaryUncheckedCreateInput>
  }

  /**
   * BookSummary createMany
   */
  export type BookSummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookSummaries.
     */
    data: BookSummaryCreateManyInput | BookSummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookSummary createManyAndReturn
   */
  export type BookSummaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSummary
     */
    select?: BookSummarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookSummary
     */
    omit?: BookSummaryOmit<ExtArgs> | null
    /**
     * The data used to create many BookSummaries.
     */
    data: BookSummaryCreateManyInput | BookSummaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSummaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookSummary update
   */
  export type BookSummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSummary
     */
    select?: BookSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSummary
     */
    omit?: BookSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSummaryInclude<ExtArgs> | null
    /**
     * The data needed to update a BookSummary.
     */
    data: XOR<BookSummaryUpdateInput, BookSummaryUncheckedUpdateInput>
    /**
     * Choose, which BookSummary to update.
     */
    where: BookSummaryWhereUniqueInput
  }

  /**
   * BookSummary updateMany
   */
  export type BookSummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookSummaries.
     */
    data: XOR<BookSummaryUpdateManyMutationInput, BookSummaryUncheckedUpdateManyInput>
    /**
     * Filter which BookSummaries to update
     */
    where?: BookSummaryWhereInput
    /**
     * Limit how many BookSummaries to update.
     */
    limit?: number
  }

  /**
   * BookSummary updateManyAndReturn
   */
  export type BookSummaryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSummary
     */
    select?: BookSummarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookSummary
     */
    omit?: BookSummaryOmit<ExtArgs> | null
    /**
     * The data used to update BookSummaries.
     */
    data: XOR<BookSummaryUpdateManyMutationInput, BookSummaryUncheckedUpdateManyInput>
    /**
     * Filter which BookSummaries to update
     */
    where?: BookSummaryWhereInput
    /**
     * Limit how many BookSummaries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSummaryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookSummary upsert
   */
  export type BookSummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSummary
     */
    select?: BookSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSummary
     */
    omit?: BookSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSummaryInclude<ExtArgs> | null
    /**
     * The filter to search for the BookSummary to update in case it exists.
     */
    where: BookSummaryWhereUniqueInput
    /**
     * In case the BookSummary found by the `where` argument doesn't exist, create a new BookSummary with this data.
     */
    create: XOR<BookSummaryCreateInput, BookSummaryUncheckedCreateInput>
    /**
     * In case the BookSummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookSummaryUpdateInput, BookSummaryUncheckedUpdateInput>
  }

  /**
   * BookSummary delete
   */
  export type BookSummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSummary
     */
    select?: BookSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSummary
     */
    omit?: BookSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSummaryInclude<ExtArgs> | null
    /**
     * Filter which BookSummary to delete.
     */
    where: BookSummaryWhereUniqueInput
  }

  /**
   * BookSummary deleteMany
   */
  export type BookSummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookSummaries to delete
     */
    where?: BookSummaryWhereInput
    /**
     * Limit how many BookSummaries to delete.
     */
    limit?: number
  }

  /**
   * BookSummary without action
   */
  export type BookSummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSummary
     */
    select?: BookSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSummary
     */
    omit?: BookSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSummaryInclude<ExtArgs> | null
  }


  /**
   * Model Chapter
   */

  export type AggregateChapter = {
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  export type ChapterAvgAggregateOutputType = {
    number: number | null
  }

  export type ChapterSumAggregateOutputType = {
    number: number | null
  }

  export type ChapterMinAggregateOutputType = {
    id: string | null
    bookVersionId: string | null
    number: number | null
    title: string | null
    content: string | null
    createdAt: Date | null
  }

  export type ChapterMaxAggregateOutputType = {
    id: string | null
    bookVersionId: string | null
    number: number | null
    title: string | null
    content: string | null
    createdAt: Date | null
  }

  export type ChapterCountAggregateOutputType = {
    id: number
    bookVersionId: number
    number: number
    title: number
    content: number
    createdAt: number
    _all: number
  }


  export type ChapterAvgAggregateInputType = {
    number?: true
  }

  export type ChapterSumAggregateInputType = {
    number?: true
  }

  export type ChapterMinAggregateInputType = {
    id?: true
    bookVersionId?: true
    number?: true
    title?: true
    content?: true
    createdAt?: true
  }

  export type ChapterMaxAggregateInputType = {
    id?: true
    bookVersionId?: true
    number?: true
    title?: true
    content?: true
    createdAt?: true
  }

  export type ChapterCountAggregateInputType = {
    id?: true
    bookVersionId?: true
    number?: true
    title?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type ChapterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapter to aggregate.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chapters
    **/
    _count?: true | ChapterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChapterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChapterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterMaxAggregateInputType
  }

  export type GetChapterAggregateType<T extends ChapterAggregateArgs> = {
        [P in keyof T & keyof AggregateChapter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapter[P]>
      : GetScalarType<T[P], AggregateChapter[P]>
  }




  export type ChapterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithAggregationInput | ChapterOrderByWithAggregationInput[]
    by: ChapterScalarFieldEnum[] | ChapterScalarFieldEnum
    having?: ChapterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterCountAggregateInputType | true
    _avg?: ChapterAvgAggregateInputType
    _sum?: ChapterSumAggregateInputType
    _min?: ChapterMinAggregateInputType
    _max?: ChapterMaxAggregateInputType
  }

  export type ChapterGroupByOutputType = {
    id: string
    bookVersionId: string
    number: number
    title: string
    content: string
    createdAt: Date
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  type GetChapterGroupByPayload<T extends ChapterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterGroupByOutputType[P]>
        }
      >
    >


  export type ChapterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookVersionId?: boolean
    number?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    comments?: boolean | Chapter$commentsArgs<ExtArgs>
    _count?: boolean | ChapterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookVersionId?: boolean
    number?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookVersionId?: boolean
    number?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectScalar = {
    id?: boolean
    bookVersionId?: boolean
    number?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type ChapterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookVersionId" | "number" | "title" | "content" | "createdAt", ExtArgs["result"]["chapter"]>
  export type ChapterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    comments?: boolean | Chapter$commentsArgs<ExtArgs>
    _count?: boolean | ChapterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChapterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }
  export type ChapterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }

  export type $ChapterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chapter"
    objects: {
      bookVersion: Prisma.$BookVersionPayload<ExtArgs>
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookVersionId: string
      number: number
      title: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["chapter"]>
    composites: {}
  }

  type ChapterGetPayload<S extends boolean | null | undefined | ChapterDefaultArgs> = $Result.GetResult<Prisma.$ChapterPayload, S>

  type ChapterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChapterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChapterCountAggregateInputType | true
    }

  export interface ChapterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chapter'], meta: { name: 'Chapter' } }
    /**
     * Find zero or one Chapter that matches the filter.
     * @param {ChapterFindUniqueArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChapterFindUniqueArgs>(args: SelectSubset<T, ChapterFindUniqueArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chapter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChapterFindUniqueOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChapterFindUniqueOrThrowArgs>(args: SelectSubset<T, ChapterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chapter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindFirstArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChapterFindFirstArgs>(args?: SelectSubset<T, ChapterFindFirstArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chapter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindFirstOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChapterFindFirstOrThrowArgs>(args?: SelectSubset<T, ChapterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chapters
     * const chapters = await prisma.chapter.findMany()
     * 
     * // Get first 10 Chapters
     * const chapters = await prisma.chapter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chapterWithIdOnly = await prisma.chapter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChapterFindManyArgs>(args?: SelectSubset<T, ChapterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chapter.
     * @param {ChapterCreateArgs} args - Arguments to create a Chapter.
     * @example
     * // Create one Chapter
     * const Chapter = await prisma.chapter.create({
     *   data: {
     *     // ... data to create a Chapter
     *   }
     * })
     * 
     */
    create<T extends ChapterCreateArgs>(args: SelectSubset<T, ChapterCreateArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chapters.
     * @param {ChapterCreateManyArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChapterCreateManyArgs>(args?: SelectSubset<T, ChapterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chapters and returns the data saved in the database.
     * @param {ChapterCreateManyAndReturnArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chapters and only return the `id`
     * const chapterWithIdOnly = await prisma.chapter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChapterCreateManyAndReturnArgs>(args?: SelectSubset<T, ChapterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chapter.
     * @param {ChapterDeleteArgs} args - Arguments to delete one Chapter.
     * @example
     * // Delete one Chapter
     * const Chapter = await prisma.chapter.delete({
     *   where: {
     *     // ... filter to delete one Chapter
     *   }
     * })
     * 
     */
    delete<T extends ChapterDeleteArgs>(args: SelectSubset<T, ChapterDeleteArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chapter.
     * @param {ChapterUpdateArgs} args - Arguments to update one Chapter.
     * @example
     * // Update one Chapter
     * const chapter = await prisma.chapter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChapterUpdateArgs>(args: SelectSubset<T, ChapterUpdateArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chapters.
     * @param {ChapterDeleteManyArgs} args - Arguments to filter Chapters to delete.
     * @example
     * // Delete a few Chapters
     * const { count } = await prisma.chapter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChapterDeleteManyArgs>(args?: SelectSubset<T, ChapterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chapters
     * const chapter = await prisma.chapter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChapterUpdateManyArgs>(args: SelectSubset<T, ChapterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters and returns the data updated in the database.
     * @param {ChapterUpdateManyAndReturnArgs} args - Arguments to update many Chapters.
     * @example
     * // Update many Chapters
     * const chapter = await prisma.chapter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chapters and only return the `id`
     * const chapterWithIdOnly = await prisma.chapter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChapterUpdateManyAndReturnArgs>(args: SelectSubset<T, ChapterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chapter.
     * @param {ChapterUpsertArgs} args - Arguments to update or create a Chapter.
     * @example
     * // Update or create a Chapter
     * const chapter = await prisma.chapter.upsert({
     *   create: {
     *     // ... data to create a Chapter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chapter we want to update
     *   }
     * })
     */
    upsert<T extends ChapterUpsertArgs>(args: SelectSubset<T, ChapterUpsertArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterCountArgs} args - Arguments to filter Chapters to count.
     * @example
     * // Count the number of Chapters
     * const count = await prisma.chapter.count({
     *   where: {
     *     // ... the filter for the Chapters we want to count
     *   }
     * })
    **/
    count<T extends ChapterCountArgs>(
      args?: Subset<T, ChapterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterAggregateArgs>(args: Subset<T, ChapterAggregateArgs>): Prisma.PrismaPromise<GetChapterAggregateType<T>>

    /**
     * Group by Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChapterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChapterGroupByArgs['orderBy'] }
        : { orderBy?: ChapterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChapterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chapter model
   */
  readonly fields: ChapterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chapter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChapterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookVersion<T extends BookVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookVersionDefaultArgs<ExtArgs>>): Prisma__BookVersionClient<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comments<T extends Chapter$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chapter model
   */
  interface ChapterFieldRefs {
    readonly id: FieldRef<"Chapter", 'String'>
    readonly bookVersionId: FieldRef<"Chapter", 'String'>
    readonly number: FieldRef<"Chapter", 'Int'>
    readonly title: FieldRef<"Chapter", 'String'>
    readonly content: FieldRef<"Chapter", 'String'>
    readonly createdAt: FieldRef<"Chapter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chapter findUnique
   */
  export type ChapterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter findUniqueOrThrow
   */
  export type ChapterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter findFirst
   */
  export type ChapterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter findFirstOrThrow
   */
  export type ChapterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter findMany
   */
  export type ChapterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapters to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter create
   */
  export type ChapterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The data needed to create a Chapter.
     */
    data: XOR<ChapterCreateInput, ChapterUncheckedCreateInput>
  }

  /**
   * Chapter createMany
   */
  export type ChapterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chapters.
     */
    data: ChapterCreateManyInput | ChapterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chapter createManyAndReturn
   */
  export type ChapterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * The data used to create many Chapters.
     */
    data: ChapterCreateManyInput | ChapterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chapter update
   */
  export type ChapterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The data needed to update a Chapter.
     */
    data: XOR<ChapterUpdateInput, ChapterUncheckedUpdateInput>
    /**
     * Choose, which Chapter to update.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter updateMany
   */
  export type ChapterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chapters.
     */
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyInput>
    /**
     * Filter which Chapters to update
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to update.
     */
    limit?: number
  }

  /**
   * Chapter updateManyAndReturn
   */
  export type ChapterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * The data used to update Chapters.
     */
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyInput>
    /**
     * Filter which Chapters to update
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chapter upsert
   */
  export type ChapterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The filter to search for the Chapter to update in case it exists.
     */
    where: ChapterWhereUniqueInput
    /**
     * In case the Chapter found by the `where` argument doesn't exist, create a new Chapter with this data.
     */
    create: XOR<ChapterCreateInput, ChapterUncheckedCreateInput>
    /**
     * In case the Chapter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChapterUpdateInput, ChapterUncheckedUpdateInput>
  }

  /**
   * Chapter delete
   */
  export type ChapterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter which Chapter to delete.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter deleteMany
   */
  export type ChapterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapters to delete
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to delete.
     */
    limit?: number
  }

  /**
   * Chapter.comments
   */
  export type Chapter$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Chapter without action
   */
  export type ChapterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
  }


  /**
   * Model AudioChapter
   */

  export type AggregateAudioChapter = {
    _count: AudioChapterCountAggregateOutputType | null
    _avg: AudioChapterAvgAggregateOutputType | null
    _sum: AudioChapterSumAggregateOutputType | null
    _min: AudioChapterMinAggregateOutputType | null
    _max: AudioChapterMaxAggregateOutputType | null
  }

  export type AudioChapterAvgAggregateOutputType = {
    number: number | null
    duration: number | null
  }

  export type AudioChapterSumAggregateOutputType = {
    number: number | null
    duration: number | null
  }

  export type AudioChapterMinAggregateOutputType = {
    id: string | null
    bookVersionId: string | null
    number: number | null
    title: string | null
    audioUrl: string | null
    duration: number | null
    createdAt: Date | null
  }

  export type AudioChapterMaxAggregateOutputType = {
    id: string | null
    bookVersionId: string | null
    number: number | null
    title: string | null
    audioUrl: string | null
    duration: number | null
    createdAt: Date | null
  }

  export type AudioChapterCountAggregateOutputType = {
    id: number
    bookVersionId: number
    number: number
    title: number
    audioUrl: number
    duration: number
    createdAt: number
    _all: number
  }


  export type AudioChapterAvgAggregateInputType = {
    number?: true
    duration?: true
  }

  export type AudioChapterSumAggregateInputType = {
    number?: true
    duration?: true
  }

  export type AudioChapterMinAggregateInputType = {
    id?: true
    bookVersionId?: true
    number?: true
    title?: true
    audioUrl?: true
    duration?: true
    createdAt?: true
  }

  export type AudioChapterMaxAggregateInputType = {
    id?: true
    bookVersionId?: true
    number?: true
    title?: true
    audioUrl?: true
    duration?: true
    createdAt?: true
  }

  export type AudioChapterCountAggregateInputType = {
    id?: true
    bookVersionId?: true
    number?: true
    title?: true
    audioUrl?: true
    duration?: true
    createdAt?: true
    _all?: true
  }

  export type AudioChapterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioChapter to aggregate.
     */
    where?: AudioChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioChapters to fetch.
     */
    orderBy?: AudioChapterOrderByWithRelationInput | AudioChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AudioChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioChapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioChapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AudioChapters
    **/
    _count?: true | AudioChapterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AudioChapterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AudioChapterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AudioChapterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AudioChapterMaxAggregateInputType
  }

  export type GetAudioChapterAggregateType<T extends AudioChapterAggregateArgs> = {
        [P in keyof T & keyof AggregateAudioChapter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudioChapter[P]>
      : GetScalarType<T[P], AggregateAudioChapter[P]>
  }




  export type AudioChapterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioChapterWhereInput
    orderBy?: AudioChapterOrderByWithAggregationInput | AudioChapterOrderByWithAggregationInput[]
    by: AudioChapterScalarFieldEnum[] | AudioChapterScalarFieldEnum
    having?: AudioChapterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AudioChapterCountAggregateInputType | true
    _avg?: AudioChapterAvgAggregateInputType
    _sum?: AudioChapterSumAggregateInputType
    _min?: AudioChapterMinAggregateInputType
    _max?: AudioChapterMaxAggregateInputType
  }

  export type AudioChapterGroupByOutputType = {
    id: string
    bookVersionId: string
    number: number
    title: string
    audioUrl: string
    duration: number
    createdAt: Date
    _count: AudioChapterCountAggregateOutputType | null
    _avg: AudioChapterAvgAggregateOutputType | null
    _sum: AudioChapterSumAggregateOutputType | null
    _min: AudioChapterMinAggregateOutputType | null
    _max: AudioChapterMaxAggregateOutputType | null
  }

  type GetAudioChapterGroupByPayload<T extends AudioChapterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AudioChapterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AudioChapterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AudioChapterGroupByOutputType[P]>
            : GetScalarType<T[P], AudioChapterGroupByOutputType[P]>
        }
      >
    >


  export type AudioChapterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookVersionId?: boolean
    number?: boolean
    title?: boolean
    audioUrl?: boolean
    duration?: boolean
    createdAt?: boolean
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    comments?: boolean | AudioChapter$commentsArgs<ExtArgs>
    _count?: boolean | AudioChapterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioChapter"]>

  export type AudioChapterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookVersionId?: boolean
    number?: boolean
    title?: boolean
    audioUrl?: boolean
    duration?: boolean
    createdAt?: boolean
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioChapter"]>

  export type AudioChapterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookVersionId?: boolean
    number?: boolean
    title?: boolean
    audioUrl?: boolean
    duration?: boolean
    createdAt?: boolean
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioChapter"]>

  export type AudioChapterSelectScalar = {
    id?: boolean
    bookVersionId?: boolean
    number?: boolean
    title?: boolean
    audioUrl?: boolean
    duration?: boolean
    createdAt?: boolean
  }

  export type AudioChapterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookVersionId" | "number" | "title" | "audioUrl" | "duration" | "createdAt", ExtArgs["result"]["audioChapter"]>
  export type AudioChapterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    comments?: boolean | AudioChapter$commentsArgs<ExtArgs>
    _count?: boolean | AudioChapterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AudioChapterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }
  export type AudioChapterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }

  export type $AudioChapterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AudioChapter"
    objects: {
      bookVersion: Prisma.$BookVersionPayload<ExtArgs>
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookVersionId: string
      number: number
      title: string
      audioUrl: string
      duration: number
      createdAt: Date
    }, ExtArgs["result"]["audioChapter"]>
    composites: {}
  }

  type AudioChapterGetPayload<S extends boolean | null | undefined | AudioChapterDefaultArgs> = $Result.GetResult<Prisma.$AudioChapterPayload, S>

  type AudioChapterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AudioChapterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AudioChapterCountAggregateInputType | true
    }

  export interface AudioChapterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AudioChapter'], meta: { name: 'AudioChapter' } }
    /**
     * Find zero or one AudioChapter that matches the filter.
     * @param {AudioChapterFindUniqueArgs} args - Arguments to find a AudioChapter
     * @example
     * // Get one AudioChapter
     * const audioChapter = await prisma.audioChapter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AudioChapterFindUniqueArgs>(args: SelectSubset<T, AudioChapterFindUniqueArgs<ExtArgs>>): Prisma__AudioChapterClient<$Result.GetResult<Prisma.$AudioChapterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AudioChapter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AudioChapterFindUniqueOrThrowArgs} args - Arguments to find a AudioChapter
     * @example
     * // Get one AudioChapter
     * const audioChapter = await prisma.audioChapter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AudioChapterFindUniqueOrThrowArgs>(args: SelectSubset<T, AudioChapterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AudioChapterClient<$Result.GetResult<Prisma.$AudioChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AudioChapter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioChapterFindFirstArgs} args - Arguments to find a AudioChapter
     * @example
     * // Get one AudioChapter
     * const audioChapter = await prisma.audioChapter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AudioChapterFindFirstArgs>(args?: SelectSubset<T, AudioChapterFindFirstArgs<ExtArgs>>): Prisma__AudioChapterClient<$Result.GetResult<Prisma.$AudioChapterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AudioChapter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioChapterFindFirstOrThrowArgs} args - Arguments to find a AudioChapter
     * @example
     * // Get one AudioChapter
     * const audioChapter = await prisma.audioChapter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AudioChapterFindFirstOrThrowArgs>(args?: SelectSubset<T, AudioChapterFindFirstOrThrowArgs<ExtArgs>>): Prisma__AudioChapterClient<$Result.GetResult<Prisma.$AudioChapterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AudioChapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioChapterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AudioChapters
     * const audioChapters = await prisma.audioChapter.findMany()
     * 
     * // Get first 10 AudioChapters
     * const audioChapters = await prisma.audioChapter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audioChapterWithIdOnly = await prisma.audioChapter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AudioChapterFindManyArgs>(args?: SelectSubset<T, AudioChapterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AudioChapter.
     * @param {AudioChapterCreateArgs} args - Arguments to create a AudioChapter.
     * @example
     * // Create one AudioChapter
     * const AudioChapter = await prisma.audioChapter.create({
     *   data: {
     *     // ... data to create a AudioChapter
     *   }
     * })
     * 
     */
    create<T extends AudioChapterCreateArgs>(args: SelectSubset<T, AudioChapterCreateArgs<ExtArgs>>): Prisma__AudioChapterClient<$Result.GetResult<Prisma.$AudioChapterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AudioChapters.
     * @param {AudioChapterCreateManyArgs} args - Arguments to create many AudioChapters.
     * @example
     * // Create many AudioChapters
     * const audioChapter = await prisma.audioChapter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AudioChapterCreateManyArgs>(args?: SelectSubset<T, AudioChapterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AudioChapters and returns the data saved in the database.
     * @param {AudioChapterCreateManyAndReturnArgs} args - Arguments to create many AudioChapters.
     * @example
     * // Create many AudioChapters
     * const audioChapter = await prisma.audioChapter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AudioChapters and only return the `id`
     * const audioChapterWithIdOnly = await prisma.audioChapter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AudioChapterCreateManyAndReturnArgs>(args?: SelectSubset<T, AudioChapterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioChapterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AudioChapter.
     * @param {AudioChapterDeleteArgs} args - Arguments to delete one AudioChapter.
     * @example
     * // Delete one AudioChapter
     * const AudioChapter = await prisma.audioChapter.delete({
     *   where: {
     *     // ... filter to delete one AudioChapter
     *   }
     * })
     * 
     */
    delete<T extends AudioChapterDeleteArgs>(args: SelectSubset<T, AudioChapterDeleteArgs<ExtArgs>>): Prisma__AudioChapterClient<$Result.GetResult<Prisma.$AudioChapterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AudioChapter.
     * @param {AudioChapterUpdateArgs} args - Arguments to update one AudioChapter.
     * @example
     * // Update one AudioChapter
     * const audioChapter = await prisma.audioChapter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AudioChapterUpdateArgs>(args: SelectSubset<T, AudioChapterUpdateArgs<ExtArgs>>): Prisma__AudioChapterClient<$Result.GetResult<Prisma.$AudioChapterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AudioChapters.
     * @param {AudioChapterDeleteManyArgs} args - Arguments to filter AudioChapters to delete.
     * @example
     * // Delete a few AudioChapters
     * const { count } = await prisma.audioChapter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AudioChapterDeleteManyArgs>(args?: SelectSubset<T, AudioChapterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioChapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioChapterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AudioChapters
     * const audioChapter = await prisma.audioChapter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AudioChapterUpdateManyArgs>(args: SelectSubset<T, AudioChapterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioChapters and returns the data updated in the database.
     * @param {AudioChapterUpdateManyAndReturnArgs} args - Arguments to update many AudioChapters.
     * @example
     * // Update many AudioChapters
     * const audioChapter = await prisma.audioChapter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AudioChapters and only return the `id`
     * const audioChapterWithIdOnly = await prisma.audioChapter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AudioChapterUpdateManyAndReturnArgs>(args: SelectSubset<T, AudioChapterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioChapterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AudioChapter.
     * @param {AudioChapterUpsertArgs} args - Arguments to update or create a AudioChapter.
     * @example
     * // Update or create a AudioChapter
     * const audioChapter = await prisma.audioChapter.upsert({
     *   create: {
     *     // ... data to create a AudioChapter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AudioChapter we want to update
     *   }
     * })
     */
    upsert<T extends AudioChapterUpsertArgs>(args: SelectSubset<T, AudioChapterUpsertArgs<ExtArgs>>): Prisma__AudioChapterClient<$Result.GetResult<Prisma.$AudioChapterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AudioChapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioChapterCountArgs} args - Arguments to filter AudioChapters to count.
     * @example
     * // Count the number of AudioChapters
     * const count = await prisma.audioChapter.count({
     *   where: {
     *     // ... the filter for the AudioChapters we want to count
     *   }
     * })
    **/
    count<T extends AudioChapterCountArgs>(
      args?: Subset<T, AudioChapterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AudioChapterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AudioChapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioChapterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AudioChapterAggregateArgs>(args: Subset<T, AudioChapterAggregateArgs>): Prisma.PrismaPromise<GetAudioChapterAggregateType<T>>

    /**
     * Group by AudioChapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioChapterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AudioChapterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AudioChapterGroupByArgs['orderBy'] }
        : { orderBy?: AudioChapterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AudioChapterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudioChapterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AudioChapter model
   */
  readonly fields: AudioChapterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AudioChapter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AudioChapterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookVersion<T extends BookVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookVersionDefaultArgs<ExtArgs>>): Prisma__BookVersionClient<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comments<T extends AudioChapter$commentsArgs<ExtArgs> = {}>(args?: Subset<T, AudioChapter$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AudioChapter model
   */
  interface AudioChapterFieldRefs {
    readonly id: FieldRef<"AudioChapter", 'String'>
    readonly bookVersionId: FieldRef<"AudioChapter", 'String'>
    readonly number: FieldRef<"AudioChapter", 'Int'>
    readonly title: FieldRef<"AudioChapter", 'String'>
    readonly audioUrl: FieldRef<"AudioChapter", 'String'>
    readonly duration: FieldRef<"AudioChapter", 'Int'>
    readonly createdAt: FieldRef<"AudioChapter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AudioChapter findUnique
   */
  export type AudioChapterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChapter
     */
    select?: AudioChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioChapter
     */
    omit?: AudioChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChapterInclude<ExtArgs> | null
    /**
     * Filter, which AudioChapter to fetch.
     */
    where: AudioChapterWhereUniqueInput
  }

  /**
   * AudioChapter findUniqueOrThrow
   */
  export type AudioChapterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChapter
     */
    select?: AudioChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioChapter
     */
    omit?: AudioChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChapterInclude<ExtArgs> | null
    /**
     * Filter, which AudioChapter to fetch.
     */
    where: AudioChapterWhereUniqueInput
  }

  /**
   * AudioChapter findFirst
   */
  export type AudioChapterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChapter
     */
    select?: AudioChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioChapter
     */
    omit?: AudioChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChapterInclude<ExtArgs> | null
    /**
     * Filter, which AudioChapter to fetch.
     */
    where?: AudioChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioChapters to fetch.
     */
    orderBy?: AudioChapterOrderByWithRelationInput | AudioChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioChapters.
     */
    cursor?: AudioChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioChapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioChapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioChapters.
     */
    distinct?: AudioChapterScalarFieldEnum | AudioChapterScalarFieldEnum[]
  }

  /**
   * AudioChapter findFirstOrThrow
   */
  export type AudioChapterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChapter
     */
    select?: AudioChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioChapter
     */
    omit?: AudioChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChapterInclude<ExtArgs> | null
    /**
     * Filter, which AudioChapter to fetch.
     */
    where?: AudioChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioChapters to fetch.
     */
    orderBy?: AudioChapterOrderByWithRelationInput | AudioChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioChapters.
     */
    cursor?: AudioChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioChapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioChapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioChapters.
     */
    distinct?: AudioChapterScalarFieldEnum | AudioChapterScalarFieldEnum[]
  }

  /**
   * AudioChapter findMany
   */
  export type AudioChapterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChapter
     */
    select?: AudioChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioChapter
     */
    omit?: AudioChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChapterInclude<ExtArgs> | null
    /**
     * Filter, which AudioChapters to fetch.
     */
    where?: AudioChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioChapters to fetch.
     */
    orderBy?: AudioChapterOrderByWithRelationInput | AudioChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AudioChapters.
     */
    cursor?: AudioChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioChapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioChapters.
     */
    skip?: number
    distinct?: AudioChapterScalarFieldEnum | AudioChapterScalarFieldEnum[]
  }

  /**
   * AudioChapter create
   */
  export type AudioChapterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChapter
     */
    select?: AudioChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioChapter
     */
    omit?: AudioChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChapterInclude<ExtArgs> | null
    /**
     * The data needed to create a AudioChapter.
     */
    data: XOR<AudioChapterCreateInput, AudioChapterUncheckedCreateInput>
  }

  /**
   * AudioChapter createMany
   */
  export type AudioChapterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AudioChapters.
     */
    data: AudioChapterCreateManyInput | AudioChapterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AudioChapter createManyAndReturn
   */
  export type AudioChapterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChapter
     */
    select?: AudioChapterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AudioChapter
     */
    omit?: AudioChapterOmit<ExtArgs> | null
    /**
     * The data used to create many AudioChapters.
     */
    data: AudioChapterCreateManyInput | AudioChapterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChapterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioChapter update
   */
  export type AudioChapterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChapter
     */
    select?: AudioChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioChapter
     */
    omit?: AudioChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChapterInclude<ExtArgs> | null
    /**
     * The data needed to update a AudioChapter.
     */
    data: XOR<AudioChapterUpdateInput, AudioChapterUncheckedUpdateInput>
    /**
     * Choose, which AudioChapter to update.
     */
    where: AudioChapterWhereUniqueInput
  }

  /**
   * AudioChapter updateMany
   */
  export type AudioChapterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AudioChapters.
     */
    data: XOR<AudioChapterUpdateManyMutationInput, AudioChapterUncheckedUpdateManyInput>
    /**
     * Filter which AudioChapters to update
     */
    where?: AudioChapterWhereInput
    /**
     * Limit how many AudioChapters to update.
     */
    limit?: number
  }

  /**
   * AudioChapter updateManyAndReturn
   */
  export type AudioChapterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChapter
     */
    select?: AudioChapterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AudioChapter
     */
    omit?: AudioChapterOmit<ExtArgs> | null
    /**
     * The data used to update AudioChapters.
     */
    data: XOR<AudioChapterUpdateManyMutationInput, AudioChapterUncheckedUpdateManyInput>
    /**
     * Filter which AudioChapters to update
     */
    where?: AudioChapterWhereInput
    /**
     * Limit how many AudioChapters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChapterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioChapter upsert
   */
  export type AudioChapterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChapter
     */
    select?: AudioChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioChapter
     */
    omit?: AudioChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChapterInclude<ExtArgs> | null
    /**
     * The filter to search for the AudioChapter to update in case it exists.
     */
    where: AudioChapterWhereUniqueInput
    /**
     * In case the AudioChapter found by the `where` argument doesn't exist, create a new AudioChapter with this data.
     */
    create: XOR<AudioChapterCreateInput, AudioChapterUncheckedCreateInput>
    /**
     * In case the AudioChapter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AudioChapterUpdateInput, AudioChapterUncheckedUpdateInput>
  }

  /**
   * AudioChapter delete
   */
  export type AudioChapterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChapter
     */
    select?: AudioChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioChapter
     */
    omit?: AudioChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChapterInclude<ExtArgs> | null
    /**
     * Filter which AudioChapter to delete.
     */
    where: AudioChapterWhereUniqueInput
  }

  /**
   * AudioChapter deleteMany
   */
  export type AudioChapterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioChapters to delete
     */
    where?: AudioChapterWhereInput
    /**
     * Limit how many AudioChapters to delete.
     */
    limit?: number
  }

  /**
   * AudioChapter.comments
   */
  export type AudioChapter$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * AudioChapter without action
   */
  export type AudioChapterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChapter
     */
    select?: AudioChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioChapter
     */
    omit?: AudioChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChapterInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    avatarUrl: string | null
    languagePreference: $Enums.Language | null
    createdAt: Date | null
    lastLogin: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    avatarUrl: string | null
    languagePreference: $Enums.Language | null
    createdAt: Date | null
    lastLogin: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    name: number
    avatarUrl: number
    languagePreference: number
    createdAt: number
    lastLogin: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    avatarUrl?: true
    languagePreference?: true
    createdAt?: true
    lastLogin?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    avatarUrl?: true
    languagePreference?: true
    createdAt?: true
    lastLogin?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    avatarUrl?: true
    languagePreference?: true
    createdAt?: true
    lastLogin?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    name: string | null
    avatarUrl: string | null
    languagePreference: $Enums.Language
    createdAt: Date
    lastLogin: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    avatarUrl?: boolean
    languagePreference?: boolean
    createdAt?: boolean
    lastLogin?: boolean
    bookshelves?: boolean | User$bookshelvesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    likes?: boolean | User$likesArgs<ExtArgs>
    viewStats?: boolean | User$viewStatsArgs<ExtArgs>
    readingProgress?: boolean | User$readingProgressArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    avatarUrl?: boolean
    languagePreference?: boolean
    createdAt?: boolean
    lastLogin?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    avatarUrl?: boolean
    languagePreference?: boolean
    createdAt?: boolean
    lastLogin?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    avatarUrl?: boolean
    languagePreference?: boolean
    createdAt?: boolean
    lastLogin?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "name" | "avatarUrl" | "languagePreference" | "createdAt" | "lastLogin", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookshelves?: boolean | User$bookshelvesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    likes?: boolean | User$likesArgs<ExtArgs>
    viewStats?: boolean | User$viewStatsArgs<ExtArgs>
    readingProgress?: boolean | User$readingProgressArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      bookshelves: Prisma.$BookshelfPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      likes: Prisma.$LikePayload<ExtArgs>[]
      viewStats: Prisma.$ViewStatPayload<ExtArgs>[]
      readingProgress: Prisma.$ReadingProgressPayload<ExtArgs>[]
      roles: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      name: string | null
      avatarUrl: string | null
      languagePreference: $Enums.Language
      createdAt: Date
      lastLogin: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookshelves<T extends User$bookshelvesArgs<ExtArgs> = {}>(args?: Subset<T, User$bookshelvesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookshelfPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends User$likesArgs<ExtArgs> = {}>(args?: Subset<T, User$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    viewStats<T extends User$viewStatsArgs<ExtArgs> = {}>(args?: Subset<T, User$viewStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewStatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    readingProgress<T extends User$readingProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$readingProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadingProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roles<T extends User$rolesArgs<ExtArgs> = {}>(args?: Subset<T, User$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly languagePreference: FieldRef<"User", 'Language'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.bookshelves
   */
  export type User$bookshelvesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookshelf
     */
    select?: BookshelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookshelf
     */
    omit?: BookshelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookshelfInclude<ExtArgs> | null
    where?: BookshelfWhereInput
    orderBy?: BookshelfOrderByWithRelationInput | BookshelfOrderByWithRelationInput[]
    cursor?: BookshelfWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookshelfScalarFieldEnum | BookshelfScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.likes
   */
  export type User$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * User.viewStats
   */
  export type User$viewStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewStat
     */
    select?: ViewStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewStat
     */
    omit?: ViewStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewStatInclude<ExtArgs> | null
    where?: ViewStatWhereInput
    orderBy?: ViewStatOrderByWithRelationInput | ViewStatOrderByWithRelationInput[]
    cursor?: ViewStatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViewStatScalarFieldEnum | ViewStatScalarFieldEnum[]
  }

  /**
   * User.readingProgress
   */
  export type User$readingProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingProgress
     */
    select?: ReadingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadingProgress
     */
    omit?: ReadingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingProgressInclude<ExtArgs> | null
    where?: ReadingProgressWhereInput
    orderBy?: ReadingProgressOrderByWithRelationInput | ReadingProgressOrderByWithRelationInput[]
    cursor?: ReadingProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReadingProgressScalarFieldEnum | ReadingProgressScalarFieldEnum[]
  }

  /**
   * User.roles
   */
  export type User$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Bookshelf
   */

  export type AggregateBookshelf = {
    _count: BookshelfCountAggregateOutputType | null
    _min: BookshelfMinAggregateOutputType | null
    _max: BookshelfMaxAggregateOutputType | null
  }

  export type BookshelfMinAggregateOutputType = {
    id: string | null
    userId: string | null
    bookVersionId: string | null
    addedAt: Date | null
  }

  export type BookshelfMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    bookVersionId: string | null
    addedAt: Date | null
  }

  export type BookshelfCountAggregateOutputType = {
    id: number
    userId: number
    bookVersionId: number
    addedAt: number
    _all: number
  }


  export type BookshelfMinAggregateInputType = {
    id?: true
    userId?: true
    bookVersionId?: true
    addedAt?: true
  }

  export type BookshelfMaxAggregateInputType = {
    id?: true
    userId?: true
    bookVersionId?: true
    addedAt?: true
  }

  export type BookshelfCountAggregateInputType = {
    id?: true
    userId?: true
    bookVersionId?: true
    addedAt?: true
    _all?: true
  }

  export type BookshelfAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookshelf to aggregate.
     */
    where?: BookshelfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookshelves to fetch.
     */
    orderBy?: BookshelfOrderByWithRelationInput | BookshelfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookshelfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookshelves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookshelves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookshelves
    **/
    _count?: true | BookshelfCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookshelfMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookshelfMaxAggregateInputType
  }

  export type GetBookshelfAggregateType<T extends BookshelfAggregateArgs> = {
        [P in keyof T & keyof AggregateBookshelf]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookshelf[P]>
      : GetScalarType<T[P], AggregateBookshelf[P]>
  }




  export type BookshelfGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookshelfWhereInput
    orderBy?: BookshelfOrderByWithAggregationInput | BookshelfOrderByWithAggregationInput[]
    by: BookshelfScalarFieldEnum[] | BookshelfScalarFieldEnum
    having?: BookshelfScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookshelfCountAggregateInputType | true
    _min?: BookshelfMinAggregateInputType
    _max?: BookshelfMaxAggregateInputType
  }

  export type BookshelfGroupByOutputType = {
    id: string
    userId: string
    bookVersionId: string
    addedAt: Date
    _count: BookshelfCountAggregateOutputType | null
    _min: BookshelfMinAggregateOutputType | null
    _max: BookshelfMaxAggregateOutputType | null
  }

  type GetBookshelfGroupByPayload<T extends BookshelfGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookshelfGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookshelfGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookshelfGroupByOutputType[P]>
            : GetScalarType<T[P], BookshelfGroupByOutputType[P]>
        }
      >
    >


  export type BookshelfSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookVersionId?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookshelf"]>

  export type BookshelfSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookVersionId?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookshelf"]>

  export type BookshelfSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookVersionId?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookshelf"]>

  export type BookshelfSelectScalar = {
    id?: boolean
    userId?: boolean
    bookVersionId?: boolean
    addedAt?: boolean
  }

  export type BookshelfOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "bookVersionId" | "addedAt", ExtArgs["result"]["bookshelf"]>
  export type BookshelfInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }
  export type BookshelfIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }
  export type BookshelfIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }

  export type $BookshelfPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bookshelf"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bookVersion: Prisma.$BookVersionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      bookVersionId: string
      addedAt: Date
    }, ExtArgs["result"]["bookshelf"]>
    composites: {}
  }

  type BookshelfGetPayload<S extends boolean | null | undefined | BookshelfDefaultArgs> = $Result.GetResult<Prisma.$BookshelfPayload, S>

  type BookshelfCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookshelfFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookshelfCountAggregateInputType | true
    }

  export interface BookshelfDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bookshelf'], meta: { name: 'Bookshelf' } }
    /**
     * Find zero or one Bookshelf that matches the filter.
     * @param {BookshelfFindUniqueArgs} args - Arguments to find a Bookshelf
     * @example
     * // Get one Bookshelf
     * const bookshelf = await prisma.bookshelf.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookshelfFindUniqueArgs>(args: SelectSubset<T, BookshelfFindUniqueArgs<ExtArgs>>): Prisma__BookshelfClient<$Result.GetResult<Prisma.$BookshelfPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bookshelf that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookshelfFindUniqueOrThrowArgs} args - Arguments to find a Bookshelf
     * @example
     * // Get one Bookshelf
     * const bookshelf = await prisma.bookshelf.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookshelfFindUniqueOrThrowArgs>(args: SelectSubset<T, BookshelfFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookshelfClient<$Result.GetResult<Prisma.$BookshelfPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bookshelf that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookshelfFindFirstArgs} args - Arguments to find a Bookshelf
     * @example
     * // Get one Bookshelf
     * const bookshelf = await prisma.bookshelf.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookshelfFindFirstArgs>(args?: SelectSubset<T, BookshelfFindFirstArgs<ExtArgs>>): Prisma__BookshelfClient<$Result.GetResult<Prisma.$BookshelfPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bookshelf that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookshelfFindFirstOrThrowArgs} args - Arguments to find a Bookshelf
     * @example
     * // Get one Bookshelf
     * const bookshelf = await prisma.bookshelf.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookshelfFindFirstOrThrowArgs>(args?: SelectSubset<T, BookshelfFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookshelfClient<$Result.GetResult<Prisma.$BookshelfPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookshelves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookshelfFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookshelves
     * const bookshelves = await prisma.bookshelf.findMany()
     * 
     * // Get first 10 Bookshelves
     * const bookshelves = await prisma.bookshelf.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookshelfWithIdOnly = await prisma.bookshelf.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookshelfFindManyArgs>(args?: SelectSubset<T, BookshelfFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookshelfPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bookshelf.
     * @param {BookshelfCreateArgs} args - Arguments to create a Bookshelf.
     * @example
     * // Create one Bookshelf
     * const Bookshelf = await prisma.bookshelf.create({
     *   data: {
     *     // ... data to create a Bookshelf
     *   }
     * })
     * 
     */
    create<T extends BookshelfCreateArgs>(args: SelectSubset<T, BookshelfCreateArgs<ExtArgs>>): Prisma__BookshelfClient<$Result.GetResult<Prisma.$BookshelfPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookshelves.
     * @param {BookshelfCreateManyArgs} args - Arguments to create many Bookshelves.
     * @example
     * // Create many Bookshelves
     * const bookshelf = await prisma.bookshelf.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookshelfCreateManyArgs>(args?: SelectSubset<T, BookshelfCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookshelves and returns the data saved in the database.
     * @param {BookshelfCreateManyAndReturnArgs} args - Arguments to create many Bookshelves.
     * @example
     * // Create many Bookshelves
     * const bookshelf = await prisma.bookshelf.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookshelves and only return the `id`
     * const bookshelfWithIdOnly = await prisma.bookshelf.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookshelfCreateManyAndReturnArgs>(args?: SelectSubset<T, BookshelfCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookshelfPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bookshelf.
     * @param {BookshelfDeleteArgs} args - Arguments to delete one Bookshelf.
     * @example
     * // Delete one Bookshelf
     * const Bookshelf = await prisma.bookshelf.delete({
     *   where: {
     *     // ... filter to delete one Bookshelf
     *   }
     * })
     * 
     */
    delete<T extends BookshelfDeleteArgs>(args: SelectSubset<T, BookshelfDeleteArgs<ExtArgs>>): Prisma__BookshelfClient<$Result.GetResult<Prisma.$BookshelfPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bookshelf.
     * @param {BookshelfUpdateArgs} args - Arguments to update one Bookshelf.
     * @example
     * // Update one Bookshelf
     * const bookshelf = await prisma.bookshelf.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookshelfUpdateArgs>(args: SelectSubset<T, BookshelfUpdateArgs<ExtArgs>>): Prisma__BookshelfClient<$Result.GetResult<Prisma.$BookshelfPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookshelves.
     * @param {BookshelfDeleteManyArgs} args - Arguments to filter Bookshelves to delete.
     * @example
     * // Delete a few Bookshelves
     * const { count } = await prisma.bookshelf.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookshelfDeleteManyArgs>(args?: SelectSubset<T, BookshelfDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookshelves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookshelfUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookshelves
     * const bookshelf = await prisma.bookshelf.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookshelfUpdateManyArgs>(args: SelectSubset<T, BookshelfUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookshelves and returns the data updated in the database.
     * @param {BookshelfUpdateManyAndReturnArgs} args - Arguments to update many Bookshelves.
     * @example
     * // Update many Bookshelves
     * const bookshelf = await prisma.bookshelf.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookshelves and only return the `id`
     * const bookshelfWithIdOnly = await prisma.bookshelf.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookshelfUpdateManyAndReturnArgs>(args: SelectSubset<T, BookshelfUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookshelfPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bookshelf.
     * @param {BookshelfUpsertArgs} args - Arguments to update or create a Bookshelf.
     * @example
     * // Update or create a Bookshelf
     * const bookshelf = await prisma.bookshelf.upsert({
     *   create: {
     *     // ... data to create a Bookshelf
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bookshelf we want to update
     *   }
     * })
     */
    upsert<T extends BookshelfUpsertArgs>(args: SelectSubset<T, BookshelfUpsertArgs<ExtArgs>>): Prisma__BookshelfClient<$Result.GetResult<Prisma.$BookshelfPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookshelves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookshelfCountArgs} args - Arguments to filter Bookshelves to count.
     * @example
     * // Count the number of Bookshelves
     * const count = await prisma.bookshelf.count({
     *   where: {
     *     // ... the filter for the Bookshelves we want to count
     *   }
     * })
    **/
    count<T extends BookshelfCountArgs>(
      args?: Subset<T, BookshelfCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookshelfCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bookshelf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookshelfAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookshelfAggregateArgs>(args: Subset<T, BookshelfAggregateArgs>): Prisma.PrismaPromise<GetBookshelfAggregateType<T>>

    /**
     * Group by Bookshelf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookshelfGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookshelfGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookshelfGroupByArgs['orderBy'] }
        : { orderBy?: BookshelfGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookshelfGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookshelfGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bookshelf model
   */
  readonly fields: BookshelfFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bookshelf.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookshelfClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookVersion<T extends BookVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookVersionDefaultArgs<ExtArgs>>): Prisma__BookVersionClient<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bookshelf model
   */
  interface BookshelfFieldRefs {
    readonly id: FieldRef<"Bookshelf", 'String'>
    readonly userId: FieldRef<"Bookshelf", 'String'>
    readonly bookVersionId: FieldRef<"Bookshelf", 'String'>
    readonly addedAt: FieldRef<"Bookshelf", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bookshelf findUnique
   */
  export type BookshelfFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookshelf
     */
    select?: BookshelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookshelf
     */
    omit?: BookshelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookshelfInclude<ExtArgs> | null
    /**
     * Filter, which Bookshelf to fetch.
     */
    where: BookshelfWhereUniqueInput
  }

  /**
   * Bookshelf findUniqueOrThrow
   */
  export type BookshelfFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookshelf
     */
    select?: BookshelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookshelf
     */
    omit?: BookshelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookshelfInclude<ExtArgs> | null
    /**
     * Filter, which Bookshelf to fetch.
     */
    where: BookshelfWhereUniqueInput
  }

  /**
   * Bookshelf findFirst
   */
  export type BookshelfFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookshelf
     */
    select?: BookshelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookshelf
     */
    omit?: BookshelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookshelfInclude<ExtArgs> | null
    /**
     * Filter, which Bookshelf to fetch.
     */
    where?: BookshelfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookshelves to fetch.
     */
    orderBy?: BookshelfOrderByWithRelationInput | BookshelfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookshelves.
     */
    cursor?: BookshelfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookshelves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookshelves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookshelves.
     */
    distinct?: BookshelfScalarFieldEnum | BookshelfScalarFieldEnum[]
  }

  /**
   * Bookshelf findFirstOrThrow
   */
  export type BookshelfFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookshelf
     */
    select?: BookshelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookshelf
     */
    omit?: BookshelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookshelfInclude<ExtArgs> | null
    /**
     * Filter, which Bookshelf to fetch.
     */
    where?: BookshelfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookshelves to fetch.
     */
    orderBy?: BookshelfOrderByWithRelationInput | BookshelfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookshelves.
     */
    cursor?: BookshelfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookshelves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookshelves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookshelves.
     */
    distinct?: BookshelfScalarFieldEnum | BookshelfScalarFieldEnum[]
  }

  /**
   * Bookshelf findMany
   */
  export type BookshelfFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookshelf
     */
    select?: BookshelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookshelf
     */
    omit?: BookshelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookshelfInclude<ExtArgs> | null
    /**
     * Filter, which Bookshelves to fetch.
     */
    where?: BookshelfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookshelves to fetch.
     */
    orderBy?: BookshelfOrderByWithRelationInput | BookshelfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookshelves.
     */
    cursor?: BookshelfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookshelves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookshelves.
     */
    skip?: number
    distinct?: BookshelfScalarFieldEnum | BookshelfScalarFieldEnum[]
  }

  /**
   * Bookshelf create
   */
  export type BookshelfCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookshelf
     */
    select?: BookshelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookshelf
     */
    omit?: BookshelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookshelfInclude<ExtArgs> | null
    /**
     * The data needed to create a Bookshelf.
     */
    data: XOR<BookshelfCreateInput, BookshelfUncheckedCreateInput>
  }

  /**
   * Bookshelf createMany
   */
  export type BookshelfCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookshelves.
     */
    data: BookshelfCreateManyInput | BookshelfCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bookshelf createManyAndReturn
   */
  export type BookshelfCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookshelf
     */
    select?: BookshelfSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bookshelf
     */
    omit?: BookshelfOmit<ExtArgs> | null
    /**
     * The data used to create many Bookshelves.
     */
    data: BookshelfCreateManyInput | BookshelfCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookshelfIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bookshelf update
   */
  export type BookshelfUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookshelf
     */
    select?: BookshelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookshelf
     */
    omit?: BookshelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookshelfInclude<ExtArgs> | null
    /**
     * The data needed to update a Bookshelf.
     */
    data: XOR<BookshelfUpdateInput, BookshelfUncheckedUpdateInput>
    /**
     * Choose, which Bookshelf to update.
     */
    where: BookshelfWhereUniqueInput
  }

  /**
   * Bookshelf updateMany
   */
  export type BookshelfUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookshelves.
     */
    data: XOR<BookshelfUpdateManyMutationInput, BookshelfUncheckedUpdateManyInput>
    /**
     * Filter which Bookshelves to update
     */
    where?: BookshelfWhereInput
    /**
     * Limit how many Bookshelves to update.
     */
    limit?: number
  }

  /**
   * Bookshelf updateManyAndReturn
   */
  export type BookshelfUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookshelf
     */
    select?: BookshelfSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bookshelf
     */
    omit?: BookshelfOmit<ExtArgs> | null
    /**
     * The data used to update Bookshelves.
     */
    data: XOR<BookshelfUpdateManyMutationInput, BookshelfUncheckedUpdateManyInput>
    /**
     * Filter which Bookshelves to update
     */
    where?: BookshelfWhereInput
    /**
     * Limit how many Bookshelves to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookshelfIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bookshelf upsert
   */
  export type BookshelfUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookshelf
     */
    select?: BookshelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookshelf
     */
    omit?: BookshelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookshelfInclude<ExtArgs> | null
    /**
     * The filter to search for the Bookshelf to update in case it exists.
     */
    where: BookshelfWhereUniqueInput
    /**
     * In case the Bookshelf found by the `where` argument doesn't exist, create a new Bookshelf with this data.
     */
    create: XOR<BookshelfCreateInput, BookshelfUncheckedCreateInput>
    /**
     * In case the Bookshelf was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookshelfUpdateInput, BookshelfUncheckedUpdateInput>
  }

  /**
   * Bookshelf delete
   */
  export type BookshelfDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookshelf
     */
    select?: BookshelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookshelf
     */
    omit?: BookshelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookshelfInclude<ExtArgs> | null
    /**
     * Filter which Bookshelf to delete.
     */
    where: BookshelfWhereUniqueInput
  }

  /**
   * Bookshelf deleteMany
   */
  export type BookshelfDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookshelves to delete
     */
    where?: BookshelfWhereInput
    /**
     * Limit how many Bookshelves to delete.
     */
    limit?: number
  }

  /**
   * Bookshelf without action
   */
  export type BookshelfDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookshelf
     */
    select?: BookshelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookshelf
     */
    omit?: BookshelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookshelfInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    bookVersionId: string | null
    chapterId: string | null
    audioChapterId: string | null
    parentId: string | null
    text: string | null
    isDeleted: boolean | null
    isHidden: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    bookVersionId: string | null
    chapterId: string | null
    audioChapterId: string | null
    parentId: string | null
    text: string | null
    isDeleted: boolean | null
    isHidden: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    userId: number
    bookVersionId: number
    chapterId: number
    audioChapterId: number
    parentId: number
    text: number
    isDeleted: number
    isHidden: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    userId?: true
    bookVersionId?: true
    chapterId?: true
    audioChapterId?: true
    parentId?: true
    text?: true
    isDeleted?: true
    isHidden?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    userId?: true
    bookVersionId?: true
    chapterId?: true
    audioChapterId?: true
    parentId?: true
    text?: true
    isDeleted?: true
    isHidden?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    userId?: true
    bookVersionId?: true
    chapterId?: true
    audioChapterId?: true
    parentId?: true
    text?: true
    isDeleted?: true
    isHidden?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    userId: string
    bookVersionId: string | null
    chapterId: string | null
    audioChapterId: string | null
    parentId: string | null
    text: string
    isDeleted: boolean
    isHidden: boolean
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookVersionId?: boolean
    chapterId?: boolean
    audioChapterId?: boolean
    parentId?: boolean
    text?: boolean
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | Comment$bookVersionArgs<ExtArgs>
    chapter?: boolean | Comment$chapterArgs<ExtArgs>
    audioChapter?: boolean | Comment$audioChapterArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    children?: boolean | Comment$childrenArgs<ExtArgs>
    likes?: boolean | Comment$likesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookVersionId?: boolean
    chapterId?: boolean
    audioChapterId?: boolean
    parentId?: boolean
    text?: boolean
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | Comment$bookVersionArgs<ExtArgs>
    chapter?: boolean | Comment$chapterArgs<ExtArgs>
    audioChapter?: boolean | Comment$audioChapterArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookVersionId?: boolean
    chapterId?: boolean
    audioChapterId?: boolean
    parentId?: boolean
    text?: boolean
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | Comment$bookVersionArgs<ExtArgs>
    chapter?: boolean | Comment$chapterArgs<ExtArgs>
    audioChapter?: boolean | Comment$audioChapterArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    userId?: boolean
    bookVersionId?: boolean
    chapterId?: boolean
    audioChapterId?: boolean
    parentId?: boolean
    text?: boolean
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "bookVersionId" | "chapterId" | "audioChapterId" | "parentId" | "text" | "isDeleted" | "isHidden" | "createdAt" | "updatedAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | Comment$bookVersionArgs<ExtArgs>
    chapter?: boolean | Comment$chapterArgs<ExtArgs>
    audioChapter?: boolean | Comment$audioChapterArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    children?: boolean | Comment$childrenArgs<ExtArgs>
    likes?: boolean | Comment$likesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | Comment$bookVersionArgs<ExtArgs>
    chapter?: boolean | Comment$chapterArgs<ExtArgs>
    audioChapter?: boolean | Comment$audioChapterArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | Comment$bookVersionArgs<ExtArgs>
    chapter?: boolean | Comment$chapterArgs<ExtArgs>
    audioChapter?: boolean | Comment$audioChapterArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bookVersion: Prisma.$BookVersionPayload<ExtArgs> | null
      chapter: Prisma.$ChapterPayload<ExtArgs> | null
      audioChapter: Prisma.$AudioChapterPayload<ExtArgs> | null
      parent: Prisma.$CommentPayload<ExtArgs> | null
      children: Prisma.$CommentPayload<ExtArgs>[]
      likes: Prisma.$LikePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      bookVersionId: string | null
      chapterId: string | null
      audioChapterId: string | null
      parentId: string | null
      text: string
      isDeleted: boolean
      isHidden: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookVersion<T extends Comment$bookVersionArgs<ExtArgs> = {}>(args?: Subset<T, Comment$bookVersionArgs<ExtArgs>>): Prisma__BookVersionClient<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    chapter<T extends Comment$chapterArgs<ExtArgs> = {}>(args?: Subset<T, Comment$chapterArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    audioChapter<T extends Comment$audioChapterArgs<ExtArgs> = {}>(args?: Subset<T, Comment$audioChapterArgs<ExtArgs>>): Prisma__AudioChapterClient<$Result.GetResult<Prisma.$AudioChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parent<T extends Comment$parentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Comment$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Comment$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends Comment$likesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly userId: FieldRef<"Comment", 'String'>
    readonly bookVersionId: FieldRef<"Comment", 'String'>
    readonly chapterId: FieldRef<"Comment", 'String'>
    readonly audioChapterId: FieldRef<"Comment", 'String'>
    readonly parentId: FieldRef<"Comment", 'String'>
    readonly text: FieldRef<"Comment", 'String'>
    readonly isDeleted: FieldRef<"Comment", 'Boolean'>
    readonly isHidden: FieldRef<"Comment", 'Boolean'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.bookVersion
   */
  export type Comment$bookVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookVersion
     */
    select?: BookVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookVersion
     */
    omit?: BookVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookVersionInclude<ExtArgs> | null
    where?: BookVersionWhereInput
  }

  /**
   * Comment.chapter
   */
  export type Comment$chapterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    where?: ChapterWhereInput
  }

  /**
   * Comment.audioChapter
   */
  export type Comment$audioChapterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioChapter
     */
    select?: AudioChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioChapter
     */
    omit?: AudioChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioChapterInclude<ExtArgs> | null
    where?: AudioChapterWhereInput
  }

  /**
   * Comment.parent
   */
  export type Comment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.children
   */
  export type Comment$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment.likes
   */
  export type Comment$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Like
   */

  export type AggregateLike = {
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  export type LikeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    bookVersionId: string | null
    commentId: string | null
    createdAt: Date | null
  }

  export type LikeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    bookVersionId: string | null
    commentId: string | null
    createdAt: Date | null
  }

  export type LikeCountAggregateOutputType = {
    id: number
    userId: number
    bookVersionId: number
    commentId: number
    createdAt: number
    _all: number
  }


  export type LikeMinAggregateInputType = {
    id?: true
    userId?: true
    bookVersionId?: true
    commentId?: true
    createdAt?: true
  }

  export type LikeMaxAggregateInputType = {
    id?: true
    userId?: true
    bookVersionId?: true
    commentId?: true
    createdAt?: true
  }

  export type LikeCountAggregateInputType = {
    id?: true
    userId?: true
    bookVersionId?: true
    commentId?: true
    createdAt?: true
    _all?: true
  }

  export type LikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Like to aggregate.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Likes
    **/
    _count?: true | LikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikeMaxAggregateInputType
  }

  export type GetLikeAggregateType<T extends LikeAggregateArgs> = {
        [P in keyof T & keyof AggregateLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLike[P]>
      : GetScalarType<T[P], AggregateLike[P]>
  }




  export type LikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithAggregationInput | LikeOrderByWithAggregationInput[]
    by: LikeScalarFieldEnum[] | LikeScalarFieldEnum
    having?: LikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikeCountAggregateInputType | true
    _min?: LikeMinAggregateInputType
    _max?: LikeMaxAggregateInputType
  }

  export type LikeGroupByOutputType = {
    id: string
    userId: string
    bookVersionId: string | null
    commentId: string | null
    createdAt: Date
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  type GetLikeGroupByPayload<T extends LikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikeGroupByOutputType[P]>
            : GetScalarType<T[P], LikeGroupByOutputType[P]>
        }
      >
    >


  export type LikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookVersionId?: boolean
    commentId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | Like$bookVersionArgs<ExtArgs>
    comment?: boolean | Like$commentArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookVersionId?: boolean
    commentId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | Like$bookVersionArgs<ExtArgs>
    comment?: boolean | Like$commentArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookVersionId?: boolean
    commentId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | Like$bookVersionArgs<ExtArgs>
    comment?: boolean | Like$commentArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectScalar = {
    id?: boolean
    userId?: boolean
    bookVersionId?: boolean
    commentId?: boolean
    createdAt?: boolean
  }

  export type LikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "bookVersionId" | "commentId" | "createdAt", ExtArgs["result"]["like"]>
  export type LikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | Like$bookVersionArgs<ExtArgs>
    comment?: boolean | Like$commentArgs<ExtArgs>
  }
  export type LikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | Like$bookVersionArgs<ExtArgs>
    comment?: boolean | Like$commentArgs<ExtArgs>
  }
  export type LikeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | Like$bookVersionArgs<ExtArgs>
    comment?: boolean | Like$commentArgs<ExtArgs>
  }

  export type $LikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Like"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bookVersion: Prisma.$BookVersionPayload<ExtArgs> | null
      comment: Prisma.$CommentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      bookVersionId: string | null
      commentId: string | null
      createdAt: Date
    }, ExtArgs["result"]["like"]>
    composites: {}
  }

  type LikeGetPayload<S extends boolean | null | undefined | LikeDefaultArgs> = $Result.GetResult<Prisma.$LikePayload, S>

  type LikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LikeCountAggregateInputType | true
    }

  export interface LikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Like'], meta: { name: 'Like' } }
    /**
     * Find zero or one Like that matches the filter.
     * @param {LikeFindUniqueArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LikeFindUniqueArgs>(args: SelectSubset<T, LikeFindUniqueArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Like that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LikeFindUniqueOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LikeFindUniqueOrThrowArgs>(args: SelectSubset<T, LikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Like that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LikeFindFirstArgs>(args?: SelectSubset<T, LikeFindFirstArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Like that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LikeFindFirstOrThrowArgs>(args?: SelectSubset<T, LikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Likes
     * const likes = await prisma.like.findMany()
     * 
     * // Get first 10 Likes
     * const likes = await prisma.like.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likeWithIdOnly = await prisma.like.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LikeFindManyArgs>(args?: SelectSubset<T, LikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Like.
     * @param {LikeCreateArgs} args - Arguments to create a Like.
     * @example
     * // Create one Like
     * const Like = await prisma.like.create({
     *   data: {
     *     // ... data to create a Like
     *   }
     * })
     * 
     */
    create<T extends LikeCreateArgs>(args: SelectSubset<T, LikeCreateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Likes.
     * @param {LikeCreateManyArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LikeCreateManyArgs>(args?: SelectSubset<T, LikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Likes and returns the data saved in the database.
     * @param {LikeCreateManyAndReturnArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Likes and only return the `id`
     * const likeWithIdOnly = await prisma.like.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LikeCreateManyAndReturnArgs>(args?: SelectSubset<T, LikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Like.
     * @param {LikeDeleteArgs} args - Arguments to delete one Like.
     * @example
     * // Delete one Like
     * const Like = await prisma.like.delete({
     *   where: {
     *     // ... filter to delete one Like
     *   }
     * })
     * 
     */
    delete<T extends LikeDeleteArgs>(args: SelectSubset<T, LikeDeleteArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Like.
     * @param {LikeUpdateArgs} args - Arguments to update one Like.
     * @example
     * // Update one Like
     * const like = await prisma.like.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LikeUpdateArgs>(args: SelectSubset<T, LikeUpdateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Likes.
     * @param {LikeDeleteManyArgs} args - Arguments to filter Likes to delete.
     * @example
     * // Delete a few Likes
     * const { count } = await prisma.like.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LikeDeleteManyArgs>(args?: SelectSubset<T, LikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Likes
     * const like = await prisma.like.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LikeUpdateManyArgs>(args: SelectSubset<T, LikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes and returns the data updated in the database.
     * @param {LikeUpdateManyAndReturnArgs} args - Arguments to update many Likes.
     * @example
     * // Update many Likes
     * const like = await prisma.like.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Likes and only return the `id`
     * const likeWithIdOnly = await prisma.like.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LikeUpdateManyAndReturnArgs>(args: SelectSubset<T, LikeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Like.
     * @param {LikeUpsertArgs} args - Arguments to update or create a Like.
     * @example
     * // Update or create a Like
     * const like = await prisma.like.upsert({
     *   create: {
     *     // ... data to create a Like
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Like we want to update
     *   }
     * })
     */
    upsert<T extends LikeUpsertArgs>(args: SelectSubset<T, LikeUpsertArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCountArgs} args - Arguments to filter Likes to count.
     * @example
     * // Count the number of Likes
     * const count = await prisma.like.count({
     *   where: {
     *     // ... the filter for the Likes we want to count
     *   }
     * })
    **/
    count<T extends LikeCountArgs>(
      args?: Subset<T, LikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikeAggregateArgs>(args: Subset<T, LikeAggregateArgs>): Prisma.PrismaPromise<GetLikeAggregateType<T>>

    /**
     * Group by Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikeGroupByArgs['orderBy'] }
        : { orderBy?: LikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Like model
   */
  readonly fields: LikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Like.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookVersion<T extends Like$bookVersionArgs<ExtArgs> = {}>(args?: Subset<T, Like$bookVersionArgs<ExtArgs>>): Prisma__BookVersionClient<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comment<T extends Like$commentArgs<ExtArgs> = {}>(args?: Subset<T, Like$commentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Like model
   */
  interface LikeFieldRefs {
    readonly id: FieldRef<"Like", 'String'>
    readonly userId: FieldRef<"Like", 'String'>
    readonly bookVersionId: FieldRef<"Like", 'String'>
    readonly commentId: FieldRef<"Like", 'String'>
    readonly createdAt: FieldRef<"Like", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Like findUnique
   */
  export type LikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findUniqueOrThrow
   */
  export type LikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findFirst
   */
  export type LikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findFirstOrThrow
   */
  export type LikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findMany
   */
  export type LikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Likes to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like create
   */
  export type LikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to create a Like.
     */
    data: XOR<LikeCreateInput, LikeUncheckedCreateInput>
  }

  /**
   * Like createMany
   */
  export type LikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Like createManyAndReturn
   */
  export type LikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Like update
   */
  export type LikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to update a Like.
     */
    data: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
    /**
     * Choose, which Like to update.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like updateMany
   */
  export type LikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Likes.
     */
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikeWhereInput
    /**
     * Limit how many Likes to update.
     */
    limit?: number
  }

  /**
   * Like updateManyAndReturn
   */
  export type LikeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * The data used to update Likes.
     */
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikeWhereInput
    /**
     * Limit how many Likes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Like upsert
   */
  export type LikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The filter to search for the Like to update in case it exists.
     */
    where: LikeWhereUniqueInput
    /**
     * In case the Like found by the `where` argument doesn't exist, create a new Like with this data.
     */
    create: XOR<LikeCreateInput, LikeUncheckedCreateInput>
    /**
     * In case the Like was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
  }

  /**
   * Like delete
   */
  export type LikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter which Like to delete.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like deleteMany
   */
  export type LikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Likes to delete
     */
    where?: LikeWhereInput
    /**
     * Limit how many Likes to delete.
     */
    limit?: number
  }

  /**
   * Like.bookVersion
   */
  export type Like$bookVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookVersion
     */
    select?: BookVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookVersion
     */
    omit?: BookVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookVersionInclude<ExtArgs> | null
    where?: BookVersionWhereInput
  }

  /**
   * Like.comment
   */
  export type Like$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Like without action
   */
  export type LikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    type: $Enums.CategoryType | null
    name: string | null
    slug: string | null
    parentId: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    type: $Enums.CategoryType | null
    name: string | null
    slug: string | null
    parentId: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    type: number
    name: number
    slug: number
    parentId: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    slug?: true
    parentId?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    slug?: true
    parentId?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    slug?: true
    parentId?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    type: $Enums.CategoryType
    name: string
    slug: string
    parentId: string | null
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    slug?: boolean
    parentId?: boolean
    books?: boolean | Category$booksArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    slug?: boolean
    parentId?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    slug?: boolean
    parentId?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    slug?: boolean
    parentId?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "name" | "slug" | "parentId", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | Category$booksArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      books: Prisma.$BookCategoryPayload<ExtArgs>[]
      parent: Prisma.$CategoryPayload<ExtArgs> | null
      children: Prisma.$CategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.CategoryType
      name: string
      slug: string
      parentId: string | null
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    books<T extends Category$booksArgs<ExtArgs> = {}>(args?: Subset<T, Category$booksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parent<T extends Category$parentArgs<ExtArgs> = {}>(args?: Subset<T, Category$parentArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Category$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Category$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly type: FieldRef<"Category", 'CategoryType'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly parentId: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.books
   */
  export type Category$booksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCategory
     */
    omit?: BookCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCategoryInclude<ExtArgs> | null
    where?: BookCategoryWhereInput
    orderBy?: BookCategoryOrderByWithRelationInput | BookCategoryOrderByWithRelationInput[]
    cursor?: BookCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookCategoryScalarFieldEnum | BookCategoryScalarFieldEnum[]
  }

  /**
   * Category.parent
   */
  export type Category$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Category.children
   */
  export type Category$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model BookCategory
   */

  export type AggregateBookCategory = {
    _count: BookCategoryCountAggregateOutputType | null
    _min: BookCategoryMinAggregateOutputType | null
    _max: BookCategoryMaxAggregateOutputType | null
  }

  export type BookCategoryMinAggregateOutputType = {
    id: string | null
    bookVersionId: string | null
    categoryId: string | null
  }

  export type BookCategoryMaxAggregateOutputType = {
    id: string | null
    bookVersionId: string | null
    categoryId: string | null
  }

  export type BookCategoryCountAggregateOutputType = {
    id: number
    bookVersionId: number
    categoryId: number
    _all: number
  }


  export type BookCategoryMinAggregateInputType = {
    id?: true
    bookVersionId?: true
    categoryId?: true
  }

  export type BookCategoryMaxAggregateInputType = {
    id?: true
    bookVersionId?: true
    categoryId?: true
  }

  export type BookCategoryCountAggregateInputType = {
    id?: true
    bookVersionId?: true
    categoryId?: true
    _all?: true
  }

  export type BookCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookCategory to aggregate.
     */
    where?: BookCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookCategories to fetch.
     */
    orderBy?: BookCategoryOrderByWithRelationInput | BookCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookCategories
    **/
    _count?: true | BookCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookCategoryMaxAggregateInputType
  }

  export type GetBookCategoryAggregateType<T extends BookCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBookCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookCategory[P]>
      : GetScalarType<T[P], AggregateBookCategory[P]>
  }




  export type BookCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookCategoryWhereInput
    orderBy?: BookCategoryOrderByWithAggregationInput | BookCategoryOrderByWithAggregationInput[]
    by: BookCategoryScalarFieldEnum[] | BookCategoryScalarFieldEnum
    having?: BookCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookCategoryCountAggregateInputType | true
    _min?: BookCategoryMinAggregateInputType
    _max?: BookCategoryMaxAggregateInputType
  }

  export type BookCategoryGroupByOutputType = {
    id: string
    bookVersionId: string
    categoryId: string
    _count: BookCategoryCountAggregateOutputType | null
    _min: BookCategoryMinAggregateOutputType | null
    _max: BookCategoryMaxAggregateOutputType | null
  }

  type GetBookCategoryGroupByPayload<T extends BookCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], BookCategoryGroupByOutputType[P]>
        }
      >
    >


  export type BookCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookVersionId?: boolean
    categoryId?: boolean
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookCategory"]>

  export type BookCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookVersionId?: boolean
    categoryId?: boolean
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookCategory"]>

  export type BookCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookVersionId?: boolean
    categoryId?: boolean
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookCategory"]>

  export type BookCategorySelectScalar = {
    id?: boolean
    bookVersionId?: boolean
    categoryId?: boolean
  }

  export type BookCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookVersionId" | "categoryId", ExtArgs["result"]["bookCategory"]>
  export type BookCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type BookCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type BookCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $BookCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookCategory"
    objects: {
      bookVersion: Prisma.$BookVersionPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookVersionId: string
      categoryId: string
    }, ExtArgs["result"]["bookCategory"]>
    composites: {}
  }

  type BookCategoryGetPayload<S extends boolean | null | undefined | BookCategoryDefaultArgs> = $Result.GetResult<Prisma.$BookCategoryPayload, S>

  type BookCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookCategoryCountAggregateInputType | true
    }

  export interface BookCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookCategory'], meta: { name: 'BookCategory' } }
    /**
     * Find zero or one BookCategory that matches the filter.
     * @param {BookCategoryFindUniqueArgs} args - Arguments to find a BookCategory
     * @example
     * // Get one BookCategory
     * const bookCategory = await prisma.bookCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookCategoryFindUniqueArgs>(args: SelectSubset<T, BookCategoryFindUniqueArgs<ExtArgs>>): Prisma__BookCategoryClient<$Result.GetResult<Prisma.$BookCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookCategoryFindUniqueOrThrowArgs} args - Arguments to find a BookCategory
     * @example
     * // Get one BookCategory
     * const bookCategory = await prisma.bookCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, BookCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookCategoryClient<$Result.GetResult<Prisma.$BookCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCategoryFindFirstArgs} args - Arguments to find a BookCategory
     * @example
     * // Get one BookCategory
     * const bookCategory = await prisma.bookCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookCategoryFindFirstArgs>(args?: SelectSubset<T, BookCategoryFindFirstArgs<ExtArgs>>): Prisma__BookCategoryClient<$Result.GetResult<Prisma.$BookCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCategoryFindFirstOrThrowArgs} args - Arguments to find a BookCategory
     * @example
     * // Get one BookCategory
     * const bookCategory = await prisma.bookCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, BookCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookCategoryClient<$Result.GetResult<Prisma.$BookCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookCategories
     * const bookCategories = await prisma.bookCategory.findMany()
     * 
     * // Get first 10 BookCategories
     * const bookCategories = await prisma.bookCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookCategoryWithIdOnly = await prisma.bookCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookCategoryFindManyArgs>(args?: SelectSubset<T, BookCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookCategory.
     * @param {BookCategoryCreateArgs} args - Arguments to create a BookCategory.
     * @example
     * // Create one BookCategory
     * const BookCategory = await prisma.bookCategory.create({
     *   data: {
     *     // ... data to create a BookCategory
     *   }
     * })
     * 
     */
    create<T extends BookCategoryCreateArgs>(args: SelectSubset<T, BookCategoryCreateArgs<ExtArgs>>): Prisma__BookCategoryClient<$Result.GetResult<Prisma.$BookCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookCategories.
     * @param {BookCategoryCreateManyArgs} args - Arguments to create many BookCategories.
     * @example
     * // Create many BookCategories
     * const bookCategory = await prisma.bookCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookCategoryCreateManyArgs>(args?: SelectSubset<T, BookCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookCategories and returns the data saved in the database.
     * @param {BookCategoryCreateManyAndReturnArgs} args - Arguments to create many BookCategories.
     * @example
     * // Create many BookCategories
     * const bookCategory = await prisma.bookCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookCategories and only return the `id`
     * const bookCategoryWithIdOnly = await prisma.bookCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, BookCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookCategory.
     * @param {BookCategoryDeleteArgs} args - Arguments to delete one BookCategory.
     * @example
     * // Delete one BookCategory
     * const BookCategory = await prisma.bookCategory.delete({
     *   where: {
     *     // ... filter to delete one BookCategory
     *   }
     * })
     * 
     */
    delete<T extends BookCategoryDeleteArgs>(args: SelectSubset<T, BookCategoryDeleteArgs<ExtArgs>>): Prisma__BookCategoryClient<$Result.GetResult<Prisma.$BookCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookCategory.
     * @param {BookCategoryUpdateArgs} args - Arguments to update one BookCategory.
     * @example
     * // Update one BookCategory
     * const bookCategory = await prisma.bookCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookCategoryUpdateArgs>(args: SelectSubset<T, BookCategoryUpdateArgs<ExtArgs>>): Prisma__BookCategoryClient<$Result.GetResult<Prisma.$BookCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookCategories.
     * @param {BookCategoryDeleteManyArgs} args - Arguments to filter BookCategories to delete.
     * @example
     * // Delete a few BookCategories
     * const { count } = await prisma.bookCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookCategoryDeleteManyArgs>(args?: SelectSubset<T, BookCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookCategories
     * const bookCategory = await prisma.bookCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookCategoryUpdateManyArgs>(args: SelectSubset<T, BookCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookCategories and returns the data updated in the database.
     * @param {BookCategoryUpdateManyAndReturnArgs} args - Arguments to update many BookCategories.
     * @example
     * // Update many BookCategories
     * const bookCategory = await prisma.bookCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookCategories and only return the `id`
     * const bookCategoryWithIdOnly = await prisma.bookCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, BookCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookCategory.
     * @param {BookCategoryUpsertArgs} args - Arguments to update or create a BookCategory.
     * @example
     * // Update or create a BookCategory
     * const bookCategory = await prisma.bookCategory.upsert({
     *   create: {
     *     // ... data to create a BookCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookCategory we want to update
     *   }
     * })
     */
    upsert<T extends BookCategoryUpsertArgs>(args: SelectSubset<T, BookCategoryUpsertArgs<ExtArgs>>): Prisma__BookCategoryClient<$Result.GetResult<Prisma.$BookCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCategoryCountArgs} args - Arguments to filter BookCategories to count.
     * @example
     * // Count the number of BookCategories
     * const count = await prisma.bookCategory.count({
     *   where: {
     *     // ... the filter for the BookCategories we want to count
     *   }
     * })
    **/
    count<T extends BookCategoryCountArgs>(
      args?: Subset<T, BookCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookCategoryAggregateArgs>(args: Subset<T, BookCategoryAggregateArgs>): Prisma.PrismaPromise<GetBookCategoryAggregateType<T>>

    /**
     * Group by BookCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookCategoryGroupByArgs['orderBy'] }
        : { orderBy?: BookCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookCategory model
   */
  readonly fields: BookCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookVersion<T extends BookVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookVersionDefaultArgs<ExtArgs>>): Prisma__BookVersionClient<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookCategory model
   */
  interface BookCategoryFieldRefs {
    readonly id: FieldRef<"BookCategory", 'String'>
    readonly bookVersionId: FieldRef<"BookCategory", 'String'>
    readonly categoryId: FieldRef<"BookCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BookCategory findUnique
   */
  export type BookCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCategory
     */
    omit?: BookCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BookCategory to fetch.
     */
    where: BookCategoryWhereUniqueInput
  }

  /**
   * BookCategory findUniqueOrThrow
   */
  export type BookCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCategory
     */
    omit?: BookCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BookCategory to fetch.
     */
    where: BookCategoryWhereUniqueInput
  }

  /**
   * BookCategory findFirst
   */
  export type BookCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCategory
     */
    omit?: BookCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BookCategory to fetch.
     */
    where?: BookCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookCategories to fetch.
     */
    orderBy?: BookCategoryOrderByWithRelationInput | BookCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookCategories.
     */
    cursor?: BookCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookCategories.
     */
    distinct?: BookCategoryScalarFieldEnum | BookCategoryScalarFieldEnum[]
  }

  /**
   * BookCategory findFirstOrThrow
   */
  export type BookCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCategory
     */
    omit?: BookCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BookCategory to fetch.
     */
    where?: BookCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookCategories to fetch.
     */
    orderBy?: BookCategoryOrderByWithRelationInput | BookCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookCategories.
     */
    cursor?: BookCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookCategories.
     */
    distinct?: BookCategoryScalarFieldEnum | BookCategoryScalarFieldEnum[]
  }

  /**
   * BookCategory findMany
   */
  export type BookCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCategory
     */
    omit?: BookCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BookCategories to fetch.
     */
    where?: BookCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookCategories to fetch.
     */
    orderBy?: BookCategoryOrderByWithRelationInput | BookCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookCategories.
     */
    cursor?: BookCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookCategories.
     */
    skip?: number
    distinct?: BookCategoryScalarFieldEnum | BookCategoryScalarFieldEnum[]
  }

  /**
   * BookCategory create
   */
  export type BookCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCategory
     */
    omit?: BookCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a BookCategory.
     */
    data: XOR<BookCategoryCreateInput, BookCategoryUncheckedCreateInput>
  }

  /**
   * BookCategory createMany
   */
  export type BookCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookCategories.
     */
    data: BookCategoryCreateManyInput | BookCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookCategory createManyAndReturn
   */
  export type BookCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookCategory
     */
    omit?: BookCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many BookCategories.
     */
    data: BookCategoryCreateManyInput | BookCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookCategory update
   */
  export type BookCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCategory
     */
    omit?: BookCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a BookCategory.
     */
    data: XOR<BookCategoryUpdateInput, BookCategoryUncheckedUpdateInput>
    /**
     * Choose, which BookCategory to update.
     */
    where: BookCategoryWhereUniqueInput
  }

  /**
   * BookCategory updateMany
   */
  export type BookCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookCategories.
     */
    data: XOR<BookCategoryUpdateManyMutationInput, BookCategoryUncheckedUpdateManyInput>
    /**
     * Filter which BookCategories to update
     */
    where?: BookCategoryWhereInput
    /**
     * Limit how many BookCategories to update.
     */
    limit?: number
  }

  /**
   * BookCategory updateManyAndReturn
   */
  export type BookCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookCategory
     */
    omit?: BookCategoryOmit<ExtArgs> | null
    /**
     * The data used to update BookCategories.
     */
    data: XOR<BookCategoryUpdateManyMutationInput, BookCategoryUncheckedUpdateManyInput>
    /**
     * Filter which BookCategories to update
     */
    where?: BookCategoryWhereInput
    /**
     * Limit how many BookCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookCategory upsert
   */
  export type BookCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCategory
     */
    omit?: BookCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the BookCategory to update in case it exists.
     */
    where: BookCategoryWhereUniqueInput
    /**
     * In case the BookCategory found by the `where` argument doesn't exist, create a new BookCategory with this data.
     */
    create: XOR<BookCategoryCreateInput, BookCategoryUncheckedCreateInput>
    /**
     * In case the BookCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookCategoryUpdateInput, BookCategoryUncheckedUpdateInput>
  }

  /**
   * BookCategory delete
   */
  export type BookCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCategory
     */
    omit?: BookCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCategoryInclude<ExtArgs> | null
    /**
     * Filter which BookCategory to delete.
     */
    where: BookCategoryWhereUniqueInput
  }

  /**
   * BookCategory deleteMany
   */
  export type BookCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookCategories to delete
     */
    where?: BookCategoryWhereInput
    /**
     * Limit how many BookCategories to delete.
     */
    limit?: number
  }

  /**
   * BookCategory without action
   */
  export type BookCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCategory
     */
    select?: BookCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCategory
     */
    omit?: BookCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    slug: string
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    books?: boolean | Tag$booksArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | Tag$booksArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      books: Prisma.$BookTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    books<T extends Tag$booksArgs<ExtArgs> = {}>(args?: Subset<T, Tag$booksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly slug: FieldRef<"Tag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.books
   */
  export type Tag$booksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookTag
     */
    select?: BookTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookTag
     */
    omit?: BookTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookTagInclude<ExtArgs> | null
    where?: BookTagWhereInput
    orderBy?: BookTagOrderByWithRelationInput | BookTagOrderByWithRelationInput[]
    cursor?: BookTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookTagScalarFieldEnum | BookTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model BookTag
   */

  export type AggregateBookTag = {
    _count: BookTagCountAggregateOutputType | null
    _min: BookTagMinAggregateOutputType | null
    _max: BookTagMaxAggregateOutputType | null
  }

  export type BookTagMinAggregateOutputType = {
    id: string | null
    bookVersionId: string | null
    tagId: string | null
  }

  export type BookTagMaxAggregateOutputType = {
    id: string | null
    bookVersionId: string | null
    tagId: string | null
  }

  export type BookTagCountAggregateOutputType = {
    id: number
    bookVersionId: number
    tagId: number
    _all: number
  }


  export type BookTagMinAggregateInputType = {
    id?: true
    bookVersionId?: true
    tagId?: true
  }

  export type BookTagMaxAggregateInputType = {
    id?: true
    bookVersionId?: true
    tagId?: true
  }

  export type BookTagCountAggregateInputType = {
    id?: true
    bookVersionId?: true
    tagId?: true
    _all?: true
  }

  export type BookTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookTag to aggregate.
     */
    where?: BookTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookTags to fetch.
     */
    orderBy?: BookTagOrderByWithRelationInput | BookTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookTags
    **/
    _count?: true | BookTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookTagMaxAggregateInputType
  }

  export type GetBookTagAggregateType<T extends BookTagAggregateArgs> = {
        [P in keyof T & keyof AggregateBookTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookTag[P]>
      : GetScalarType<T[P], AggregateBookTag[P]>
  }




  export type BookTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookTagWhereInput
    orderBy?: BookTagOrderByWithAggregationInput | BookTagOrderByWithAggregationInput[]
    by: BookTagScalarFieldEnum[] | BookTagScalarFieldEnum
    having?: BookTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookTagCountAggregateInputType | true
    _min?: BookTagMinAggregateInputType
    _max?: BookTagMaxAggregateInputType
  }

  export type BookTagGroupByOutputType = {
    id: string
    bookVersionId: string
    tagId: string
    _count: BookTagCountAggregateOutputType | null
    _min: BookTagMinAggregateOutputType | null
    _max: BookTagMaxAggregateOutputType | null
  }

  type GetBookTagGroupByPayload<T extends BookTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookTagGroupByOutputType[P]>
            : GetScalarType<T[P], BookTagGroupByOutputType[P]>
        }
      >
    >


  export type BookTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookVersionId?: boolean
    tagId?: boolean
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookTag"]>

  export type BookTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookVersionId?: boolean
    tagId?: boolean
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookTag"]>

  export type BookTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookVersionId?: boolean
    tagId?: boolean
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookTag"]>

  export type BookTagSelectScalar = {
    id?: boolean
    bookVersionId?: boolean
    tagId?: boolean
  }

  export type BookTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookVersionId" | "tagId", ExtArgs["result"]["bookTag"]>
  export type BookTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type BookTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type BookTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $BookTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookTag"
    objects: {
      bookVersion: Prisma.$BookVersionPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookVersionId: string
      tagId: string
    }, ExtArgs["result"]["bookTag"]>
    composites: {}
  }

  type BookTagGetPayload<S extends boolean | null | undefined | BookTagDefaultArgs> = $Result.GetResult<Prisma.$BookTagPayload, S>

  type BookTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookTagCountAggregateInputType | true
    }

  export interface BookTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookTag'], meta: { name: 'BookTag' } }
    /**
     * Find zero or one BookTag that matches the filter.
     * @param {BookTagFindUniqueArgs} args - Arguments to find a BookTag
     * @example
     * // Get one BookTag
     * const bookTag = await prisma.bookTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookTagFindUniqueArgs>(args: SelectSubset<T, BookTagFindUniqueArgs<ExtArgs>>): Prisma__BookTagClient<$Result.GetResult<Prisma.$BookTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookTagFindUniqueOrThrowArgs} args - Arguments to find a BookTag
     * @example
     * // Get one BookTag
     * const bookTag = await prisma.bookTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookTagFindUniqueOrThrowArgs>(args: SelectSubset<T, BookTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookTagClient<$Result.GetResult<Prisma.$BookTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookTagFindFirstArgs} args - Arguments to find a BookTag
     * @example
     * // Get one BookTag
     * const bookTag = await prisma.bookTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookTagFindFirstArgs>(args?: SelectSubset<T, BookTagFindFirstArgs<ExtArgs>>): Prisma__BookTagClient<$Result.GetResult<Prisma.$BookTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookTagFindFirstOrThrowArgs} args - Arguments to find a BookTag
     * @example
     * // Get one BookTag
     * const bookTag = await prisma.bookTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookTagFindFirstOrThrowArgs>(args?: SelectSubset<T, BookTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookTagClient<$Result.GetResult<Prisma.$BookTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookTags
     * const bookTags = await prisma.bookTag.findMany()
     * 
     * // Get first 10 BookTags
     * const bookTags = await prisma.bookTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookTagWithIdOnly = await prisma.bookTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookTagFindManyArgs>(args?: SelectSubset<T, BookTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookTag.
     * @param {BookTagCreateArgs} args - Arguments to create a BookTag.
     * @example
     * // Create one BookTag
     * const BookTag = await prisma.bookTag.create({
     *   data: {
     *     // ... data to create a BookTag
     *   }
     * })
     * 
     */
    create<T extends BookTagCreateArgs>(args: SelectSubset<T, BookTagCreateArgs<ExtArgs>>): Prisma__BookTagClient<$Result.GetResult<Prisma.$BookTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookTags.
     * @param {BookTagCreateManyArgs} args - Arguments to create many BookTags.
     * @example
     * // Create many BookTags
     * const bookTag = await prisma.bookTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookTagCreateManyArgs>(args?: SelectSubset<T, BookTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookTags and returns the data saved in the database.
     * @param {BookTagCreateManyAndReturnArgs} args - Arguments to create many BookTags.
     * @example
     * // Create many BookTags
     * const bookTag = await prisma.bookTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookTags and only return the `id`
     * const bookTagWithIdOnly = await prisma.bookTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookTagCreateManyAndReturnArgs>(args?: SelectSubset<T, BookTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookTag.
     * @param {BookTagDeleteArgs} args - Arguments to delete one BookTag.
     * @example
     * // Delete one BookTag
     * const BookTag = await prisma.bookTag.delete({
     *   where: {
     *     // ... filter to delete one BookTag
     *   }
     * })
     * 
     */
    delete<T extends BookTagDeleteArgs>(args: SelectSubset<T, BookTagDeleteArgs<ExtArgs>>): Prisma__BookTagClient<$Result.GetResult<Prisma.$BookTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookTag.
     * @param {BookTagUpdateArgs} args - Arguments to update one BookTag.
     * @example
     * // Update one BookTag
     * const bookTag = await prisma.bookTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookTagUpdateArgs>(args: SelectSubset<T, BookTagUpdateArgs<ExtArgs>>): Prisma__BookTagClient<$Result.GetResult<Prisma.$BookTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookTags.
     * @param {BookTagDeleteManyArgs} args - Arguments to filter BookTags to delete.
     * @example
     * // Delete a few BookTags
     * const { count } = await prisma.bookTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookTagDeleteManyArgs>(args?: SelectSubset<T, BookTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookTags
     * const bookTag = await prisma.bookTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookTagUpdateManyArgs>(args: SelectSubset<T, BookTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookTags and returns the data updated in the database.
     * @param {BookTagUpdateManyAndReturnArgs} args - Arguments to update many BookTags.
     * @example
     * // Update many BookTags
     * const bookTag = await prisma.bookTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookTags and only return the `id`
     * const bookTagWithIdOnly = await prisma.bookTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookTagUpdateManyAndReturnArgs>(args: SelectSubset<T, BookTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookTag.
     * @param {BookTagUpsertArgs} args - Arguments to update or create a BookTag.
     * @example
     * // Update or create a BookTag
     * const bookTag = await prisma.bookTag.upsert({
     *   create: {
     *     // ... data to create a BookTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookTag we want to update
     *   }
     * })
     */
    upsert<T extends BookTagUpsertArgs>(args: SelectSubset<T, BookTagUpsertArgs<ExtArgs>>): Prisma__BookTagClient<$Result.GetResult<Prisma.$BookTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookTagCountArgs} args - Arguments to filter BookTags to count.
     * @example
     * // Count the number of BookTags
     * const count = await prisma.bookTag.count({
     *   where: {
     *     // ... the filter for the BookTags we want to count
     *   }
     * })
    **/
    count<T extends BookTagCountArgs>(
      args?: Subset<T, BookTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookTagAggregateArgs>(args: Subset<T, BookTagAggregateArgs>): Prisma.PrismaPromise<GetBookTagAggregateType<T>>

    /**
     * Group by BookTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookTagGroupByArgs['orderBy'] }
        : { orderBy?: BookTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookTag model
   */
  readonly fields: BookTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookVersion<T extends BookVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookVersionDefaultArgs<ExtArgs>>): Prisma__BookVersionClient<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookTag model
   */
  interface BookTagFieldRefs {
    readonly id: FieldRef<"BookTag", 'String'>
    readonly bookVersionId: FieldRef<"BookTag", 'String'>
    readonly tagId: FieldRef<"BookTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BookTag findUnique
   */
  export type BookTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookTag
     */
    select?: BookTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookTag
     */
    omit?: BookTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookTagInclude<ExtArgs> | null
    /**
     * Filter, which BookTag to fetch.
     */
    where: BookTagWhereUniqueInput
  }

  /**
   * BookTag findUniqueOrThrow
   */
  export type BookTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookTag
     */
    select?: BookTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookTag
     */
    omit?: BookTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookTagInclude<ExtArgs> | null
    /**
     * Filter, which BookTag to fetch.
     */
    where: BookTagWhereUniqueInput
  }

  /**
   * BookTag findFirst
   */
  export type BookTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookTag
     */
    select?: BookTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookTag
     */
    omit?: BookTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookTagInclude<ExtArgs> | null
    /**
     * Filter, which BookTag to fetch.
     */
    where?: BookTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookTags to fetch.
     */
    orderBy?: BookTagOrderByWithRelationInput | BookTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookTags.
     */
    cursor?: BookTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookTags.
     */
    distinct?: BookTagScalarFieldEnum | BookTagScalarFieldEnum[]
  }

  /**
   * BookTag findFirstOrThrow
   */
  export type BookTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookTag
     */
    select?: BookTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookTag
     */
    omit?: BookTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookTagInclude<ExtArgs> | null
    /**
     * Filter, which BookTag to fetch.
     */
    where?: BookTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookTags to fetch.
     */
    orderBy?: BookTagOrderByWithRelationInput | BookTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookTags.
     */
    cursor?: BookTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookTags.
     */
    distinct?: BookTagScalarFieldEnum | BookTagScalarFieldEnum[]
  }

  /**
   * BookTag findMany
   */
  export type BookTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookTag
     */
    select?: BookTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookTag
     */
    omit?: BookTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookTagInclude<ExtArgs> | null
    /**
     * Filter, which BookTags to fetch.
     */
    where?: BookTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookTags to fetch.
     */
    orderBy?: BookTagOrderByWithRelationInput | BookTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookTags.
     */
    cursor?: BookTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookTags.
     */
    skip?: number
    distinct?: BookTagScalarFieldEnum | BookTagScalarFieldEnum[]
  }

  /**
   * BookTag create
   */
  export type BookTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookTag
     */
    select?: BookTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookTag
     */
    omit?: BookTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookTagInclude<ExtArgs> | null
    /**
     * The data needed to create a BookTag.
     */
    data: XOR<BookTagCreateInput, BookTagUncheckedCreateInput>
  }

  /**
   * BookTag createMany
   */
  export type BookTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookTags.
     */
    data: BookTagCreateManyInput | BookTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookTag createManyAndReturn
   */
  export type BookTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookTag
     */
    select?: BookTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookTag
     */
    omit?: BookTagOmit<ExtArgs> | null
    /**
     * The data used to create many BookTags.
     */
    data: BookTagCreateManyInput | BookTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookTag update
   */
  export type BookTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookTag
     */
    select?: BookTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookTag
     */
    omit?: BookTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookTagInclude<ExtArgs> | null
    /**
     * The data needed to update a BookTag.
     */
    data: XOR<BookTagUpdateInput, BookTagUncheckedUpdateInput>
    /**
     * Choose, which BookTag to update.
     */
    where: BookTagWhereUniqueInput
  }

  /**
   * BookTag updateMany
   */
  export type BookTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookTags.
     */
    data: XOR<BookTagUpdateManyMutationInput, BookTagUncheckedUpdateManyInput>
    /**
     * Filter which BookTags to update
     */
    where?: BookTagWhereInput
    /**
     * Limit how many BookTags to update.
     */
    limit?: number
  }

  /**
   * BookTag updateManyAndReturn
   */
  export type BookTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookTag
     */
    select?: BookTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookTag
     */
    omit?: BookTagOmit<ExtArgs> | null
    /**
     * The data used to update BookTags.
     */
    data: XOR<BookTagUpdateManyMutationInput, BookTagUncheckedUpdateManyInput>
    /**
     * Filter which BookTags to update
     */
    where?: BookTagWhereInput
    /**
     * Limit how many BookTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookTag upsert
   */
  export type BookTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookTag
     */
    select?: BookTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookTag
     */
    omit?: BookTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookTagInclude<ExtArgs> | null
    /**
     * The filter to search for the BookTag to update in case it exists.
     */
    where: BookTagWhereUniqueInput
    /**
     * In case the BookTag found by the `where` argument doesn't exist, create a new BookTag with this data.
     */
    create: XOR<BookTagCreateInput, BookTagUncheckedCreateInput>
    /**
     * In case the BookTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookTagUpdateInput, BookTagUncheckedUpdateInput>
  }

  /**
   * BookTag delete
   */
  export type BookTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookTag
     */
    select?: BookTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookTag
     */
    omit?: BookTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookTagInclude<ExtArgs> | null
    /**
     * Filter which BookTag to delete.
     */
    where: BookTagWhereUniqueInput
  }

  /**
   * BookTag deleteMany
   */
  export type BookTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookTags to delete
     */
    where?: BookTagWhereInput
    /**
     * Limit how many BookTags to delete.
     */
    limit?: number
  }

  /**
   * BookTag without action
   */
  export type BookTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookTag
     */
    select?: BookTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookTag
     */
    omit?: BookTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookTagInclude<ExtArgs> | null
  }


  /**
   * Model ViewStat
   */

  export type AggregateViewStat = {
    _count: ViewStatCountAggregateOutputType | null
    _min: ViewStatMinAggregateOutputType | null
    _max: ViewStatMaxAggregateOutputType | null
  }

  export type ViewStatMinAggregateOutputType = {
    id: string | null
    bookVersionId: string | null
    userId: string | null
    source: $Enums.ViewSource | null
    timestamp: Date | null
  }

  export type ViewStatMaxAggregateOutputType = {
    id: string | null
    bookVersionId: string | null
    userId: string | null
    source: $Enums.ViewSource | null
    timestamp: Date | null
  }

  export type ViewStatCountAggregateOutputType = {
    id: number
    bookVersionId: number
    userId: number
    source: number
    timestamp: number
    _all: number
  }


  export type ViewStatMinAggregateInputType = {
    id?: true
    bookVersionId?: true
    userId?: true
    source?: true
    timestamp?: true
  }

  export type ViewStatMaxAggregateInputType = {
    id?: true
    bookVersionId?: true
    userId?: true
    source?: true
    timestamp?: true
  }

  export type ViewStatCountAggregateInputType = {
    id?: true
    bookVersionId?: true
    userId?: true
    source?: true
    timestamp?: true
    _all?: true
  }

  export type ViewStatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewStat to aggregate.
     */
    where?: ViewStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewStats to fetch.
     */
    orderBy?: ViewStatOrderByWithRelationInput | ViewStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViewStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViewStats
    **/
    _count?: true | ViewStatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViewStatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViewStatMaxAggregateInputType
  }

  export type GetViewStatAggregateType<T extends ViewStatAggregateArgs> = {
        [P in keyof T & keyof AggregateViewStat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViewStat[P]>
      : GetScalarType<T[P], AggregateViewStat[P]>
  }




  export type ViewStatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewStatWhereInput
    orderBy?: ViewStatOrderByWithAggregationInput | ViewStatOrderByWithAggregationInput[]
    by: ViewStatScalarFieldEnum[] | ViewStatScalarFieldEnum
    having?: ViewStatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViewStatCountAggregateInputType | true
    _min?: ViewStatMinAggregateInputType
    _max?: ViewStatMaxAggregateInputType
  }

  export type ViewStatGroupByOutputType = {
    id: string
    bookVersionId: string
    userId: string | null
    source: $Enums.ViewSource
    timestamp: Date
    _count: ViewStatCountAggregateOutputType | null
    _min: ViewStatMinAggregateOutputType | null
    _max: ViewStatMaxAggregateOutputType | null
  }

  type GetViewStatGroupByPayload<T extends ViewStatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViewStatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViewStatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViewStatGroupByOutputType[P]>
            : GetScalarType<T[P], ViewStatGroupByOutputType[P]>
        }
      >
    >


  export type ViewStatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookVersionId?: boolean
    userId?: boolean
    source?: boolean
    timestamp?: boolean
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    user?: boolean | ViewStat$userArgs<ExtArgs>
  }, ExtArgs["result"]["viewStat"]>

  export type ViewStatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookVersionId?: boolean
    userId?: boolean
    source?: boolean
    timestamp?: boolean
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    user?: boolean | ViewStat$userArgs<ExtArgs>
  }, ExtArgs["result"]["viewStat"]>

  export type ViewStatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookVersionId?: boolean
    userId?: boolean
    source?: boolean
    timestamp?: boolean
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    user?: boolean | ViewStat$userArgs<ExtArgs>
  }, ExtArgs["result"]["viewStat"]>

  export type ViewStatSelectScalar = {
    id?: boolean
    bookVersionId?: boolean
    userId?: boolean
    source?: boolean
    timestamp?: boolean
  }

  export type ViewStatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookVersionId" | "userId" | "source" | "timestamp", ExtArgs["result"]["viewStat"]>
  export type ViewStatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    user?: boolean | ViewStat$userArgs<ExtArgs>
  }
  export type ViewStatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    user?: boolean | ViewStat$userArgs<ExtArgs>
  }
  export type ViewStatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
    user?: boolean | ViewStat$userArgs<ExtArgs>
  }

  export type $ViewStatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViewStat"
    objects: {
      bookVersion: Prisma.$BookVersionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookVersionId: string
      userId: string | null
      source: $Enums.ViewSource
      timestamp: Date
    }, ExtArgs["result"]["viewStat"]>
    composites: {}
  }

  type ViewStatGetPayload<S extends boolean | null | undefined | ViewStatDefaultArgs> = $Result.GetResult<Prisma.$ViewStatPayload, S>

  type ViewStatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ViewStatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ViewStatCountAggregateInputType | true
    }

  export interface ViewStatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViewStat'], meta: { name: 'ViewStat' } }
    /**
     * Find zero or one ViewStat that matches the filter.
     * @param {ViewStatFindUniqueArgs} args - Arguments to find a ViewStat
     * @example
     * // Get one ViewStat
     * const viewStat = await prisma.viewStat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViewStatFindUniqueArgs>(args: SelectSubset<T, ViewStatFindUniqueArgs<ExtArgs>>): Prisma__ViewStatClient<$Result.GetResult<Prisma.$ViewStatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ViewStat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ViewStatFindUniqueOrThrowArgs} args - Arguments to find a ViewStat
     * @example
     * // Get one ViewStat
     * const viewStat = await prisma.viewStat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViewStatFindUniqueOrThrowArgs>(args: SelectSubset<T, ViewStatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViewStatClient<$Result.GetResult<Prisma.$ViewStatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViewStat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewStatFindFirstArgs} args - Arguments to find a ViewStat
     * @example
     * // Get one ViewStat
     * const viewStat = await prisma.viewStat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViewStatFindFirstArgs>(args?: SelectSubset<T, ViewStatFindFirstArgs<ExtArgs>>): Prisma__ViewStatClient<$Result.GetResult<Prisma.$ViewStatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViewStat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewStatFindFirstOrThrowArgs} args - Arguments to find a ViewStat
     * @example
     * // Get one ViewStat
     * const viewStat = await prisma.viewStat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViewStatFindFirstOrThrowArgs>(args?: SelectSubset<T, ViewStatFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViewStatClient<$Result.GetResult<Prisma.$ViewStatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ViewStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewStatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViewStats
     * const viewStats = await prisma.viewStat.findMany()
     * 
     * // Get first 10 ViewStats
     * const viewStats = await prisma.viewStat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viewStatWithIdOnly = await prisma.viewStat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ViewStatFindManyArgs>(args?: SelectSubset<T, ViewStatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewStatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ViewStat.
     * @param {ViewStatCreateArgs} args - Arguments to create a ViewStat.
     * @example
     * // Create one ViewStat
     * const ViewStat = await prisma.viewStat.create({
     *   data: {
     *     // ... data to create a ViewStat
     *   }
     * })
     * 
     */
    create<T extends ViewStatCreateArgs>(args: SelectSubset<T, ViewStatCreateArgs<ExtArgs>>): Prisma__ViewStatClient<$Result.GetResult<Prisma.$ViewStatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ViewStats.
     * @param {ViewStatCreateManyArgs} args - Arguments to create many ViewStats.
     * @example
     * // Create many ViewStats
     * const viewStat = await prisma.viewStat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViewStatCreateManyArgs>(args?: SelectSubset<T, ViewStatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ViewStats and returns the data saved in the database.
     * @param {ViewStatCreateManyAndReturnArgs} args - Arguments to create many ViewStats.
     * @example
     * // Create many ViewStats
     * const viewStat = await prisma.viewStat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ViewStats and only return the `id`
     * const viewStatWithIdOnly = await prisma.viewStat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViewStatCreateManyAndReturnArgs>(args?: SelectSubset<T, ViewStatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewStatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ViewStat.
     * @param {ViewStatDeleteArgs} args - Arguments to delete one ViewStat.
     * @example
     * // Delete one ViewStat
     * const ViewStat = await prisma.viewStat.delete({
     *   where: {
     *     // ... filter to delete one ViewStat
     *   }
     * })
     * 
     */
    delete<T extends ViewStatDeleteArgs>(args: SelectSubset<T, ViewStatDeleteArgs<ExtArgs>>): Prisma__ViewStatClient<$Result.GetResult<Prisma.$ViewStatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ViewStat.
     * @param {ViewStatUpdateArgs} args - Arguments to update one ViewStat.
     * @example
     * // Update one ViewStat
     * const viewStat = await prisma.viewStat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViewStatUpdateArgs>(args: SelectSubset<T, ViewStatUpdateArgs<ExtArgs>>): Prisma__ViewStatClient<$Result.GetResult<Prisma.$ViewStatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ViewStats.
     * @param {ViewStatDeleteManyArgs} args - Arguments to filter ViewStats to delete.
     * @example
     * // Delete a few ViewStats
     * const { count } = await prisma.viewStat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViewStatDeleteManyArgs>(args?: SelectSubset<T, ViewStatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViewStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewStatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViewStats
     * const viewStat = await prisma.viewStat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViewStatUpdateManyArgs>(args: SelectSubset<T, ViewStatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViewStats and returns the data updated in the database.
     * @param {ViewStatUpdateManyAndReturnArgs} args - Arguments to update many ViewStats.
     * @example
     * // Update many ViewStats
     * const viewStat = await prisma.viewStat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ViewStats and only return the `id`
     * const viewStatWithIdOnly = await prisma.viewStat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ViewStatUpdateManyAndReturnArgs>(args: SelectSubset<T, ViewStatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewStatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ViewStat.
     * @param {ViewStatUpsertArgs} args - Arguments to update or create a ViewStat.
     * @example
     * // Update or create a ViewStat
     * const viewStat = await prisma.viewStat.upsert({
     *   create: {
     *     // ... data to create a ViewStat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViewStat we want to update
     *   }
     * })
     */
    upsert<T extends ViewStatUpsertArgs>(args: SelectSubset<T, ViewStatUpsertArgs<ExtArgs>>): Prisma__ViewStatClient<$Result.GetResult<Prisma.$ViewStatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ViewStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewStatCountArgs} args - Arguments to filter ViewStats to count.
     * @example
     * // Count the number of ViewStats
     * const count = await prisma.viewStat.count({
     *   where: {
     *     // ... the filter for the ViewStats we want to count
     *   }
     * })
    **/
    count<T extends ViewStatCountArgs>(
      args?: Subset<T, ViewStatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViewStatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViewStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewStatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViewStatAggregateArgs>(args: Subset<T, ViewStatAggregateArgs>): Prisma.PrismaPromise<GetViewStatAggregateType<T>>

    /**
     * Group by ViewStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewStatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViewStatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViewStatGroupByArgs['orderBy'] }
        : { orderBy?: ViewStatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViewStatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViewStatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViewStat model
   */
  readonly fields: ViewStatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViewStat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViewStatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookVersion<T extends BookVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookVersionDefaultArgs<ExtArgs>>): Prisma__BookVersionClient<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends ViewStat$userArgs<ExtArgs> = {}>(args?: Subset<T, ViewStat$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ViewStat model
   */
  interface ViewStatFieldRefs {
    readonly id: FieldRef<"ViewStat", 'String'>
    readonly bookVersionId: FieldRef<"ViewStat", 'String'>
    readonly userId: FieldRef<"ViewStat", 'String'>
    readonly source: FieldRef<"ViewStat", 'ViewSource'>
    readonly timestamp: FieldRef<"ViewStat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ViewStat findUnique
   */
  export type ViewStatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewStat
     */
    select?: ViewStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewStat
     */
    omit?: ViewStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewStatInclude<ExtArgs> | null
    /**
     * Filter, which ViewStat to fetch.
     */
    where: ViewStatWhereUniqueInput
  }

  /**
   * ViewStat findUniqueOrThrow
   */
  export type ViewStatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewStat
     */
    select?: ViewStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewStat
     */
    omit?: ViewStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewStatInclude<ExtArgs> | null
    /**
     * Filter, which ViewStat to fetch.
     */
    where: ViewStatWhereUniqueInput
  }

  /**
   * ViewStat findFirst
   */
  export type ViewStatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewStat
     */
    select?: ViewStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewStat
     */
    omit?: ViewStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewStatInclude<ExtArgs> | null
    /**
     * Filter, which ViewStat to fetch.
     */
    where?: ViewStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewStats to fetch.
     */
    orderBy?: ViewStatOrderByWithRelationInput | ViewStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewStats.
     */
    cursor?: ViewStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewStats.
     */
    distinct?: ViewStatScalarFieldEnum | ViewStatScalarFieldEnum[]
  }

  /**
   * ViewStat findFirstOrThrow
   */
  export type ViewStatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewStat
     */
    select?: ViewStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewStat
     */
    omit?: ViewStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewStatInclude<ExtArgs> | null
    /**
     * Filter, which ViewStat to fetch.
     */
    where?: ViewStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewStats to fetch.
     */
    orderBy?: ViewStatOrderByWithRelationInput | ViewStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewStats.
     */
    cursor?: ViewStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewStats.
     */
    distinct?: ViewStatScalarFieldEnum | ViewStatScalarFieldEnum[]
  }

  /**
   * ViewStat findMany
   */
  export type ViewStatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewStat
     */
    select?: ViewStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewStat
     */
    omit?: ViewStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewStatInclude<ExtArgs> | null
    /**
     * Filter, which ViewStats to fetch.
     */
    where?: ViewStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewStats to fetch.
     */
    orderBy?: ViewStatOrderByWithRelationInput | ViewStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViewStats.
     */
    cursor?: ViewStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewStats.
     */
    skip?: number
    distinct?: ViewStatScalarFieldEnum | ViewStatScalarFieldEnum[]
  }

  /**
   * ViewStat create
   */
  export type ViewStatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewStat
     */
    select?: ViewStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewStat
     */
    omit?: ViewStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewStatInclude<ExtArgs> | null
    /**
     * The data needed to create a ViewStat.
     */
    data: XOR<ViewStatCreateInput, ViewStatUncheckedCreateInput>
  }

  /**
   * ViewStat createMany
   */
  export type ViewStatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViewStats.
     */
    data: ViewStatCreateManyInput | ViewStatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViewStat createManyAndReturn
   */
  export type ViewStatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewStat
     */
    select?: ViewStatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViewStat
     */
    omit?: ViewStatOmit<ExtArgs> | null
    /**
     * The data used to create many ViewStats.
     */
    data: ViewStatCreateManyInput | ViewStatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewStatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViewStat update
   */
  export type ViewStatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewStat
     */
    select?: ViewStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewStat
     */
    omit?: ViewStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewStatInclude<ExtArgs> | null
    /**
     * The data needed to update a ViewStat.
     */
    data: XOR<ViewStatUpdateInput, ViewStatUncheckedUpdateInput>
    /**
     * Choose, which ViewStat to update.
     */
    where: ViewStatWhereUniqueInput
  }

  /**
   * ViewStat updateMany
   */
  export type ViewStatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViewStats.
     */
    data: XOR<ViewStatUpdateManyMutationInput, ViewStatUncheckedUpdateManyInput>
    /**
     * Filter which ViewStats to update
     */
    where?: ViewStatWhereInput
    /**
     * Limit how many ViewStats to update.
     */
    limit?: number
  }

  /**
   * ViewStat updateManyAndReturn
   */
  export type ViewStatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewStat
     */
    select?: ViewStatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViewStat
     */
    omit?: ViewStatOmit<ExtArgs> | null
    /**
     * The data used to update ViewStats.
     */
    data: XOR<ViewStatUpdateManyMutationInput, ViewStatUncheckedUpdateManyInput>
    /**
     * Filter which ViewStats to update
     */
    where?: ViewStatWhereInput
    /**
     * Limit how many ViewStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewStatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViewStat upsert
   */
  export type ViewStatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewStat
     */
    select?: ViewStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewStat
     */
    omit?: ViewStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewStatInclude<ExtArgs> | null
    /**
     * The filter to search for the ViewStat to update in case it exists.
     */
    where: ViewStatWhereUniqueInput
    /**
     * In case the ViewStat found by the `where` argument doesn't exist, create a new ViewStat with this data.
     */
    create: XOR<ViewStatCreateInput, ViewStatUncheckedCreateInput>
    /**
     * In case the ViewStat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViewStatUpdateInput, ViewStatUncheckedUpdateInput>
  }

  /**
   * ViewStat delete
   */
  export type ViewStatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewStat
     */
    select?: ViewStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewStat
     */
    omit?: ViewStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewStatInclude<ExtArgs> | null
    /**
     * Filter which ViewStat to delete.
     */
    where: ViewStatWhereUniqueInput
  }

  /**
   * ViewStat deleteMany
   */
  export type ViewStatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewStats to delete
     */
    where?: ViewStatWhereInput
    /**
     * Limit how many ViewStats to delete.
     */
    limit?: number
  }

  /**
   * ViewStat.user
   */
  export type ViewStat$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ViewStat without action
   */
  export type ViewStatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewStat
     */
    select?: ViewStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewStat
     */
    omit?: ViewStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewStatInclude<ExtArgs> | null
  }


  /**
   * Model ReadingProgress
   */

  export type AggregateReadingProgress = {
    _count: ReadingProgressCountAggregateOutputType | null
    _avg: ReadingProgressAvgAggregateOutputType | null
    _sum: ReadingProgressSumAggregateOutputType | null
    _min: ReadingProgressMinAggregateOutputType | null
    _max: ReadingProgressMaxAggregateOutputType | null
  }

  export type ReadingProgressAvgAggregateOutputType = {
    chapterNumber: number | null
    audioChapterNumber: number | null
    position: number | null
  }

  export type ReadingProgressSumAggregateOutputType = {
    chapterNumber: number | null
    audioChapterNumber: number | null
    position: number | null
  }

  export type ReadingProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    bookVersionId: string | null
    chapterNumber: number | null
    audioChapterNumber: number | null
    position: number | null
    updatedAt: Date | null
  }

  export type ReadingProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    bookVersionId: string | null
    chapterNumber: number | null
    audioChapterNumber: number | null
    position: number | null
    updatedAt: Date | null
  }

  export type ReadingProgressCountAggregateOutputType = {
    id: number
    userId: number
    bookVersionId: number
    chapterNumber: number
    audioChapterNumber: number
    position: number
    updatedAt: number
    _all: number
  }


  export type ReadingProgressAvgAggregateInputType = {
    chapterNumber?: true
    audioChapterNumber?: true
    position?: true
  }

  export type ReadingProgressSumAggregateInputType = {
    chapterNumber?: true
    audioChapterNumber?: true
    position?: true
  }

  export type ReadingProgressMinAggregateInputType = {
    id?: true
    userId?: true
    bookVersionId?: true
    chapterNumber?: true
    audioChapterNumber?: true
    position?: true
    updatedAt?: true
  }

  export type ReadingProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    bookVersionId?: true
    chapterNumber?: true
    audioChapterNumber?: true
    position?: true
    updatedAt?: true
  }

  export type ReadingProgressCountAggregateInputType = {
    id?: true
    userId?: true
    bookVersionId?: true
    chapterNumber?: true
    audioChapterNumber?: true
    position?: true
    updatedAt?: true
    _all?: true
  }

  export type ReadingProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReadingProgress to aggregate.
     */
    where?: ReadingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReadingProgresses to fetch.
     */
    orderBy?: ReadingProgressOrderByWithRelationInput | ReadingProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReadingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReadingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReadingProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReadingProgresses
    **/
    _count?: true | ReadingProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReadingProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReadingProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReadingProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReadingProgressMaxAggregateInputType
  }

  export type GetReadingProgressAggregateType<T extends ReadingProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateReadingProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReadingProgress[P]>
      : GetScalarType<T[P], AggregateReadingProgress[P]>
  }




  export type ReadingProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReadingProgressWhereInput
    orderBy?: ReadingProgressOrderByWithAggregationInput | ReadingProgressOrderByWithAggregationInput[]
    by: ReadingProgressScalarFieldEnum[] | ReadingProgressScalarFieldEnum
    having?: ReadingProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReadingProgressCountAggregateInputType | true
    _avg?: ReadingProgressAvgAggregateInputType
    _sum?: ReadingProgressSumAggregateInputType
    _min?: ReadingProgressMinAggregateInputType
    _max?: ReadingProgressMaxAggregateInputType
  }

  export type ReadingProgressGroupByOutputType = {
    id: string
    userId: string
    bookVersionId: string
    chapterNumber: number | null
    audioChapterNumber: number | null
    position: number
    updatedAt: Date
    _count: ReadingProgressCountAggregateOutputType | null
    _avg: ReadingProgressAvgAggregateOutputType | null
    _sum: ReadingProgressSumAggregateOutputType | null
    _min: ReadingProgressMinAggregateOutputType | null
    _max: ReadingProgressMaxAggregateOutputType | null
  }

  type GetReadingProgressGroupByPayload<T extends ReadingProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReadingProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReadingProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReadingProgressGroupByOutputType[P]>
            : GetScalarType<T[P], ReadingProgressGroupByOutputType[P]>
        }
      >
    >


  export type ReadingProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookVersionId?: boolean
    chapterNumber?: boolean
    audioChapterNumber?: boolean
    position?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["readingProgress"]>

  export type ReadingProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookVersionId?: boolean
    chapterNumber?: boolean
    audioChapterNumber?: boolean
    position?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["readingProgress"]>

  export type ReadingProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookVersionId?: boolean
    chapterNumber?: boolean
    audioChapterNumber?: boolean
    position?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["readingProgress"]>

  export type ReadingProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    bookVersionId?: boolean
    chapterNumber?: boolean
    audioChapterNumber?: boolean
    position?: boolean
    updatedAt?: boolean
  }

  export type ReadingProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "bookVersionId" | "chapterNumber" | "audioChapterNumber" | "position" | "updatedAt", ExtArgs["result"]["readingProgress"]>
  export type ReadingProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }
  export type ReadingProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }
  export type ReadingProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookVersion?: boolean | BookVersionDefaultArgs<ExtArgs>
  }

  export type $ReadingProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReadingProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bookVersion: Prisma.$BookVersionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      bookVersionId: string
      chapterNumber: number | null
      audioChapterNumber: number | null
      position: number
      updatedAt: Date
    }, ExtArgs["result"]["readingProgress"]>
    composites: {}
  }

  type ReadingProgressGetPayload<S extends boolean | null | undefined | ReadingProgressDefaultArgs> = $Result.GetResult<Prisma.$ReadingProgressPayload, S>

  type ReadingProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReadingProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReadingProgressCountAggregateInputType | true
    }

  export interface ReadingProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReadingProgress'], meta: { name: 'ReadingProgress' } }
    /**
     * Find zero or one ReadingProgress that matches the filter.
     * @param {ReadingProgressFindUniqueArgs} args - Arguments to find a ReadingProgress
     * @example
     * // Get one ReadingProgress
     * const readingProgress = await prisma.readingProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReadingProgressFindUniqueArgs>(args: SelectSubset<T, ReadingProgressFindUniqueArgs<ExtArgs>>): Prisma__ReadingProgressClient<$Result.GetResult<Prisma.$ReadingProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReadingProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReadingProgressFindUniqueOrThrowArgs} args - Arguments to find a ReadingProgress
     * @example
     * // Get one ReadingProgress
     * const readingProgress = await prisma.readingProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReadingProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, ReadingProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReadingProgressClient<$Result.GetResult<Prisma.$ReadingProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReadingProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingProgressFindFirstArgs} args - Arguments to find a ReadingProgress
     * @example
     * // Get one ReadingProgress
     * const readingProgress = await prisma.readingProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReadingProgressFindFirstArgs>(args?: SelectSubset<T, ReadingProgressFindFirstArgs<ExtArgs>>): Prisma__ReadingProgressClient<$Result.GetResult<Prisma.$ReadingProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReadingProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingProgressFindFirstOrThrowArgs} args - Arguments to find a ReadingProgress
     * @example
     * // Get one ReadingProgress
     * const readingProgress = await prisma.readingProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReadingProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, ReadingProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReadingProgressClient<$Result.GetResult<Prisma.$ReadingProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReadingProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReadingProgresses
     * const readingProgresses = await prisma.readingProgress.findMany()
     * 
     * // Get first 10 ReadingProgresses
     * const readingProgresses = await prisma.readingProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const readingProgressWithIdOnly = await prisma.readingProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReadingProgressFindManyArgs>(args?: SelectSubset<T, ReadingProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadingProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReadingProgress.
     * @param {ReadingProgressCreateArgs} args - Arguments to create a ReadingProgress.
     * @example
     * // Create one ReadingProgress
     * const ReadingProgress = await prisma.readingProgress.create({
     *   data: {
     *     // ... data to create a ReadingProgress
     *   }
     * })
     * 
     */
    create<T extends ReadingProgressCreateArgs>(args: SelectSubset<T, ReadingProgressCreateArgs<ExtArgs>>): Prisma__ReadingProgressClient<$Result.GetResult<Prisma.$ReadingProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReadingProgresses.
     * @param {ReadingProgressCreateManyArgs} args - Arguments to create many ReadingProgresses.
     * @example
     * // Create many ReadingProgresses
     * const readingProgress = await prisma.readingProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReadingProgressCreateManyArgs>(args?: SelectSubset<T, ReadingProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReadingProgresses and returns the data saved in the database.
     * @param {ReadingProgressCreateManyAndReturnArgs} args - Arguments to create many ReadingProgresses.
     * @example
     * // Create many ReadingProgresses
     * const readingProgress = await prisma.readingProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReadingProgresses and only return the `id`
     * const readingProgressWithIdOnly = await prisma.readingProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReadingProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, ReadingProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadingProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReadingProgress.
     * @param {ReadingProgressDeleteArgs} args - Arguments to delete one ReadingProgress.
     * @example
     * // Delete one ReadingProgress
     * const ReadingProgress = await prisma.readingProgress.delete({
     *   where: {
     *     // ... filter to delete one ReadingProgress
     *   }
     * })
     * 
     */
    delete<T extends ReadingProgressDeleteArgs>(args: SelectSubset<T, ReadingProgressDeleteArgs<ExtArgs>>): Prisma__ReadingProgressClient<$Result.GetResult<Prisma.$ReadingProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReadingProgress.
     * @param {ReadingProgressUpdateArgs} args - Arguments to update one ReadingProgress.
     * @example
     * // Update one ReadingProgress
     * const readingProgress = await prisma.readingProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReadingProgressUpdateArgs>(args: SelectSubset<T, ReadingProgressUpdateArgs<ExtArgs>>): Prisma__ReadingProgressClient<$Result.GetResult<Prisma.$ReadingProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReadingProgresses.
     * @param {ReadingProgressDeleteManyArgs} args - Arguments to filter ReadingProgresses to delete.
     * @example
     * // Delete a few ReadingProgresses
     * const { count } = await prisma.readingProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReadingProgressDeleteManyArgs>(args?: SelectSubset<T, ReadingProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReadingProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReadingProgresses
     * const readingProgress = await prisma.readingProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReadingProgressUpdateManyArgs>(args: SelectSubset<T, ReadingProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReadingProgresses and returns the data updated in the database.
     * @param {ReadingProgressUpdateManyAndReturnArgs} args - Arguments to update many ReadingProgresses.
     * @example
     * // Update many ReadingProgresses
     * const readingProgress = await prisma.readingProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReadingProgresses and only return the `id`
     * const readingProgressWithIdOnly = await prisma.readingProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReadingProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, ReadingProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadingProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReadingProgress.
     * @param {ReadingProgressUpsertArgs} args - Arguments to update or create a ReadingProgress.
     * @example
     * // Update or create a ReadingProgress
     * const readingProgress = await prisma.readingProgress.upsert({
     *   create: {
     *     // ... data to create a ReadingProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReadingProgress we want to update
     *   }
     * })
     */
    upsert<T extends ReadingProgressUpsertArgs>(args: SelectSubset<T, ReadingProgressUpsertArgs<ExtArgs>>): Prisma__ReadingProgressClient<$Result.GetResult<Prisma.$ReadingProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReadingProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingProgressCountArgs} args - Arguments to filter ReadingProgresses to count.
     * @example
     * // Count the number of ReadingProgresses
     * const count = await prisma.readingProgress.count({
     *   where: {
     *     // ... the filter for the ReadingProgresses we want to count
     *   }
     * })
    **/
    count<T extends ReadingProgressCountArgs>(
      args?: Subset<T, ReadingProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReadingProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReadingProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReadingProgressAggregateArgs>(args: Subset<T, ReadingProgressAggregateArgs>): Prisma.PrismaPromise<GetReadingProgressAggregateType<T>>

    /**
     * Group by ReadingProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReadingProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReadingProgressGroupByArgs['orderBy'] }
        : { orderBy?: ReadingProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReadingProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReadingProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReadingProgress model
   */
  readonly fields: ReadingProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReadingProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReadingProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookVersion<T extends BookVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookVersionDefaultArgs<ExtArgs>>): Prisma__BookVersionClient<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReadingProgress model
   */
  interface ReadingProgressFieldRefs {
    readonly id: FieldRef<"ReadingProgress", 'String'>
    readonly userId: FieldRef<"ReadingProgress", 'String'>
    readonly bookVersionId: FieldRef<"ReadingProgress", 'String'>
    readonly chapterNumber: FieldRef<"ReadingProgress", 'Int'>
    readonly audioChapterNumber: FieldRef<"ReadingProgress", 'Int'>
    readonly position: FieldRef<"ReadingProgress", 'Float'>
    readonly updatedAt: FieldRef<"ReadingProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReadingProgress findUnique
   */
  export type ReadingProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingProgress
     */
    select?: ReadingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadingProgress
     */
    omit?: ReadingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingProgressInclude<ExtArgs> | null
    /**
     * Filter, which ReadingProgress to fetch.
     */
    where: ReadingProgressWhereUniqueInput
  }

  /**
   * ReadingProgress findUniqueOrThrow
   */
  export type ReadingProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingProgress
     */
    select?: ReadingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadingProgress
     */
    omit?: ReadingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingProgressInclude<ExtArgs> | null
    /**
     * Filter, which ReadingProgress to fetch.
     */
    where: ReadingProgressWhereUniqueInput
  }

  /**
   * ReadingProgress findFirst
   */
  export type ReadingProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingProgress
     */
    select?: ReadingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadingProgress
     */
    omit?: ReadingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingProgressInclude<ExtArgs> | null
    /**
     * Filter, which ReadingProgress to fetch.
     */
    where?: ReadingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReadingProgresses to fetch.
     */
    orderBy?: ReadingProgressOrderByWithRelationInput | ReadingProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReadingProgresses.
     */
    cursor?: ReadingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReadingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReadingProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReadingProgresses.
     */
    distinct?: ReadingProgressScalarFieldEnum | ReadingProgressScalarFieldEnum[]
  }

  /**
   * ReadingProgress findFirstOrThrow
   */
  export type ReadingProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingProgress
     */
    select?: ReadingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadingProgress
     */
    omit?: ReadingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingProgressInclude<ExtArgs> | null
    /**
     * Filter, which ReadingProgress to fetch.
     */
    where?: ReadingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReadingProgresses to fetch.
     */
    orderBy?: ReadingProgressOrderByWithRelationInput | ReadingProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReadingProgresses.
     */
    cursor?: ReadingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReadingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReadingProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReadingProgresses.
     */
    distinct?: ReadingProgressScalarFieldEnum | ReadingProgressScalarFieldEnum[]
  }

  /**
   * ReadingProgress findMany
   */
  export type ReadingProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingProgress
     */
    select?: ReadingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadingProgress
     */
    omit?: ReadingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingProgressInclude<ExtArgs> | null
    /**
     * Filter, which ReadingProgresses to fetch.
     */
    where?: ReadingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReadingProgresses to fetch.
     */
    orderBy?: ReadingProgressOrderByWithRelationInput | ReadingProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReadingProgresses.
     */
    cursor?: ReadingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReadingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReadingProgresses.
     */
    skip?: number
    distinct?: ReadingProgressScalarFieldEnum | ReadingProgressScalarFieldEnum[]
  }

  /**
   * ReadingProgress create
   */
  export type ReadingProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingProgress
     */
    select?: ReadingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadingProgress
     */
    omit?: ReadingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a ReadingProgress.
     */
    data: XOR<ReadingProgressCreateInput, ReadingProgressUncheckedCreateInput>
  }

  /**
   * ReadingProgress createMany
   */
  export type ReadingProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReadingProgresses.
     */
    data: ReadingProgressCreateManyInput | ReadingProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReadingProgress createManyAndReturn
   */
  export type ReadingProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingProgress
     */
    select?: ReadingProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReadingProgress
     */
    omit?: ReadingProgressOmit<ExtArgs> | null
    /**
     * The data used to create many ReadingProgresses.
     */
    data: ReadingProgressCreateManyInput | ReadingProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReadingProgress update
   */
  export type ReadingProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingProgress
     */
    select?: ReadingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadingProgress
     */
    omit?: ReadingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a ReadingProgress.
     */
    data: XOR<ReadingProgressUpdateInput, ReadingProgressUncheckedUpdateInput>
    /**
     * Choose, which ReadingProgress to update.
     */
    where: ReadingProgressWhereUniqueInput
  }

  /**
   * ReadingProgress updateMany
   */
  export type ReadingProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReadingProgresses.
     */
    data: XOR<ReadingProgressUpdateManyMutationInput, ReadingProgressUncheckedUpdateManyInput>
    /**
     * Filter which ReadingProgresses to update
     */
    where?: ReadingProgressWhereInput
    /**
     * Limit how many ReadingProgresses to update.
     */
    limit?: number
  }

  /**
   * ReadingProgress updateManyAndReturn
   */
  export type ReadingProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingProgress
     */
    select?: ReadingProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReadingProgress
     */
    omit?: ReadingProgressOmit<ExtArgs> | null
    /**
     * The data used to update ReadingProgresses.
     */
    data: XOR<ReadingProgressUpdateManyMutationInput, ReadingProgressUncheckedUpdateManyInput>
    /**
     * Filter which ReadingProgresses to update
     */
    where?: ReadingProgressWhereInput
    /**
     * Limit how many ReadingProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReadingProgress upsert
   */
  export type ReadingProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingProgress
     */
    select?: ReadingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadingProgress
     */
    omit?: ReadingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the ReadingProgress to update in case it exists.
     */
    where: ReadingProgressWhereUniqueInput
    /**
     * In case the ReadingProgress found by the `where` argument doesn't exist, create a new ReadingProgress with this data.
     */
    create: XOR<ReadingProgressCreateInput, ReadingProgressUncheckedCreateInput>
    /**
     * In case the ReadingProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReadingProgressUpdateInput, ReadingProgressUncheckedUpdateInput>
  }

  /**
   * ReadingProgress delete
   */
  export type ReadingProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingProgress
     */
    select?: ReadingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadingProgress
     */
    omit?: ReadingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingProgressInclude<ExtArgs> | null
    /**
     * Filter which ReadingProgress to delete.
     */
    where: ReadingProgressWhereUniqueInput
  }

  /**
   * ReadingProgress deleteMany
   */
  export type ReadingProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReadingProgresses to delete
     */
    where?: ReadingProgressWhereInput
    /**
     * Limit how many ReadingProgresses to delete.
     */
    limit?: number
  }

  /**
   * ReadingProgress without action
   */
  export type ReadingProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadingProgress
     */
    select?: ReadingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReadingProgress
     */
    omit?: ReadingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingProgressInclude<ExtArgs> | null
  }


  /**
   * Model Seo
   */

  export type AggregateSeo = {
    _count: SeoCountAggregateOutputType | null
    _avg: SeoAvgAggregateOutputType | null
    _sum: SeoSumAggregateOutputType | null
    _min: SeoMinAggregateOutputType | null
    _max: SeoMaxAggregateOutputType | null
  }

  export type SeoAvgAggregateOutputType = {
    id: number | null
  }

  export type SeoSumAggregateOutputType = {
    id: number | null
  }

  export type SeoMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    metaTitle: string | null
    metaDescription: string | null
    canonicalUrl: string | null
    robots: string | null
    ogTitle: string | null
    ogDescription: string | null
    ogType: string | null
    ogUrl: string | null
    ogImageUrl: string | null
    ogImageAlt: string | null
    twitterCard: string | null
    twitterSite: string | null
    twitterCreator: string | null
    eventName: string | null
    eventDescription: string | null
    eventStartDate: Date | null
    eventEndDate: Date | null
    eventUrl: string | null
    eventImageUrl: string | null
    eventLocationName: string | null
    eventLocationStreet: string | null
    eventLocationCity: string | null
    eventLocationRegion: string | null
    eventLocationPostal: string | null
    eventLocationCountry: string | null
  }

  export type SeoMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    metaTitle: string | null
    metaDescription: string | null
    canonicalUrl: string | null
    robots: string | null
    ogTitle: string | null
    ogDescription: string | null
    ogType: string | null
    ogUrl: string | null
    ogImageUrl: string | null
    ogImageAlt: string | null
    twitterCard: string | null
    twitterSite: string | null
    twitterCreator: string | null
    eventName: string | null
    eventDescription: string | null
    eventStartDate: Date | null
    eventEndDate: Date | null
    eventUrl: string | null
    eventImageUrl: string | null
    eventLocationName: string | null
    eventLocationStreet: string | null
    eventLocationCity: string | null
    eventLocationRegion: string | null
    eventLocationPostal: string | null
    eventLocationCountry: string | null
  }

  export type SeoCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    metaTitle: number
    metaDescription: number
    canonicalUrl: number
    robots: number
    ogTitle: number
    ogDescription: number
    ogType: number
    ogUrl: number
    ogImageUrl: number
    ogImageAlt: number
    twitterCard: number
    twitterSite: number
    twitterCreator: number
    eventName: number
    eventDescription: number
    eventStartDate: number
    eventEndDate: number
    eventUrl: number
    eventImageUrl: number
    eventLocationName: number
    eventLocationStreet: number
    eventLocationCity: number
    eventLocationRegion: number
    eventLocationPostal: number
    eventLocationCountry: number
    _all: number
  }


  export type SeoAvgAggregateInputType = {
    id?: true
  }

  export type SeoSumAggregateInputType = {
    id?: true
  }

  export type SeoMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    metaTitle?: true
    metaDescription?: true
    canonicalUrl?: true
    robots?: true
    ogTitle?: true
    ogDescription?: true
    ogType?: true
    ogUrl?: true
    ogImageUrl?: true
    ogImageAlt?: true
    twitterCard?: true
    twitterSite?: true
    twitterCreator?: true
    eventName?: true
    eventDescription?: true
    eventStartDate?: true
    eventEndDate?: true
    eventUrl?: true
    eventImageUrl?: true
    eventLocationName?: true
    eventLocationStreet?: true
    eventLocationCity?: true
    eventLocationRegion?: true
    eventLocationPostal?: true
    eventLocationCountry?: true
  }

  export type SeoMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    metaTitle?: true
    metaDescription?: true
    canonicalUrl?: true
    robots?: true
    ogTitle?: true
    ogDescription?: true
    ogType?: true
    ogUrl?: true
    ogImageUrl?: true
    ogImageAlt?: true
    twitterCard?: true
    twitterSite?: true
    twitterCreator?: true
    eventName?: true
    eventDescription?: true
    eventStartDate?: true
    eventEndDate?: true
    eventUrl?: true
    eventImageUrl?: true
    eventLocationName?: true
    eventLocationStreet?: true
    eventLocationCity?: true
    eventLocationRegion?: true
    eventLocationPostal?: true
    eventLocationCountry?: true
  }

  export type SeoCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    metaTitle?: true
    metaDescription?: true
    canonicalUrl?: true
    robots?: true
    ogTitle?: true
    ogDescription?: true
    ogType?: true
    ogUrl?: true
    ogImageUrl?: true
    ogImageAlt?: true
    twitterCard?: true
    twitterSite?: true
    twitterCreator?: true
    eventName?: true
    eventDescription?: true
    eventStartDate?: true
    eventEndDate?: true
    eventUrl?: true
    eventImageUrl?: true
    eventLocationName?: true
    eventLocationStreet?: true
    eventLocationCity?: true
    eventLocationRegion?: true
    eventLocationPostal?: true
    eventLocationCountry?: true
    _all?: true
  }

  export type SeoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seo to aggregate.
     */
    where?: SeoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seos to fetch.
     */
    orderBy?: SeoOrderByWithRelationInput | SeoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Seos
    **/
    _count?: true | SeoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeoMaxAggregateInputType
  }

  export type GetSeoAggregateType<T extends SeoAggregateArgs> = {
        [P in keyof T & keyof AggregateSeo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeo[P]>
      : GetScalarType<T[P], AggregateSeo[P]>
  }




  export type SeoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeoWhereInput
    orderBy?: SeoOrderByWithAggregationInput | SeoOrderByWithAggregationInput[]
    by: SeoScalarFieldEnum[] | SeoScalarFieldEnum
    having?: SeoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeoCountAggregateInputType | true
    _avg?: SeoAvgAggregateInputType
    _sum?: SeoSumAggregateInputType
    _min?: SeoMinAggregateInputType
    _max?: SeoMaxAggregateInputType
  }

  export type SeoGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    metaTitle: string | null
    metaDescription: string | null
    canonicalUrl: string | null
    robots: string | null
    ogTitle: string | null
    ogDescription: string | null
    ogType: string | null
    ogUrl: string | null
    ogImageUrl: string | null
    ogImageAlt: string | null
    twitterCard: string | null
    twitterSite: string | null
    twitterCreator: string | null
    eventName: string | null
    eventDescription: string | null
    eventStartDate: Date | null
    eventEndDate: Date | null
    eventUrl: string | null
    eventImageUrl: string | null
    eventLocationName: string | null
    eventLocationStreet: string | null
    eventLocationCity: string | null
    eventLocationRegion: string | null
    eventLocationPostal: string | null
    eventLocationCountry: string | null
    _count: SeoCountAggregateOutputType | null
    _avg: SeoAvgAggregateOutputType | null
    _sum: SeoSumAggregateOutputType | null
    _min: SeoMinAggregateOutputType | null
    _max: SeoMaxAggregateOutputType | null
  }

  type GetSeoGroupByPayload<T extends SeoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeoGroupByOutputType[P]>
            : GetScalarType<T[P], SeoGroupByOutputType[P]>
        }
      >
    >


  export type SeoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    canonicalUrl?: boolean
    robots?: boolean
    ogTitle?: boolean
    ogDescription?: boolean
    ogType?: boolean
    ogUrl?: boolean
    ogImageUrl?: boolean
    ogImageAlt?: boolean
    twitterCard?: boolean
    twitterSite?: boolean
    twitterCreator?: boolean
    eventName?: boolean
    eventDescription?: boolean
    eventStartDate?: boolean
    eventEndDate?: boolean
    eventUrl?: boolean
    eventImageUrl?: boolean
    eventLocationName?: boolean
    eventLocationStreet?: boolean
    eventLocationCity?: boolean
    eventLocationRegion?: boolean
    eventLocationPostal?: boolean
    eventLocationCountry?: boolean
    bookVersion?: boolean | Seo$bookVersionArgs<ExtArgs>
  }, ExtArgs["result"]["seo"]>

  export type SeoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    canonicalUrl?: boolean
    robots?: boolean
    ogTitle?: boolean
    ogDescription?: boolean
    ogType?: boolean
    ogUrl?: boolean
    ogImageUrl?: boolean
    ogImageAlt?: boolean
    twitterCard?: boolean
    twitterSite?: boolean
    twitterCreator?: boolean
    eventName?: boolean
    eventDescription?: boolean
    eventStartDate?: boolean
    eventEndDate?: boolean
    eventUrl?: boolean
    eventImageUrl?: boolean
    eventLocationName?: boolean
    eventLocationStreet?: boolean
    eventLocationCity?: boolean
    eventLocationRegion?: boolean
    eventLocationPostal?: boolean
    eventLocationCountry?: boolean
  }, ExtArgs["result"]["seo"]>

  export type SeoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    canonicalUrl?: boolean
    robots?: boolean
    ogTitle?: boolean
    ogDescription?: boolean
    ogType?: boolean
    ogUrl?: boolean
    ogImageUrl?: boolean
    ogImageAlt?: boolean
    twitterCard?: boolean
    twitterSite?: boolean
    twitterCreator?: boolean
    eventName?: boolean
    eventDescription?: boolean
    eventStartDate?: boolean
    eventEndDate?: boolean
    eventUrl?: boolean
    eventImageUrl?: boolean
    eventLocationName?: boolean
    eventLocationStreet?: boolean
    eventLocationCity?: boolean
    eventLocationRegion?: boolean
    eventLocationPostal?: boolean
    eventLocationCountry?: boolean
  }, ExtArgs["result"]["seo"]>

  export type SeoSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    canonicalUrl?: boolean
    robots?: boolean
    ogTitle?: boolean
    ogDescription?: boolean
    ogType?: boolean
    ogUrl?: boolean
    ogImageUrl?: boolean
    ogImageAlt?: boolean
    twitterCard?: boolean
    twitterSite?: boolean
    twitterCreator?: boolean
    eventName?: boolean
    eventDescription?: boolean
    eventStartDate?: boolean
    eventEndDate?: boolean
    eventUrl?: boolean
    eventImageUrl?: boolean
    eventLocationName?: boolean
    eventLocationStreet?: boolean
    eventLocationCity?: boolean
    eventLocationRegion?: boolean
    eventLocationPostal?: boolean
    eventLocationCountry?: boolean
  }

  export type SeoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "metaTitle" | "metaDescription" | "canonicalUrl" | "robots" | "ogTitle" | "ogDescription" | "ogType" | "ogUrl" | "ogImageUrl" | "ogImageAlt" | "twitterCard" | "twitterSite" | "twitterCreator" | "eventName" | "eventDescription" | "eventStartDate" | "eventEndDate" | "eventUrl" | "eventImageUrl" | "eventLocationName" | "eventLocationStreet" | "eventLocationCity" | "eventLocationRegion" | "eventLocationPostal" | "eventLocationCountry", ExtArgs["result"]["seo"]>
  export type SeoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookVersion?: boolean | Seo$bookVersionArgs<ExtArgs>
  }
  export type SeoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SeoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SeoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Seo"
    objects: {
      bookVersion: Prisma.$BookVersionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      metaTitle: string | null
      metaDescription: string | null
      canonicalUrl: string | null
      robots: string | null
      ogTitle: string | null
      ogDescription: string | null
      ogType: string | null
      ogUrl: string | null
      ogImageUrl: string | null
      ogImageAlt: string | null
      twitterCard: string | null
      twitterSite: string | null
      twitterCreator: string | null
      eventName: string | null
      eventDescription: string | null
      eventStartDate: Date | null
      eventEndDate: Date | null
      eventUrl: string | null
      eventImageUrl: string | null
      eventLocationName: string | null
      eventLocationStreet: string | null
      eventLocationCity: string | null
      eventLocationRegion: string | null
      eventLocationPostal: string | null
      eventLocationCountry: string | null
    }, ExtArgs["result"]["seo"]>
    composites: {}
  }

  type SeoGetPayload<S extends boolean | null | undefined | SeoDefaultArgs> = $Result.GetResult<Prisma.$SeoPayload, S>

  type SeoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeoCountAggregateInputType | true
    }

  export interface SeoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Seo'], meta: { name: 'Seo' } }
    /**
     * Find zero or one Seo that matches the filter.
     * @param {SeoFindUniqueArgs} args - Arguments to find a Seo
     * @example
     * // Get one Seo
     * const seo = await prisma.seo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeoFindUniqueArgs>(args: SelectSubset<T, SeoFindUniqueArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Seo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeoFindUniqueOrThrowArgs} args - Arguments to find a Seo
     * @example
     * // Get one Seo
     * const seo = await prisma.seo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeoFindUniqueOrThrowArgs>(args: SelectSubset<T, SeoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoFindFirstArgs} args - Arguments to find a Seo
     * @example
     * // Get one Seo
     * const seo = await prisma.seo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeoFindFirstArgs>(args?: SelectSubset<T, SeoFindFirstArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoFindFirstOrThrowArgs} args - Arguments to find a Seo
     * @example
     * // Get one Seo
     * const seo = await prisma.seo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeoFindFirstOrThrowArgs>(args?: SelectSubset<T, SeoFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Seos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seos
     * const seos = await prisma.seo.findMany()
     * 
     * // Get first 10 Seos
     * const seos = await prisma.seo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seoWithIdOnly = await prisma.seo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeoFindManyArgs>(args?: SelectSubset<T, SeoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Seo.
     * @param {SeoCreateArgs} args - Arguments to create a Seo.
     * @example
     * // Create one Seo
     * const Seo = await prisma.seo.create({
     *   data: {
     *     // ... data to create a Seo
     *   }
     * })
     * 
     */
    create<T extends SeoCreateArgs>(args: SelectSubset<T, SeoCreateArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Seos.
     * @param {SeoCreateManyArgs} args - Arguments to create many Seos.
     * @example
     * // Create many Seos
     * const seo = await prisma.seo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeoCreateManyArgs>(args?: SelectSubset<T, SeoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Seos and returns the data saved in the database.
     * @param {SeoCreateManyAndReturnArgs} args - Arguments to create many Seos.
     * @example
     * // Create many Seos
     * const seo = await prisma.seo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Seos and only return the `id`
     * const seoWithIdOnly = await prisma.seo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeoCreateManyAndReturnArgs>(args?: SelectSubset<T, SeoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Seo.
     * @param {SeoDeleteArgs} args - Arguments to delete one Seo.
     * @example
     * // Delete one Seo
     * const Seo = await prisma.seo.delete({
     *   where: {
     *     // ... filter to delete one Seo
     *   }
     * })
     * 
     */
    delete<T extends SeoDeleteArgs>(args: SelectSubset<T, SeoDeleteArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Seo.
     * @param {SeoUpdateArgs} args - Arguments to update one Seo.
     * @example
     * // Update one Seo
     * const seo = await prisma.seo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeoUpdateArgs>(args: SelectSubset<T, SeoUpdateArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Seos.
     * @param {SeoDeleteManyArgs} args - Arguments to filter Seos to delete.
     * @example
     * // Delete a few Seos
     * const { count } = await prisma.seo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeoDeleteManyArgs>(args?: SelectSubset<T, SeoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seos
     * const seo = await prisma.seo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeoUpdateManyArgs>(args: SelectSubset<T, SeoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seos and returns the data updated in the database.
     * @param {SeoUpdateManyAndReturnArgs} args - Arguments to update many Seos.
     * @example
     * // Update many Seos
     * const seo = await prisma.seo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Seos and only return the `id`
     * const seoWithIdOnly = await prisma.seo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeoUpdateManyAndReturnArgs>(args: SelectSubset<T, SeoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Seo.
     * @param {SeoUpsertArgs} args - Arguments to update or create a Seo.
     * @example
     * // Update or create a Seo
     * const seo = await prisma.seo.upsert({
     *   create: {
     *     // ... data to create a Seo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seo we want to update
     *   }
     * })
     */
    upsert<T extends SeoUpsertArgs>(args: SelectSubset<T, SeoUpsertArgs<ExtArgs>>): Prisma__SeoClient<$Result.GetResult<Prisma.$SeoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Seos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoCountArgs} args - Arguments to filter Seos to count.
     * @example
     * // Count the number of Seos
     * const count = await prisma.seo.count({
     *   where: {
     *     // ... the filter for the Seos we want to count
     *   }
     * })
    **/
    count<T extends SeoCountArgs>(
      args?: Subset<T, SeoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeoAggregateArgs>(args: Subset<T, SeoAggregateArgs>): Prisma.PrismaPromise<GetSeoAggregateType<T>>

    /**
     * Group by Seo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeoGroupByArgs['orderBy'] }
        : { orderBy?: SeoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Seo model
   */
  readonly fields: SeoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Seo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookVersion<T extends Seo$bookVersionArgs<ExtArgs> = {}>(args?: Subset<T, Seo$bookVersionArgs<ExtArgs>>): Prisma__BookVersionClient<$Result.GetResult<Prisma.$BookVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Seo model
   */
  interface SeoFieldRefs {
    readonly id: FieldRef<"Seo", 'Int'>
    readonly createdAt: FieldRef<"Seo", 'DateTime'>
    readonly updatedAt: FieldRef<"Seo", 'DateTime'>
    readonly metaTitle: FieldRef<"Seo", 'String'>
    readonly metaDescription: FieldRef<"Seo", 'String'>
    readonly canonicalUrl: FieldRef<"Seo", 'String'>
    readonly robots: FieldRef<"Seo", 'String'>
    readonly ogTitle: FieldRef<"Seo", 'String'>
    readonly ogDescription: FieldRef<"Seo", 'String'>
    readonly ogType: FieldRef<"Seo", 'String'>
    readonly ogUrl: FieldRef<"Seo", 'String'>
    readonly ogImageUrl: FieldRef<"Seo", 'String'>
    readonly ogImageAlt: FieldRef<"Seo", 'String'>
    readonly twitterCard: FieldRef<"Seo", 'String'>
    readonly twitterSite: FieldRef<"Seo", 'String'>
    readonly twitterCreator: FieldRef<"Seo", 'String'>
    readonly eventName: FieldRef<"Seo", 'String'>
    readonly eventDescription: FieldRef<"Seo", 'String'>
    readonly eventStartDate: FieldRef<"Seo", 'DateTime'>
    readonly eventEndDate: FieldRef<"Seo", 'DateTime'>
    readonly eventUrl: FieldRef<"Seo", 'String'>
    readonly eventImageUrl: FieldRef<"Seo", 'String'>
    readonly eventLocationName: FieldRef<"Seo", 'String'>
    readonly eventLocationStreet: FieldRef<"Seo", 'String'>
    readonly eventLocationCity: FieldRef<"Seo", 'String'>
    readonly eventLocationRegion: FieldRef<"Seo", 'String'>
    readonly eventLocationPostal: FieldRef<"Seo", 'String'>
    readonly eventLocationCountry: FieldRef<"Seo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Seo findUnique
   */
  export type SeoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    /**
     * Filter, which Seo to fetch.
     */
    where: SeoWhereUniqueInput
  }

  /**
   * Seo findUniqueOrThrow
   */
  export type SeoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    /**
     * Filter, which Seo to fetch.
     */
    where: SeoWhereUniqueInput
  }

  /**
   * Seo findFirst
   */
  export type SeoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    /**
     * Filter, which Seo to fetch.
     */
    where?: SeoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seos to fetch.
     */
    orderBy?: SeoOrderByWithRelationInput | SeoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seos.
     */
    cursor?: SeoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seos.
     */
    distinct?: SeoScalarFieldEnum | SeoScalarFieldEnum[]
  }

  /**
   * Seo findFirstOrThrow
   */
  export type SeoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    /**
     * Filter, which Seo to fetch.
     */
    where?: SeoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seos to fetch.
     */
    orderBy?: SeoOrderByWithRelationInput | SeoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seos.
     */
    cursor?: SeoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seos.
     */
    distinct?: SeoScalarFieldEnum | SeoScalarFieldEnum[]
  }

  /**
   * Seo findMany
   */
  export type SeoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    /**
     * Filter, which Seos to fetch.
     */
    where?: SeoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seos to fetch.
     */
    orderBy?: SeoOrderByWithRelationInput | SeoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Seos.
     */
    cursor?: SeoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seos.
     */
    skip?: number
    distinct?: SeoScalarFieldEnum | SeoScalarFieldEnum[]
  }

  /**
   * Seo create
   */
  export type SeoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    /**
     * The data needed to create a Seo.
     */
    data: XOR<SeoCreateInput, SeoUncheckedCreateInput>
  }

  /**
   * Seo createMany
   */
  export type SeoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Seos.
     */
    data: SeoCreateManyInput | SeoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Seo createManyAndReturn
   */
  export type SeoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * The data used to create many Seos.
     */
    data: SeoCreateManyInput | SeoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Seo update
   */
  export type SeoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    /**
     * The data needed to update a Seo.
     */
    data: XOR<SeoUpdateInput, SeoUncheckedUpdateInput>
    /**
     * Choose, which Seo to update.
     */
    where: SeoWhereUniqueInput
  }

  /**
   * Seo updateMany
   */
  export type SeoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Seos.
     */
    data: XOR<SeoUpdateManyMutationInput, SeoUncheckedUpdateManyInput>
    /**
     * Filter which Seos to update
     */
    where?: SeoWhereInput
    /**
     * Limit how many Seos to update.
     */
    limit?: number
  }

  /**
   * Seo updateManyAndReturn
   */
  export type SeoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * The data used to update Seos.
     */
    data: XOR<SeoUpdateManyMutationInput, SeoUncheckedUpdateManyInput>
    /**
     * Filter which Seos to update
     */
    where?: SeoWhereInput
    /**
     * Limit how many Seos to update.
     */
    limit?: number
  }

  /**
   * Seo upsert
   */
  export type SeoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    /**
     * The filter to search for the Seo to update in case it exists.
     */
    where: SeoWhereUniqueInput
    /**
     * In case the Seo found by the `where` argument doesn't exist, create a new Seo with this data.
     */
    create: XOR<SeoCreateInput, SeoUncheckedCreateInput>
    /**
     * In case the Seo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeoUpdateInput, SeoUncheckedUpdateInput>
  }

  /**
   * Seo delete
   */
  export type SeoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
    /**
     * Filter which Seo to delete.
     */
    where: SeoWhereUniqueInput
  }

  /**
   * Seo deleteMany
   */
  export type SeoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seos to delete
     */
    where?: SeoWhereInput
    /**
     * Limit how many Seos to delete.
     */
    limit?: number
  }

  /**
   * Seo.bookVersion
   */
  export type Seo$bookVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookVersion
     */
    select?: BookVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookVersion
     */
    omit?: BookVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookVersionInclude<ExtArgs> | null
    where?: BookVersionWhereInput
  }

  /**
   * Seo without action
   */
  export type SeoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seo
     */
    select?: SeoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seo
     */
    omit?: SeoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    name: $Enums.RoleName | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    name: $Enums.RoleName | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    name: $Enums.RoleName
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: $Enums.RoleName
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly name: FieldRef<"Role", 'RoleName'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleAvgAggregateOutputType = {
    roleId: number | null
  }

  export type UserRoleSumAggregateOutputType = {
    roleId: number | null
  }

  export type UserRoleMinAggregateOutputType = {
    userId: string | null
    roleId: number | null
  }

  export type UserRoleMaxAggregateOutputType = {
    userId: string | null
    roleId: number | null
  }

  export type UserRoleCountAggregateOutputType = {
    userId: number
    roleId: number
    _all: number
  }


  export type UserRoleAvgAggregateInputType = {
    roleId?: true
  }

  export type UserRoleSumAggregateInputType = {
    roleId?: true
  }

  export type UserRoleMinAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRoleMaxAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRoleCountAggregateInputType = {
    userId?: true
    roleId?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _avg?: UserRoleAvgAggregateInputType
    _sum?: UserRoleSumAggregateInputType
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    userId: string
    roleId: number
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    userId?: boolean
    roleId?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "roleId", ExtArgs["result"]["userRole"]>
  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      roleId: number
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {UserRoleUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoles and only return the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly roleId: FieldRef<"UserRole", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole updateManyAndReturn
   */
  export type UserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BookScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookScalarFieldEnum = (typeof BookScalarFieldEnum)[keyof typeof BookScalarFieldEnum]


  export const BookVersionScalarFieldEnum: {
    id: 'id',
    bookId: 'bookId',
    language: 'language',
    title: 'title',
    author: 'author',
    description: 'description',
    coverImageUrl: 'coverImageUrl',
    type: 'type',
    isFree: 'isFree',
    referralUrl: 'referralUrl',
    status: 'status',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    seoId: 'seoId'
  };

  export type BookVersionScalarFieldEnum = (typeof BookVersionScalarFieldEnum)[keyof typeof BookVersionScalarFieldEnum]


  export const BookSummaryScalarFieldEnum: {
    id: 'id',
    bookVersionId: 'bookVersionId',
    summary: 'summary',
    analysis: 'analysis',
    themes: 'themes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookSummaryScalarFieldEnum = (typeof BookSummaryScalarFieldEnum)[keyof typeof BookSummaryScalarFieldEnum]


  export const ChapterScalarFieldEnum: {
    id: 'id',
    bookVersionId: 'bookVersionId',
    number: 'number',
    title: 'title',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type ChapterScalarFieldEnum = (typeof ChapterScalarFieldEnum)[keyof typeof ChapterScalarFieldEnum]


  export const AudioChapterScalarFieldEnum: {
    id: 'id',
    bookVersionId: 'bookVersionId',
    number: 'number',
    title: 'title',
    audioUrl: 'audioUrl',
    duration: 'duration',
    createdAt: 'createdAt'
  };

  export type AudioChapterScalarFieldEnum = (typeof AudioChapterScalarFieldEnum)[keyof typeof AudioChapterScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    name: 'name',
    avatarUrl: 'avatarUrl',
    languagePreference: 'languagePreference',
    createdAt: 'createdAt',
    lastLogin: 'lastLogin'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const BookshelfScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bookVersionId: 'bookVersionId',
    addedAt: 'addedAt'
  };

  export type BookshelfScalarFieldEnum = (typeof BookshelfScalarFieldEnum)[keyof typeof BookshelfScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bookVersionId: 'bookVersionId',
    chapterId: 'chapterId',
    audioChapterId: 'audioChapterId',
    parentId: 'parentId',
    text: 'text',
    isDeleted: 'isDeleted',
    isHidden: 'isHidden',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const LikeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bookVersionId: 'bookVersionId',
    commentId: 'commentId',
    createdAt: 'createdAt'
  };

  export type LikeScalarFieldEnum = (typeof LikeScalarFieldEnum)[keyof typeof LikeScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    slug: 'slug',
    parentId: 'parentId'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const BookCategoryScalarFieldEnum: {
    id: 'id',
    bookVersionId: 'bookVersionId',
    categoryId: 'categoryId'
  };

  export type BookCategoryScalarFieldEnum = (typeof BookCategoryScalarFieldEnum)[keyof typeof BookCategoryScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const BookTagScalarFieldEnum: {
    id: 'id',
    bookVersionId: 'bookVersionId',
    tagId: 'tagId'
  };

  export type BookTagScalarFieldEnum = (typeof BookTagScalarFieldEnum)[keyof typeof BookTagScalarFieldEnum]


  export const ViewStatScalarFieldEnum: {
    id: 'id',
    bookVersionId: 'bookVersionId',
    userId: 'userId',
    source: 'source',
    timestamp: 'timestamp'
  };

  export type ViewStatScalarFieldEnum = (typeof ViewStatScalarFieldEnum)[keyof typeof ViewStatScalarFieldEnum]


  export const ReadingProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bookVersionId: 'bookVersionId',
    chapterNumber: 'chapterNumber',
    audioChapterNumber: 'audioChapterNumber',
    position: 'position',
    updatedAt: 'updatedAt'
  };

  export type ReadingProgressScalarFieldEnum = (typeof ReadingProgressScalarFieldEnum)[keyof typeof ReadingProgressScalarFieldEnum]


  export const SeoScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    canonicalUrl: 'canonicalUrl',
    robots: 'robots',
    ogTitle: 'ogTitle',
    ogDescription: 'ogDescription',
    ogType: 'ogType',
    ogUrl: 'ogUrl',
    ogImageUrl: 'ogImageUrl',
    ogImageAlt: 'ogImageAlt',
    twitterCard: 'twitterCard',
    twitterSite: 'twitterSite',
    twitterCreator: 'twitterCreator',
    eventName: 'eventName',
    eventDescription: 'eventDescription',
    eventStartDate: 'eventStartDate',
    eventEndDate: 'eventEndDate',
    eventUrl: 'eventUrl',
    eventImageUrl: 'eventImageUrl',
    eventLocationName: 'eventLocationName',
    eventLocationStreet: 'eventLocationStreet',
    eventLocationCity: 'eventLocationCity',
    eventLocationRegion: 'eventLocationRegion',
    eventLocationPostal: 'eventLocationPostal',
    eventLocationCountry: 'eventLocationCountry'
  };

  export type SeoScalarFieldEnum = (typeof SeoScalarFieldEnum)[keyof typeof SeoScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    userId: 'userId',
    roleId: 'roleId'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Language'
   */
  export type EnumLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Language'>
    


  /**
   * Reference to a field of type 'Language[]'
   */
  export type ListEnumLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Language[]'>
    


  /**
   * Reference to a field of type 'BookType'
   */
  export type EnumBookTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookType'>
    


  /**
   * Reference to a field of type 'BookType[]'
   */
  export type ListEnumBookTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'PublicationStatus'
   */
  export type EnumPublicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublicationStatus'>
    


  /**
   * Reference to a field of type 'PublicationStatus[]'
   */
  export type ListEnumPublicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublicationStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'CategoryType'
   */
  export type EnumCategoryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CategoryType'>
    


  /**
   * Reference to a field of type 'CategoryType[]'
   */
  export type ListEnumCategoryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CategoryType[]'>
    


  /**
   * Reference to a field of type 'ViewSource'
   */
  export type EnumViewSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ViewSource'>
    


  /**
   * Reference to a field of type 'ViewSource[]'
   */
  export type ListEnumViewSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ViewSource[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'RoleName'
   */
  export type EnumRoleNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleName'>
    


  /**
   * Reference to a field of type 'RoleName[]'
   */
  export type ListEnumRoleNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleName[]'>
    
  /**
   * Deep Input Types
   */


  export type BookWhereInput = {
    AND?: BookWhereInput | BookWhereInput[]
    OR?: BookWhereInput[]
    NOT?: BookWhereInput | BookWhereInput[]
    id?: StringFilter<"Book"> | string
    slug?: StringFilter<"Book"> | string
    createdAt?: DateTimeFilter<"Book"> | Date | string
    updatedAt?: DateTimeFilter<"Book"> | Date | string
    versions?: BookVersionListRelationFilter
  }

  export type BookOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    versions?: BookVersionOrderByRelationAggregateInput
  }

  export type BookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BookWhereInput | BookWhereInput[]
    OR?: BookWhereInput[]
    NOT?: BookWhereInput | BookWhereInput[]
    createdAt?: DateTimeFilter<"Book"> | Date | string
    updatedAt?: DateTimeFilter<"Book"> | Date | string
    versions?: BookVersionListRelationFilter
  }, "id" | "slug">

  export type BookOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookCountOrderByAggregateInput
    _max?: BookMaxOrderByAggregateInput
    _min?: BookMinOrderByAggregateInput
  }

  export type BookScalarWhereWithAggregatesInput = {
    AND?: BookScalarWhereWithAggregatesInput | BookScalarWhereWithAggregatesInput[]
    OR?: BookScalarWhereWithAggregatesInput[]
    NOT?: BookScalarWhereWithAggregatesInput | BookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Book"> | string
    slug?: StringWithAggregatesFilter<"Book"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Book"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Book"> | Date | string
  }

  export type BookVersionWhereInput = {
    AND?: BookVersionWhereInput | BookVersionWhereInput[]
    OR?: BookVersionWhereInput[]
    NOT?: BookVersionWhereInput | BookVersionWhereInput[]
    id?: StringFilter<"BookVersion"> | string
    bookId?: StringFilter<"BookVersion"> | string
    language?: EnumLanguageFilter<"BookVersion"> | $Enums.Language
    title?: StringFilter<"BookVersion"> | string
    author?: StringFilter<"BookVersion"> | string
    description?: StringFilter<"BookVersion"> | string
    coverImageUrl?: StringFilter<"BookVersion"> | string
    type?: EnumBookTypeFilter<"BookVersion"> | $Enums.BookType
    isFree?: BoolFilter<"BookVersion"> | boolean
    referralUrl?: StringNullableFilter<"BookVersion"> | string | null
    status?: EnumPublicationStatusFilter<"BookVersion"> | $Enums.PublicationStatus
    publishedAt?: DateTimeNullableFilter<"BookVersion"> | Date | string | null
    createdAt?: DateTimeFilter<"BookVersion"> | Date | string
    updatedAt?: DateTimeFilter<"BookVersion"> | Date | string
    seoId?: IntNullableFilter<"BookVersion"> | number | null
    book?: XOR<BookScalarRelationFilter, BookWhereInput>
    summaries?: BookSummaryListRelationFilter
    chapters?: ChapterListRelationFilter
    audioChapters?: AudioChapterListRelationFilter
    bookshelf?: BookshelfListRelationFilter
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
    categories?: BookCategoryListRelationFilter
    tags?: BookTagListRelationFilter
    viewStats?: ViewStatListRelationFilter
    readingProgress?: ReadingProgressListRelationFilter
    seo?: XOR<SeoNullableScalarRelationFilter, SeoWhereInput> | null
  }

  export type BookVersionOrderByWithRelationInput = {
    id?: SortOrder
    bookId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    author?: SortOrder
    description?: SortOrder
    coverImageUrl?: SortOrder
    type?: SortOrder
    isFree?: SortOrder
    referralUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seoId?: SortOrderInput | SortOrder
    book?: BookOrderByWithRelationInput
    summaries?: BookSummaryOrderByRelationAggregateInput
    chapters?: ChapterOrderByRelationAggregateInput
    audioChapters?: AudioChapterOrderByRelationAggregateInput
    bookshelf?: BookshelfOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    likes?: LikeOrderByRelationAggregateInput
    categories?: BookCategoryOrderByRelationAggregateInput
    tags?: BookTagOrderByRelationAggregateInput
    viewStats?: ViewStatOrderByRelationAggregateInput
    readingProgress?: ReadingProgressOrderByRelationAggregateInput
    seo?: SeoOrderByWithRelationInput
  }

  export type BookVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seoId?: number
    bookId_language?: BookVersionBookIdLanguageCompoundUniqueInput
    AND?: BookVersionWhereInput | BookVersionWhereInput[]
    OR?: BookVersionWhereInput[]
    NOT?: BookVersionWhereInput | BookVersionWhereInput[]
    bookId?: StringFilter<"BookVersion"> | string
    language?: EnumLanguageFilter<"BookVersion"> | $Enums.Language
    title?: StringFilter<"BookVersion"> | string
    author?: StringFilter<"BookVersion"> | string
    description?: StringFilter<"BookVersion"> | string
    coverImageUrl?: StringFilter<"BookVersion"> | string
    type?: EnumBookTypeFilter<"BookVersion"> | $Enums.BookType
    isFree?: BoolFilter<"BookVersion"> | boolean
    referralUrl?: StringNullableFilter<"BookVersion"> | string | null
    status?: EnumPublicationStatusFilter<"BookVersion"> | $Enums.PublicationStatus
    publishedAt?: DateTimeNullableFilter<"BookVersion"> | Date | string | null
    createdAt?: DateTimeFilter<"BookVersion"> | Date | string
    updatedAt?: DateTimeFilter<"BookVersion"> | Date | string
    book?: XOR<BookScalarRelationFilter, BookWhereInput>
    summaries?: BookSummaryListRelationFilter
    chapters?: ChapterListRelationFilter
    audioChapters?: AudioChapterListRelationFilter
    bookshelf?: BookshelfListRelationFilter
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
    categories?: BookCategoryListRelationFilter
    tags?: BookTagListRelationFilter
    viewStats?: ViewStatListRelationFilter
    readingProgress?: ReadingProgressListRelationFilter
    seo?: XOR<SeoNullableScalarRelationFilter, SeoWhereInput> | null
  }, "id" | "seoId" | "bookId_language">

  export type BookVersionOrderByWithAggregationInput = {
    id?: SortOrder
    bookId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    author?: SortOrder
    description?: SortOrder
    coverImageUrl?: SortOrder
    type?: SortOrder
    isFree?: SortOrder
    referralUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seoId?: SortOrderInput | SortOrder
    _count?: BookVersionCountOrderByAggregateInput
    _avg?: BookVersionAvgOrderByAggregateInput
    _max?: BookVersionMaxOrderByAggregateInput
    _min?: BookVersionMinOrderByAggregateInput
    _sum?: BookVersionSumOrderByAggregateInput
  }

  export type BookVersionScalarWhereWithAggregatesInput = {
    AND?: BookVersionScalarWhereWithAggregatesInput | BookVersionScalarWhereWithAggregatesInput[]
    OR?: BookVersionScalarWhereWithAggregatesInput[]
    NOT?: BookVersionScalarWhereWithAggregatesInput | BookVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookVersion"> | string
    bookId?: StringWithAggregatesFilter<"BookVersion"> | string
    language?: EnumLanguageWithAggregatesFilter<"BookVersion"> | $Enums.Language
    title?: StringWithAggregatesFilter<"BookVersion"> | string
    author?: StringWithAggregatesFilter<"BookVersion"> | string
    description?: StringWithAggregatesFilter<"BookVersion"> | string
    coverImageUrl?: StringWithAggregatesFilter<"BookVersion"> | string
    type?: EnumBookTypeWithAggregatesFilter<"BookVersion"> | $Enums.BookType
    isFree?: BoolWithAggregatesFilter<"BookVersion"> | boolean
    referralUrl?: StringNullableWithAggregatesFilter<"BookVersion"> | string | null
    status?: EnumPublicationStatusWithAggregatesFilter<"BookVersion"> | $Enums.PublicationStatus
    publishedAt?: DateTimeNullableWithAggregatesFilter<"BookVersion"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BookVersion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BookVersion"> | Date | string
    seoId?: IntNullableWithAggregatesFilter<"BookVersion"> | number | null
  }

  export type BookSummaryWhereInput = {
    AND?: BookSummaryWhereInput | BookSummaryWhereInput[]
    OR?: BookSummaryWhereInput[]
    NOT?: BookSummaryWhereInput | BookSummaryWhereInput[]
    id?: StringFilter<"BookSummary"> | string
    bookVersionId?: StringFilter<"BookSummary"> | string
    summary?: StringFilter<"BookSummary"> | string
    analysis?: StringNullableFilter<"BookSummary"> | string | null
    themes?: StringNullableFilter<"BookSummary"> | string | null
    createdAt?: DateTimeFilter<"BookSummary"> | Date | string
    updatedAt?: DateTimeFilter<"BookSummary"> | Date | string
    bookVersion?: XOR<BookVersionScalarRelationFilter, BookVersionWhereInput>
  }

  export type BookSummaryOrderByWithRelationInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    summary?: SortOrder
    analysis?: SortOrderInput | SortOrder
    themes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookVersion?: BookVersionOrderByWithRelationInput
  }

  export type BookSummaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookSummaryWhereInput | BookSummaryWhereInput[]
    OR?: BookSummaryWhereInput[]
    NOT?: BookSummaryWhereInput | BookSummaryWhereInput[]
    bookVersionId?: StringFilter<"BookSummary"> | string
    summary?: StringFilter<"BookSummary"> | string
    analysis?: StringNullableFilter<"BookSummary"> | string | null
    themes?: StringNullableFilter<"BookSummary"> | string | null
    createdAt?: DateTimeFilter<"BookSummary"> | Date | string
    updatedAt?: DateTimeFilter<"BookSummary"> | Date | string
    bookVersion?: XOR<BookVersionScalarRelationFilter, BookVersionWhereInput>
  }, "id">

  export type BookSummaryOrderByWithAggregationInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    summary?: SortOrder
    analysis?: SortOrderInput | SortOrder
    themes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookSummaryCountOrderByAggregateInput
    _max?: BookSummaryMaxOrderByAggregateInput
    _min?: BookSummaryMinOrderByAggregateInput
  }

  export type BookSummaryScalarWhereWithAggregatesInput = {
    AND?: BookSummaryScalarWhereWithAggregatesInput | BookSummaryScalarWhereWithAggregatesInput[]
    OR?: BookSummaryScalarWhereWithAggregatesInput[]
    NOT?: BookSummaryScalarWhereWithAggregatesInput | BookSummaryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookSummary"> | string
    bookVersionId?: StringWithAggregatesFilter<"BookSummary"> | string
    summary?: StringWithAggregatesFilter<"BookSummary"> | string
    analysis?: StringNullableWithAggregatesFilter<"BookSummary"> | string | null
    themes?: StringNullableWithAggregatesFilter<"BookSummary"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BookSummary"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BookSummary"> | Date | string
  }

  export type ChapterWhereInput = {
    AND?: ChapterWhereInput | ChapterWhereInput[]
    OR?: ChapterWhereInput[]
    NOT?: ChapterWhereInput | ChapterWhereInput[]
    id?: StringFilter<"Chapter"> | string
    bookVersionId?: StringFilter<"Chapter"> | string
    number?: IntFilter<"Chapter"> | number
    title?: StringFilter<"Chapter"> | string
    content?: StringFilter<"Chapter"> | string
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
    bookVersion?: XOR<BookVersionScalarRelationFilter, BookVersionWhereInput>
    comments?: CommentListRelationFilter
  }

  export type ChapterOrderByWithRelationInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    number?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    bookVersion?: BookVersionOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type ChapterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bookVersionId_number?: ChapterBookVersionIdNumberCompoundUniqueInput
    AND?: ChapterWhereInput | ChapterWhereInput[]
    OR?: ChapterWhereInput[]
    NOT?: ChapterWhereInput | ChapterWhereInput[]
    bookVersionId?: StringFilter<"Chapter"> | string
    number?: IntFilter<"Chapter"> | number
    title?: StringFilter<"Chapter"> | string
    content?: StringFilter<"Chapter"> | string
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
    bookVersion?: XOR<BookVersionScalarRelationFilter, BookVersionWhereInput>
    comments?: CommentListRelationFilter
  }, "id" | "bookVersionId_number">

  export type ChapterOrderByWithAggregationInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    number?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: ChapterCountOrderByAggregateInput
    _avg?: ChapterAvgOrderByAggregateInput
    _max?: ChapterMaxOrderByAggregateInput
    _min?: ChapterMinOrderByAggregateInput
    _sum?: ChapterSumOrderByAggregateInput
  }

  export type ChapterScalarWhereWithAggregatesInput = {
    AND?: ChapterScalarWhereWithAggregatesInput | ChapterScalarWhereWithAggregatesInput[]
    OR?: ChapterScalarWhereWithAggregatesInput[]
    NOT?: ChapterScalarWhereWithAggregatesInput | ChapterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chapter"> | string
    bookVersionId?: StringWithAggregatesFilter<"Chapter"> | string
    number?: IntWithAggregatesFilter<"Chapter"> | number
    title?: StringWithAggregatesFilter<"Chapter"> | string
    content?: StringWithAggregatesFilter<"Chapter"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Chapter"> | Date | string
  }

  export type AudioChapterWhereInput = {
    AND?: AudioChapterWhereInput | AudioChapterWhereInput[]
    OR?: AudioChapterWhereInput[]
    NOT?: AudioChapterWhereInput | AudioChapterWhereInput[]
    id?: StringFilter<"AudioChapter"> | string
    bookVersionId?: StringFilter<"AudioChapter"> | string
    number?: IntFilter<"AudioChapter"> | number
    title?: StringFilter<"AudioChapter"> | string
    audioUrl?: StringFilter<"AudioChapter"> | string
    duration?: IntFilter<"AudioChapter"> | number
    createdAt?: DateTimeFilter<"AudioChapter"> | Date | string
    bookVersion?: XOR<BookVersionScalarRelationFilter, BookVersionWhereInput>
    comments?: CommentListRelationFilter
  }

  export type AudioChapterOrderByWithRelationInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    number?: SortOrder
    title?: SortOrder
    audioUrl?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    bookVersion?: BookVersionOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type AudioChapterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bookVersionId_number?: AudioChapterBookVersionIdNumberCompoundUniqueInput
    AND?: AudioChapterWhereInput | AudioChapterWhereInput[]
    OR?: AudioChapterWhereInput[]
    NOT?: AudioChapterWhereInput | AudioChapterWhereInput[]
    bookVersionId?: StringFilter<"AudioChapter"> | string
    number?: IntFilter<"AudioChapter"> | number
    title?: StringFilter<"AudioChapter"> | string
    audioUrl?: StringFilter<"AudioChapter"> | string
    duration?: IntFilter<"AudioChapter"> | number
    createdAt?: DateTimeFilter<"AudioChapter"> | Date | string
    bookVersion?: XOR<BookVersionScalarRelationFilter, BookVersionWhereInput>
    comments?: CommentListRelationFilter
  }, "id" | "bookVersionId_number">

  export type AudioChapterOrderByWithAggregationInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    number?: SortOrder
    title?: SortOrder
    audioUrl?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    _count?: AudioChapterCountOrderByAggregateInput
    _avg?: AudioChapterAvgOrderByAggregateInput
    _max?: AudioChapterMaxOrderByAggregateInput
    _min?: AudioChapterMinOrderByAggregateInput
    _sum?: AudioChapterSumOrderByAggregateInput
  }

  export type AudioChapterScalarWhereWithAggregatesInput = {
    AND?: AudioChapterScalarWhereWithAggregatesInput | AudioChapterScalarWhereWithAggregatesInput[]
    OR?: AudioChapterScalarWhereWithAggregatesInput[]
    NOT?: AudioChapterScalarWhereWithAggregatesInput | AudioChapterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AudioChapter"> | string
    bookVersionId?: StringWithAggregatesFilter<"AudioChapter"> | string
    number?: IntWithAggregatesFilter<"AudioChapter"> | number
    title?: StringWithAggregatesFilter<"AudioChapter"> | string
    audioUrl?: StringWithAggregatesFilter<"AudioChapter"> | string
    duration?: IntWithAggregatesFilter<"AudioChapter"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AudioChapter"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    languagePreference?: EnumLanguageFilter<"User"> | $Enums.Language
    createdAt?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    bookshelves?: BookshelfListRelationFilter
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
    viewStats?: ViewStatListRelationFilter
    readingProgress?: ReadingProgressListRelationFilter
    roles?: UserRoleListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    languagePreference?: SortOrder
    createdAt?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    bookshelves?: BookshelfOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    likes?: LikeOrderByRelationAggregateInput
    viewStats?: ViewStatOrderByRelationAggregateInput
    readingProgress?: ReadingProgressOrderByRelationAggregateInput
    roles?: UserRoleOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    languagePreference?: EnumLanguageFilter<"User"> | $Enums.Language
    createdAt?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    bookshelves?: BookshelfListRelationFilter
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
    viewStats?: ViewStatListRelationFilter
    readingProgress?: ReadingProgressListRelationFilter
    roles?: UserRoleListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    languagePreference?: SortOrder
    createdAt?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    languagePreference?: EnumLanguageWithAggregatesFilter<"User"> | $Enums.Language
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type BookshelfWhereInput = {
    AND?: BookshelfWhereInput | BookshelfWhereInput[]
    OR?: BookshelfWhereInput[]
    NOT?: BookshelfWhereInput | BookshelfWhereInput[]
    id?: StringFilter<"Bookshelf"> | string
    userId?: StringFilter<"Bookshelf"> | string
    bookVersionId?: StringFilter<"Bookshelf"> | string
    addedAt?: DateTimeFilter<"Bookshelf"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bookVersion?: XOR<BookVersionScalarRelationFilter, BookVersionWhereInput>
  }

  export type BookshelfOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    bookVersionId?: SortOrder
    addedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    bookVersion?: BookVersionOrderByWithRelationInput
  }

  export type BookshelfWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_bookVersionId?: BookshelfUserIdBookVersionIdCompoundUniqueInput
    AND?: BookshelfWhereInput | BookshelfWhereInput[]
    OR?: BookshelfWhereInput[]
    NOT?: BookshelfWhereInput | BookshelfWhereInput[]
    userId?: StringFilter<"Bookshelf"> | string
    bookVersionId?: StringFilter<"Bookshelf"> | string
    addedAt?: DateTimeFilter<"Bookshelf"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bookVersion?: XOR<BookVersionScalarRelationFilter, BookVersionWhereInput>
  }, "id" | "userId_bookVersionId">

  export type BookshelfOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    bookVersionId?: SortOrder
    addedAt?: SortOrder
    _count?: BookshelfCountOrderByAggregateInput
    _max?: BookshelfMaxOrderByAggregateInput
    _min?: BookshelfMinOrderByAggregateInput
  }

  export type BookshelfScalarWhereWithAggregatesInput = {
    AND?: BookshelfScalarWhereWithAggregatesInput | BookshelfScalarWhereWithAggregatesInput[]
    OR?: BookshelfScalarWhereWithAggregatesInput[]
    NOT?: BookshelfScalarWhereWithAggregatesInput | BookshelfScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bookshelf"> | string
    userId?: StringWithAggregatesFilter<"Bookshelf"> | string
    bookVersionId?: StringWithAggregatesFilter<"Bookshelf"> | string
    addedAt?: DateTimeWithAggregatesFilter<"Bookshelf"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    bookVersionId?: StringNullableFilter<"Comment"> | string | null
    chapterId?: StringNullableFilter<"Comment"> | string | null
    audioChapterId?: StringNullableFilter<"Comment"> | string | null
    parentId?: StringNullableFilter<"Comment"> | string | null
    text?: StringFilter<"Comment"> | string
    isDeleted?: BoolFilter<"Comment"> | boolean
    isHidden?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bookVersion?: XOR<BookVersionNullableScalarRelationFilter, BookVersionWhereInput> | null
    chapter?: XOR<ChapterNullableScalarRelationFilter, ChapterWhereInput> | null
    audioChapter?: XOR<AudioChapterNullableScalarRelationFilter, AudioChapterWhereInput> | null
    parent?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    children?: CommentListRelationFilter
    likes?: LikeListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    bookVersionId?: SortOrderInput | SortOrder
    chapterId?: SortOrderInput | SortOrder
    audioChapterId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    text?: SortOrder
    isDeleted?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    bookVersion?: BookVersionOrderByWithRelationInput
    chapter?: ChapterOrderByWithRelationInput
    audioChapter?: AudioChapterOrderByWithRelationInput
    parent?: CommentOrderByWithRelationInput
    children?: CommentOrderByRelationAggregateInput
    likes?: LikeOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    userId?: StringFilter<"Comment"> | string
    bookVersionId?: StringNullableFilter<"Comment"> | string | null
    chapterId?: StringNullableFilter<"Comment"> | string | null
    audioChapterId?: StringNullableFilter<"Comment"> | string | null
    parentId?: StringNullableFilter<"Comment"> | string | null
    text?: StringFilter<"Comment"> | string
    isDeleted?: BoolFilter<"Comment"> | boolean
    isHidden?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bookVersion?: XOR<BookVersionNullableScalarRelationFilter, BookVersionWhereInput> | null
    chapter?: XOR<ChapterNullableScalarRelationFilter, ChapterWhereInput> | null
    audioChapter?: XOR<AudioChapterNullableScalarRelationFilter, AudioChapterWhereInput> | null
    parent?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    children?: CommentListRelationFilter
    likes?: LikeListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    bookVersionId?: SortOrderInput | SortOrder
    chapterId?: SortOrderInput | SortOrder
    audioChapterId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    text?: SortOrder
    isDeleted?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    userId?: StringWithAggregatesFilter<"Comment"> | string
    bookVersionId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    chapterId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    audioChapterId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    text?: StringWithAggregatesFilter<"Comment"> | string
    isDeleted?: BoolWithAggregatesFilter<"Comment"> | boolean
    isHidden?: BoolWithAggregatesFilter<"Comment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type LikeWhereInput = {
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    id?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
    bookVersionId?: StringNullableFilter<"Like"> | string | null
    commentId?: StringNullableFilter<"Like"> | string | null
    createdAt?: DateTimeFilter<"Like"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bookVersion?: XOR<BookVersionNullableScalarRelationFilter, BookVersionWhereInput> | null
    comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
  }

  export type LikeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    bookVersionId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    bookVersion?: BookVersionOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
  }

  export type LikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_commentId?: LikeUserIdCommentIdCompoundUniqueInput
    userId_bookVersionId?: LikeUserIdBookVersionIdCompoundUniqueInput
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    userId?: StringFilter<"Like"> | string
    bookVersionId?: StringNullableFilter<"Like"> | string | null
    commentId?: StringNullableFilter<"Like"> | string | null
    createdAt?: DateTimeFilter<"Like"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bookVersion?: XOR<BookVersionNullableScalarRelationFilter, BookVersionWhereInput> | null
    comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
  }, "id" | "userId_commentId" | "userId_bookVersionId">

  export type LikeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    bookVersionId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LikeCountOrderByAggregateInput
    _max?: LikeMaxOrderByAggregateInput
    _min?: LikeMinOrderByAggregateInput
  }

  export type LikeScalarWhereWithAggregatesInput = {
    AND?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    OR?: LikeScalarWhereWithAggregatesInput[]
    NOT?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Like"> | string
    userId?: StringWithAggregatesFilter<"Like"> | string
    bookVersionId?: StringNullableWithAggregatesFilter<"Like"> | string | null
    commentId?: StringNullableWithAggregatesFilter<"Like"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Like"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    type?: EnumCategoryTypeFilter<"Category"> | $Enums.CategoryType
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    parentId?: StringNullableFilter<"Category"> | string | null
    books?: BookCategoryListRelationFilter
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    parentId?: SortOrderInput | SortOrder
    books?: BookCategoryOrderByRelationAggregateInput
    parent?: CategoryOrderByWithRelationInput
    children?: CategoryOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    type?: EnumCategoryTypeFilter<"Category"> | $Enums.CategoryType
    name?: StringFilter<"Category"> | string
    parentId?: StringNullableFilter<"Category"> | string | null
    books?: BookCategoryListRelationFilter
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
  }, "id" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    parentId?: SortOrderInput | SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    type?: EnumCategoryTypeWithAggregatesFilter<"Category"> | $Enums.CategoryType
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    parentId?: StringNullableWithAggregatesFilter<"Category"> | string | null
  }

  export type BookCategoryWhereInput = {
    AND?: BookCategoryWhereInput | BookCategoryWhereInput[]
    OR?: BookCategoryWhereInput[]
    NOT?: BookCategoryWhereInput | BookCategoryWhereInput[]
    id?: StringFilter<"BookCategory"> | string
    bookVersionId?: StringFilter<"BookCategory"> | string
    categoryId?: StringFilter<"BookCategory"> | string
    bookVersion?: XOR<BookVersionScalarRelationFilter, BookVersionWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }

  export type BookCategoryOrderByWithRelationInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    categoryId?: SortOrder
    bookVersion?: BookVersionOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
  }

  export type BookCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bookVersionId_categoryId?: BookCategoryBookVersionIdCategoryIdCompoundUniqueInput
    AND?: BookCategoryWhereInput | BookCategoryWhereInput[]
    OR?: BookCategoryWhereInput[]
    NOT?: BookCategoryWhereInput | BookCategoryWhereInput[]
    bookVersionId?: StringFilter<"BookCategory"> | string
    categoryId?: StringFilter<"BookCategory"> | string
    bookVersion?: XOR<BookVersionScalarRelationFilter, BookVersionWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }, "id" | "bookVersionId_categoryId">

  export type BookCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    categoryId?: SortOrder
    _count?: BookCategoryCountOrderByAggregateInput
    _max?: BookCategoryMaxOrderByAggregateInput
    _min?: BookCategoryMinOrderByAggregateInput
  }

  export type BookCategoryScalarWhereWithAggregatesInput = {
    AND?: BookCategoryScalarWhereWithAggregatesInput | BookCategoryScalarWhereWithAggregatesInput[]
    OR?: BookCategoryScalarWhereWithAggregatesInput[]
    NOT?: BookCategoryScalarWhereWithAggregatesInput | BookCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookCategory"> | string
    bookVersionId?: StringWithAggregatesFilter<"BookCategory"> | string
    categoryId?: StringWithAggregatesFilter<"BookCategory"> | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
    books?: BookTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    books?: BookTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    name?: StringFilter<"Tag"> | string
    books?: BookTagListRelationFilter
  }, "id" | "slug">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    slug?: StringWithAggregatesFilter<"Tag"> | string
  }

  export type BookTagWhereInput = {
    AND?: BookTagWhereInput | BookTagWhereInput[]
    OR?: BookTagWhereInput[]
    NOT?: BookTagWhereInput | BookTagWhereInput[]
    id?: StringFilter<"BookTag"> | string
    bookVersionId?: StringFilter<"BookTag"> | string
    tagId?: StringFilter<"BookTag"> | string
    bookVersion?: XOR<BookVersionScalarRelationFilter, BookVersionWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type BookTagOrderByWithRelationInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    tagId?: SortOrder
    bookVersion?: BookVersionOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type BookTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bookVersionId_tagId?: BookTagBookVersionIdTagIdCompoundUniqueInput
    AND?: BookTagWhereInput | BookTagWhereInput[]
    OR?: BookTagWhereInput[]
    NOT?: BookTagWhereInput | BookTagWhereInput[]
    bookVersionId?: StringFilter<"BookTag"> | string
    tagId?: StringFilter<"BookTag"> | string
    bookVersion?: XOR<BookVersionScalarRelationFilter, BookVersionWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "id" | "bookVersionId_tagId">

  export type BookTagOrderByWithAggregationInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    tagId?: SortOrder
    _count?: BookTagCountOrderByAggregateInput
    _max?: BookTagMaxOrderByAggregateInput
    _min?: BookTagMinOrderByAggregateInput
  }

  export type BookTagScalarWhereWithAggregatesInput = {
    AND?: BookTagScalarWhereWithAggregatesInput | BookTagScalarWhereWithAggregatesInput[]
    OR?: BookTagScalarWhereWithAggregatesInput[]
    NOT?: BookTagScalarWhereWithAggregatesInput | BookTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookTag"> | string
    bookVersionId?: StringWithAggregatesFilter<"BookTag"> | string
    tagId?: StringWithAggregatesFilter<"BookTag"> | string
  }

  export type ViewStatWhereInput = {
    AND?: ViewStatWhereInput | ViewStatWhereInput[]
    OR?: ViewStatWhereInput[]
    NOT?: ViewStatWhereInput | ViewStatWhereInput[]
    id?: StringFilter<"ViewStat"> | string
    bookVersionId?: StringFilter<"ViewStat"> | string
    userId?: StringNullableFilter<"ViewStat"> | string | null
    source?: EnumViewSourceFilter<"ViewStat"> | $Enums.ViewSource
    timestamp?: DateTimeFilter<"ViewStat"> | Date | string
    bookVersion?: XOR<BookVersionScalarRelationFilter, BookVersionWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ViewStatOrderByWithRelationInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    userId?: SortOrderInput | SortOrder
    source?: SortOrder
    timestamp?: SortOrder
    bookVersion?: BookVersionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ViewStatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ViewStatWhereInput | ViewStatWhereInput[]
    OR?: ViewStatWhereInput[]
    NOT?: ViewStatWhereInput | ViewStatWhereInput[]
    bookVersionId?: StringFilter<"ViewStat"> | string
    userId?: StringNullableFilter<"ViewStat"> | string | null
    source?: EnumViewSourceFilter<"ViewStat"> | $Enums.ViewSource
    timestamp?: DateTimeFilter<"ViewStat"> | Date | string
    bookVersion?: XOR<BookVersionScalarRelationFilter, BookVersionWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ViewStatOrderByWithAggregationInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    userId?: SortOrderInput | SortOrder
    source?: SortOrder
    timestamp?: SortOrder
    _count?: ViewStatCountOrderByAggregateInput
    _max?: ViewStatMaxOrderByAggregateInput
    _min?: ViewStatMinOrderByAggregateInput
  }

  export type ViewStatScalarWhereWithAggregatesInput = {
    AND?: ViewStatScalarWhereWithAggregatesInput | ViewStatScalarWhereWithAggregatesInput[]
    OR?: ViewStatScalarWhereWithAggregatesInput[]
    NOT?: ViewStatScalarWhereWithAggregatesInput | ViewStatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ViewStat"> | string
    bookVersionId?: StringWithAggregatesFilter<"ViewStat"> | string
    userId?: StringNullableWithAggregatesFilter<"ViewStat"> | string | null
    source?: EnumViewSourceWithAggregatesFilter<"ViewStat"> | $Enums.ViewSource
    timestamp?: DateTimeWithAggregatesFilter<"ViewStat"> | Date | string
  }

  export type ReadingProgressWhereInput = {
    AND?: ReadingProgressWhereInput | ReadingProgressWhereInput[]
    OR?: ReadingProgressWhereInput[]
    NOT?: ReadingProgressWhereInput | ReadingProgressWhereInput[]
    id?: StringFilter<"ReadingProgress"> | string
    userId?: StringFilter<"ReadingProgress"> | string
    bookVersionId?: StringFilter<"ReadingProgress"> | string
    chapterNumber?: IntNullableFilter<"ReadingProgress"> | number | null
    audioChapterNumber?: IntNullableFilter<"ReadingProgress"> | number | null
    position?: FloatFilter<"ReadingProgress"> | number
    updatedAt?: DateTimeFilter<"ReadingProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bookVersion?: XOR<BookVersionScalarRelationFilter, BookVersionWhereInput>
  }

  export type ReadingProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    bookVersionId?: SortOrder
    chapterNumber?: SortOrderInput | SortOrder
    audioChapterNumber?: SortOrderInput | SortOrder
    position?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    bookVersion?: BookVersionOrderByWithRelationInput
  }

  export type ReadingProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_bookVersionId?: ReadingProgressUserIdBookVersionIdCompoundUniqueInput
    AND?: ReadingProgressWhereInput | ReadingProgressWhereInput[]
    OR?: ReadingProgressWhereInput[]
    NOT?: ReadingProgressWhereInput | ReadingProgressWhereInput[]
    userId?: StringFilter<"ReadingProgress"> | string
    bookVersionId?: StringFilter<"ReadingProgress"> | string
    chapterNumber?: IntNullableFilter<"ReadingProgress"> | number | null
    audioChapterNumber?: IntNullableFilter<"ReadingProgress"> | number | null
    position?: FloatFilter<"ReadingProgress"> | number
    updatedAt?: DateTimeFilter<"ReadingProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bookVersion?: XOR<BookVersionScalarRelationFilter, BookVersionWhereInput>
  }, "id" | "userId_bookVersionId">

  export type ReadingProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    bookVersionId?: SortOrder
    chapterNumber?: SortOrderInput | SortOrder
    audioChapterNumber?: SortOrderInput | SortOrder
    position?: SortOrder
    updatedAt?: SortOrder
    _count?: ReadingProgressCountOrderByAggregateInput
    _avg?: ReadingProgressAvgOrderByAggregateInput
    _max?: ReadingProgressMaxOrderByAggregateInput
    _min?: ReadingProgressMinOrderByAggregateInput
    _sum?: ReadingProgressSumOrderByAggregateInput
  }

  export type ReadingProgressScalarWhereWithAggregatesInput = {
    AND?: ReadingProgressScalarWhereWithAggregatesInput | ReadingProgressScalarWhereWithAggregatesInput[]
    OR?: ReadingProgressScalarWhereWithAggregatesInput[]
    NOT?: ReadingProgressScalarWhereWithAggregatesInput | ReadingProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReadingProgress"> | string
    userId?: StringWithAggregatesFilter<"ReadingProgress"> | string
    bookVersionId?: StringWithAggregatesFilter<"ReadingProgress"> | string
    chapterNumber?: IntNullableWithAggregatesFilter<"ReadingProgress"> | number | null
    audioChapterNumber?: IntNullableWithAggregatesFilter<"ReadingProgress"> | number | null
    position?: FloatWithAggregatesFilter<"ReadingProgress"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"ReadingProgress"> | Date | string
  }

  export type SeoWhereInput = {
    AND?: SeoWhereInput | SeoWhereInput[]
    OR?: SeoWhereInput[]
    NOT?: SeoWhereInput | SeoWhereInput[]
    id?: IntFilter<"Seo"> | number
    createdAt?: DateTimeFilter<"Seo"> | Date | string
    updatedAt?: DateTimeFilter<"Seo"> | Date | string
    metaTitle?: StringNullableFilter<"Seo"> | string | null
    metaDescription?: StringNullableFilter<"Seo"> | string | null
    canonicalUrl?: StringNullableFilter<"Seo"> | string | null
    robots?: StringNullableFilter<"Seo"> | string | null
    ogTitle?: StringNullableFilter<"Seo"> | string | null
    ogDescription?: StringNullableFilter<"Seo"> | string | null
    ogType?: StringNullableFilter<"Seo"> | string | null
    ogUrl?: StringNullableFilter<"Seo"> | string | null
    ogImageUrl?: StringNullableFilter<"Seo"> | string | null
    ogImageAlt?: StringNullableFilter<"Seo"> | string | null
    twitterCard?: StringNullableFilter<"Seo"> | string | null
    twitterSite?: StringNullableFilter<"Seo"> | string | null
    twitterCreator?: StringNullableFilter<"Seo"> | string | null
    eventName?: StringNullableFilter<"Seo"> | string | null
    eventDescription?: StringNullableFilter<"Seo"> | string | null
    eventStartDate?: DateTimeNullableFilter<"Seo"> | Date | string | null
    eventEndDate?: DateTimeNullableFilter<"Seo"> | Date | string | null
    eventUrl?: StringNullableFilter<"Seo"> | string | null
    eventImageUrl?: StringNullableFilter<"Seo"> | string | null
    eventLocationName?: StringNullableFilter<"Seo"> | string | null
    eventLocationStreet?: StringNullableFilter<"Seo"> | string | null
    eventLocationCity?: StringNullableFilter<"Seo"> | string | null
    eventLocationRegion?: StringNullableFilter<"Seo"> | string | null
    eventLocationPostal?: StringNullableFilter<"Seo"> | string | null
    eventLocationCountry?: StringNullableFilter<"Seo"> | string | null
    bookVersion?: XOR<BookVersionNullableScalarRelationFilter, BookVersionWhereInput> | null
  }

  export type SeoOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    canonicalUrl?: SortOrderInput | SortOrder
    robots?: SortOrderInput | SortOrder
    ogTitle?: SortOrderInput | SortOrder
    ogDescription?: SortOrderInput | SortOrder
    ogType?: SortOrderInput | SortOrder
    ogUrl?: SortOrderInput | SortOrder
    ogImageUrl?: SortOrderInput | SortOrder
    ogImageAlt?: SortOrderInput | SortOrder
    twitterCard?: SortOrderInput | SortOrder
    twitterSite?: SortOrderInput | SortOrder
    twitterCreator?: SortOrderInput | SortOrder
    eventName?: SortOrderInput | SortOrder
    eventDescription?: SortOrderInput | SortOrder
    eventStartDate?: SortOrderInput | SortOrder
    eventEndDate?: SortOrderInput | SortOrder
    eventUrl?: SortOrderInput | SortOrder
    eventImageUrl?: SortOrderInput | SortOrder
    eventLocationName?: SortOrderInput | SortOrder
    eventLocationStreet?: SortOrderInput | SortOrder
    eventLocationCity?: SortOrderInput | SortOrder
    eventLocationRegion?: SortOrderInput | SortOrder
    eventLocationPostal?: SortOrderInput | SortOrder
    eventLocationCountry?: SortOrderInput | SortOrder
    bookVersion?: BookVersionOrderByWithRelationInput
  }

  export type SeoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SeoWhereInput | SeoWhereInput[]
    OR?: SeoWhereInput[]
    NOT?: SeoWhereInput | SeoWhereInput[]
    createdAt?: DateTimeFilter<"Seo"> | Date | string
    updatedAt?: DateTimeFilter<"Seo"> | Date | string
    metaTitle?: StringNullableFilter<"Seo"> | string | null
    metaDescription?: StringNullableFilter<"Seo"> | string | null
    canonicalUrl?: StringNullableFilter<"Seo"> | string | null
    robots?: StringNullableFilter<"Seo"> | string | null
    ogTitle?: StringNullableFilter<"Seo"> | string | null
    ogDescription?: StringNullableFilter<"Seo"> | string | null
    ogType?: StringNullableFilter<"Seo"> | string | null
    ogUrl?: StringNullableFilter<"Seo"> | string | null
    ogImageUrl?: StringNullableFilter<"Seo"> | string | null
    ogImageAlt?: StringNullableFilter<"Seo"> | string | null
    twitterCard?: StringNullableFilter<"Seo"> | string | null
    twitterSite?: StringNullableFilter<"Seo"> | string | null
    twitterCreator?: StringNullableFilter<"Seo"> | string | null
    eventName?: StringNullableFilter<"Seo"> | string | null
    eventDescription?: StringNullableFilter<"Seo"> | string | null
    eventStartDate?: DateTimeNullableFilter<"Seo"> | Date | string | null
    eventEndDate?: DateTimeNullableFilter<"Seo"> | Date | string | null
    eventUrl?: StringNullableFilter<"Seo"> | string | null
    eventImageUrl?: StringNullableFilter<"Seo"> | string | null
    eventLocationName?: StringNullableFilter<"Seo"> | string | null
    eventLocationStreet?: StringNullableFilter<"Seo"> | string | null
    eventLocationCity?: StringNullableFilter<"Seo"> | string | null
    eventLocationRegion?: StringNullableFilter<"Seo"> | string | null
    eventLocationPostal?: StringNullableFilter<"Seo"> | string | null
    eventLocationCountry?: StringNullableFilter<"Seo"> | string | null
    bookVersion?: XOR<BookVersionNullableScalarRelationFilter, BookVersionWhereInput> | null
  }, "id">

  export type SeoOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    canonicalUrl?: SortOrderInput | SortOrder
    robots?: SortOrderInput | SortOrder
    ogTitle?: SortOrderInput | SortOrder
    ogDescription?: SortOrderInput | SortOrder
    ogType?: SortOrderInput | SortOrder
    ogUrl?: SortOrderInput | SortOrder
    ogImageUrl?: SortOrderInput | SortOrder
    ogImageAlt?: SortOrderInput | SortOrder
    twitterCard?: SortOrderInput | SortOrder
    twitterSite?: SortOrderInput | SortOrder
    twitterCreator?: SortOrderInput | SortOrder
    eventName?: SortOrderInput | SortOrder
    eventDescription?: SortOrderInput | SortOrder
    eventStartDate?: SortOrderInput | SortOrder
    eventEndDate?: SortOrderInput | SortOrder
    eventUrl?: SortOrderInput | SortOrder
    eventImageUrl?: SortOrderInput | SortOrder
    eventLocationName?: SortOrderInput | SortOrder
    eventLocationStreet?: SortOrderInput | SortOrder
    eventLocationCity?: SortOrderInput | SortOrder
    eventLocationRegion?: SortOrderInput | SortOrder
    eventLocationPostal?: SortOrderInput | SortOrder
    eventLocationCountry?: SortOrderInput | SortOrder
    _count?: SeoCountOrderByAggregateInput
    _avg?: SeoAvgOrderByAggregateInput
    _max?: SeoMaxOrderByAggregateInput
    _min?: SeoMinOrderByAggregateInput
    _sum?: SeoSumOrderByAggregateInput
  }

  export type SeoScalarWhereWithAggregatesInput = {
    AND?: SeoScalarWhereWithAggregatesInput | SeoScalarWhereWithAggregatesInput[]
    OR?: SeoScalarWhereWithAggregatesInput[]
    NOT?: SeoScalarWhereWithAggregatesInput | SeoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Seo"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Seo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Seo"> | Date | string
    metaTitle?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    canonicalUrl?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    robots?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    ogTitle?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    ogDescription?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    ogType?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    ogUrl?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    ogImageUrl?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    ogImageAlt?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    twitterCard?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    twitterSite?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    twitterCreator?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    eventName?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    eventDescription?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    eventStartDate?: DateTimeNullableWithAggregatesFilter<"Seo"> | Date | string | null
    eventEndDate?: DateTimeNullableWithAggregatesFilter<"Seo"> | Date | string | null
    eventUrl?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    eventImageUrl?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    eventLocationName?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    eventLocationStreet?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    eventLocationCity?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    eventLocationRegion?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    eventLocationPostal?: StringNullableWithAggregatesFilter<"Seo"> | string | null
    eventLocationCountry?: StringNullableWithAggregatesFilter<"Seo"> | string | null
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    name?: EnumRoleNameFilter<"Role"> | $Enums.RoleName
    users?: UserRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    users?: UserRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: $Enums.RoleName
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    users?: UserRoleListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    name?: EnumRoleNameWithAggregatesFilter<"Role"> | $Enums.RoleName
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: IntFilter<"UserRole"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    user?: UserOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: IntFilter<"UserRole"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "userId_roleId">

  export type UserRoleOrderByWithAggregationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _avg?: UserRoleAvgOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
    _sum?: UserRoleSumOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserRole"> | string
    roleId?: IntWithAggregatesFilter<"UserRole"> | number
  }

  export type BookCreateInput = {
    id?: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: BookVersionCreateNestedManyWithoutBookInput
  }

  export type BookUncheckedCreateInput = {
    id?: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: BookVersionUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: BookVersionUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: BookVersionUncheckedUpdateManyWithoutBookNestedInput
  }

  export type BookCreateManyInput = {
    id?: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookVersionCreateInput = {
    id?: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    book: BookCreateNestedOneWithoutVersionsInput
    summaries?: BookSummaryCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfCreateNestedManyWithoutBookVersionInput
    comments?: CommentCreateNestedManyWithoutBookVersionInput
    likes?: LikeCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryCreateNestedManyWithoutBookVersionInput
    tags?: BookTagCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressCreateNestedManyWithoutBookVersionInput
    seo?: SeoCreateNestedOneWithoutBookVersionInput
  }

  export type BookVersionUncheckedCreateInput = {
    id?: string
    bookId: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seoId?: number | null
    summaries?: BookSummaryUncheckedCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterUncheckedCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfUncheckedCreateNestedManyWithoutBookVersionInput
    comments?: CommentUncheckedCreateNestedManyWithoutBookVersionInput
    likes?: LikeUncheckedCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryUncheckedCreateNestedManyWithoutBookVersionInput
    tags?: BookTagUncheckedCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatUncheckedCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressUncheckedCreateNestedManyWithoutBookVersionInput
  }

  export type BookVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BookUpdateOneRequiredWithoutVersionsNestedInput
    summaries?: BookSummaryUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUpdateManyWithoutBookVersionNestedInput
    seo?: SeoUpdateOneWithoutBookVersionNestedInput
  }

  export type BookVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seoId?: NullableIntFieldUpdateOperationsInput | number | null
    summaries?: BookSummaryUncheckedUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUncheckedUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUncheckedUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUncheckedUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUncheckedUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUncheckedUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUncheckedUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUncheckedUpdateManyWithoutBookVersionNestedInput
  }

  export type BookVersionCreateManyInput = {
    id?: string
    bookId: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seoId?: number | null
  }

  export type BookVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BookSummaryCreateInput = {
    id?: string
    summary: string
    analysis?: string | null
    themes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookVersion: BookVersionCreateNestedOneWithoutSummariesInput
  }

  export type BookSummaryUncheckedCreateInput = {
    id?: string
    bookVersionId: string
    summary: string
    analysis?: string | null
    themes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookSummaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    analysis?: NullableStringFieldUpdateOperationsInput | string | null
    themes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookVersion?: BookVersionUpdateOneRequiredWithoutSummariesNestedInput
  }

  export type BookSummaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    analysis?: NullableStringFieldUpdateOperationsInput | string | null
    themes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookSummaryCreateManyInput = {
    id?: string
    bookVersionId: string
    summary: string
    analysis?: string | null
    themes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookSummaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    analysis?: NullableStringFieldUpdateOperationsInput | string | null
    themes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookSummaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    analysis?: NullableStringFieldUpdateOperationsInput | string | null
    themes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterCreateInput = {
    id?: string
    number: number
    title: string
    content: string
    createdAt?: Date | string
    bookVersion: BookVersionCreateNestedOneWithoutChaptersInput
    comments?: CommentCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateInput = {
    id?: string
    bookVersionId: string
    number: number
    title: string
    content: string
    createdAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookVersion?: BookVersionUpdateOneRequiredWithoutChaptersNestedInput
    comments?: CommentUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ChapterCreateManyInput = {
    id?: string
    bookVersionId: string
    number: number
    title: string
    content: string
    createdAt?: Date | string
  }

  export type ChapterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioChapterCreateInput = {
    id?: string
    number: number
    title: string
    audioUrl: string
    duration: number
    createdAt?: Date | string
    bookVersion: BookVersionCreateNestedOneWithoutAudioChaptersInput
    comments?: CommentCreateNestedManyWithoutAudioChapterInput
  }

  export type AudioChapterUncheckedCreateInput = {
    id?: string
    bookVersionId: string
    number: number
    title: string
    audioUrl: string
    duration: number
    createdAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutAudioChapterInput
  }

  export type AudioChapterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookVersion?: BookVersionUpdateOneRequiredWithoutAudioChaptersNestedInput
    comments?: CommentUpdateManyWithoutAudioChapterNestedInput
  }

  export type AudioChapterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutAudioChapterNestedInput
  }

  export type AudioChapterCreateManyInput = {
    id?: string
    bookVersionId: string
    number: number
    title: string
    audioUrl: string
    duration: number
    createdAt?: Date | string
  }

  export type AudioChapterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioChapterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    languagePreference: $Enums.Language
    createdAt?: Date | string
    lastLogin?: Date | string | null
    bookshelves?: BookshelfCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    viewStats?: ViewStatCreateNestedManyWithoutUserInput
    readingProgress?: ReadingProgressCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    languagePreference: $Enums.Language
    createdAt?: Date | string
    lastLogin?: Date | string | null
    bookshelves?: BookshelfUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    viewStats?: ViewStatUncheckedCreateNestedManyWithoutUserInput
    readingProgress?: ReadingProgressUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookshelves?: BookshelfUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    viewStats?: ViewStatUpdateManyWithoutUserNestedInput
    readingProgress?: ReadingProgressUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookshelves?: BookshelfUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    viewStats?: ViewStatUncheckedUpdateManyWithoutUserNestedInput
    readingProgress?: ReadingProgressUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    languagePreference: $Enums.Language
    createdAt?: Date | string
    lastLogin?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookshelfCreateInput = {
    id?: string
    addedAt?: Date | string
    user: UserCreateNestedOneWithoutBookshelvesInput
    bookVersion: BookVersionCreateNestedOneWithoutBookshelfInput
  }

  export type BookshelfUncheckedCreateInput = {
    id?: string
    userId: string
    bookVersionId: string
    addedAt?: Date | string
  }

  export type BookshelfUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookshelvesNestedInput
    bookVersion?: BookVersionUpdateOneRequiredWithoutBookshelfNestedInput
  }

  export type BookshelfUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookshelfCreateManyInput = {
    id?: string
    userId: string
    bookVersionId: string
    addedAt?: Date | string
  }

  export type BookshelfUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookshelfUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    bookVersion?: BookVersionCreateNestedOneWithoutCommentsInput
    chapter?: ChapterCreateNestedOneWithoutCommentsInput
    audioChapter?: AudioChapterCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutChildrenInput
    children?: CommentCreateNestedManyWithoutParentInput
    likes?: LikeCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    userId: string
    bookVersionId?: string | null
    chapterId?: string | null
    audioChapterId?: string | null
    parentId?: string | null
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
    likes?: LikeUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    bookVersion?: BookVersionUpdateOneWithoutCommentsNestedInput
    chapter?: ChapterUpdateOneWithoutCommentsNestedInput
    audioChapter?: AudioChapterUpdateOneWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
    likes?: LikeUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    audioChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
    likes?: LikeUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    userId: string
    bookVersionId?: string | null
    chapterId?: string | null
    audioChapterId?: string | null
    parentId?: string | null
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    audioChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLikesInput
    bookVersion?: BookVersionCreateNestedOneWithoutLikesInput
    comment?: CommentCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateInput = {
    id?: string
    userId: string
    bookVersionId?: string | null
    commentId?: string | null
    createdAt?: Date | string
  }

  export type LikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikesNestedInput
    bookVersion?: BookVersionUpdateOneWithoutLikesNestedInput
    comment?: CommentUpdateOneWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateManyInput = {
    id?: string
    userId: string
    bookVersionId?: string | null
    commentId?: string | null
    createdAt?: Date | string
  }

  export type LikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    type: $Enums.CategoryType
    name: string
    slug: string
    books?: BookCategoryCreateNestedManyWithoutCategoryInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    type: $Enums.CategoryType
    name: string
    slug: string
    parentId?: string | null
    books?: BookCategoryUncheckedCreateNestedManyWithoutCategoryInput
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    books?: BookCategoryUpdateManyWithoutCategoryNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    books?: BookCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    type: $Enums.CategoryType
    name: string
    slug: string
    parentId?: string | null
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookCategoryCreateInput = {
    id?: string
    bookVersion: BookVersionCreateNestedOneWithoutCategoriesInput
    category: CategoryCreateNestedOneWithoutBooksInput
  }

  export type BookCategoryUncheckedCreateInput = {
    id?: string
    bookVersionId: string
    categoryId: string
  }

  export type BookCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersion?: BookVersionUpdateOneRequiredWithoutCategoriesNestedInput
    category?: CategoryUpdateOneRequiredWithoutBooksNestedInput
  }

  export type BookCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type BookCategoryCreateManyInput = {
    id?: string
    bookVersionId: string
    categoryId: string
  }

  export type BookCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type BookCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    slug: string
    books?: BookTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    books?: BookTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    books?: BookTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    books?: BookTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    slug: string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type BookTagCreateInput = {
    id?: string
    bookVersion: BookVersionCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutBooksInput
  }

  export type BookTagUncheckedCreateInput = {
    id?: string
    bookVersionId: string
    tagId: string
  }

  export type BookTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersion?: BookVersionUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutBooksNestedInput
  }

  export type BookTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type BookTagCreateManyInput = {
    id?: string
    bookVersionId: string
    tagId: string
  }

  export type BookTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type BookTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ViewStatCreateInput = {
    id?: string
    source: $Enums.ViewSource
    timestamp?: Date | string
    bookVersion: BookVersionCreateNestedOneWithoutViewStatsInput
    user?: UserCreateNestedOneWithoutViewStatsInput
  }

  export type ViewStatUncheckedCreateInput = {
    id?: string
    bookVersionId: string
    userId?: string | null
    source: $Enums.ViewSource
    timestamp?: Date | string
  }

  export type ViewStatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumViewSourceFieldUpdateOperationsInput | $Enums.ViewSource
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    bookVersion?: BookVersionUpdateOneRequiredWithoutViewStatsNestedInput
    user?: UserUpdateOneWithoutViewStatsNestedInput
  }

  export type ViewStatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumViewSourceFieldUpdateOperationsInput | $Enums.ViewSource
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewStatCreateManyInput = {
    id?: string
    bookVersionId: string
    userId?: string | null
    source: $Enums.ViewSource
    timestamp?: Date | string
  }

  export type ViewStatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumViewSourceFieldUpdateOperationsInput | $Enums.ViewSource
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewStatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumViewSourceFieldUpdateOperationsInput | $Enums.ViewSource
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingProgressCreateInput = {
    id?: string
    chapterNumber?: number | null
    audioChapterNumber?: number | null
    position: number
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReadingProgressInput
    bookVersion: BookVersionCreateNestedOneWithoutReadingProgressInput
  }

  export type ReadingProgressUncheckedCreateInput = {
    id?: string
    userId: string
    bookVersionId: string
    chapterNumber?: number | null
    audioChapterNumber?: number | null
    position: number
    updatedAt?: Date | string
  }

  export type ReadingProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterNumber?: NullableIntFieldUpdateOperationsInput | number | null
    audioChapterNumber?: NullableIntFieldUpdateOperationsInput | number | null
    position?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReadingProgressNestedInput
    bookVersion?: BookVersionUpdateOneRequiredWithoutReadingProgressNestedInput
  }

  export type ReadingProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    chapterNumber?: NullableIntFieldUpdateOperationsInput | number | null
    audioChapterNumber?: NullableIntFieldUpdateOperationsInput | number | null
    position?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingProgressCreateManyInput = {
    id?: string
    userId: string
    bookVersionId: string
    chapterNumber?: number | null
    audioChapterNumber?: number | null
    position: number
    updatedAt?: Date | string
  }

  export type ReadingProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterNumber?: NullableIntFieldUpdateOperationsInput | number | null
    audioChapterNumber?: NullableIntFieldUpdateOperationsInput | number | null
    position?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    chapterNumber?: NullableIntFieldUpdateOperationsInput | number | null
    audioChapterNumber?: NullableIntFieldUpdateOperationsInput | number | null
    position?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeoCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    metaTitle?: string | null
    metaDescription?: string | null
    canonicalUrl?: string | null
    robots?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogType?: string | null
    ogUrl?: string | null
    ogImageUrl?: string | null
    ogImageAlt?: string | null
    twitterCard?: string | null
    twitterSite?: string | null
    twitterCreator?: string | null
    eventName?: string | null
    eventDescription?: string | null
    eventStartDate?: Date | string | null
    eventEndDate?: Date | string | null
    eventUrl?: string | null
    eventImageUrl?: string | null
    eventLocationName?: string | null
    eventLocationStreet?: string | null
    eventLocationCity?: string | null
    eventLocationRegion?: string | null
    eventLocationPostal?: string | null
    eventLocationCountry?: string | null
    bookVersion?: BookVersionCreateNestedOneWithoutSeoInput
  }

  export type SeoUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    metaTitle?: string | null
    metaDescription?: string | null
    canonicalUrl?: string | null
    robots?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogType?: string | null
    ogUrl?: string | null
    ogImageUrl?: string | null
    ogImageAlt?: string | null
    twitterCard?: string | null
    twitterSite?: string | null
    twitterCreator?: string | null
    eventName?: string | null
    eventDescription?: string | null
    eventStartDate?: Date | string | null
    eventEndDate?: Date | string | null
    eventUrl?: string | null
    eventImageUrl?: string | null
    eventLocationName?: string | null
    eventLocationStreet?: string | null
    eventLocationCity?: string | null
    eventLocationRegion?: string | null
    eventLocationPostal?: string | null
    eventLocationCountry?: string | null
    bookVersion?: BookVersionUncheckedCreateNestedOneWithoutSeoInput
  }

  export type SeoUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    robots?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogType?: NullableStringFieldUpdateOperationsInput | string | null
    ogUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCard?: NullableStringFieldUpdateOperationsInput | string | null
    twitterSite?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCreator?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    eventStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationName?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationStreet?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationCity?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationRegion?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationPostal?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationCountry?: NullableStringFieldUpdateOperationsInput | string | null
    bookVersion?: BookVersionUpdateOneWithoutSeoNestedInput
  }

  export type SeoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    robots?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogType?: NullableStringFieldUpdateOperationsInput | string | null
    ogUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCard?: NullableStringFieldUpdateOperationsInput | string | null
    twitterSite?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCreator?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    eventStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationName?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationStreet?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationCity?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationRegion?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationPostal?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationCountry?: NullableStringFieldUpdateOperationsInput | string | null
    bookVersion?: BookVersionUncheckedUpdateOneWithoutSeoNestedInput
  }

  export type SeoCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    metaTitle?: string | null
    metaDescription?: string | null
    canonicalUrl?: string | null
    robots?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogType?: string | null
    ogUrl?: string | null
    ogImageUrl?: string | null
    ogImageAlt?: string | null
    twitterCard?: string | null
    twitterSite?: string | null
    twitterCreator?: string | null
    eventName?: string | null
    eventDescription?: string | null
    eventStartDate?: Date | string | null
    eventEndDate?: Date | string | null
    eventUrl?: string | null
    eventImageUrl?: string | null
    eventLocationName?: string | null
    eventLocationStreet?: string | null
    eventLocationCity?: string | null
    eventLocationRegion?: string | null
    eventLocationPostal?: string | null
    eventLocationCountry?: string | null
  }

  export type SeoUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    robots?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogType?: NullableStringFieldUpdateOperationsInput | string | null
    ogUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCard?: NullableStringFieldUpdateOperationsInput | string | null
    twitterSite?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCreator?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    eventStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationName?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationStreet?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationCity?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationRegion?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationPostal?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationCountry?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    robots?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogType?: NullableStringFieldUpdateOperationsInput | string | null
    ogUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCard?: NullableStringFieldUpdateOperationsInput | string | null
    twitterSite?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCreator?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    eventStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationName?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationStreet?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationCity?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationRegion?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationPostal?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationCountry?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleCreateInput = {
    name: $Enums.RoleName
    users?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    name: $Enums.RoleName
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    users?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    name: $Enums.RoleName
  }

  export type RoleUpdateManyMutationInput = {
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
  }

  export type UserRoleCreateInput = {
    user: UserCreateNestedOneWithoutRolesInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserRoleUncheckedCreateInput = {
    userId: string
    roleId: number
  }

  export type UserRoleUpdateInput = {
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleCreateManyInput = {
    userId: string
    roleId: number
  }

  export type UserRoleUpdateManyMutationInput = {

  }

  export type UserRoleUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BookVersionListRelationFilter = {
    every?: BookVersionWhereInput
    some?: BookVersionWhereInput
    none?: BookVersionWhereInput
  }

  export type BookVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumLanguageFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageFilter<$PrismaModel> | $Enums.Language
  }

  export type EnumBookTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BookType | EnumBookTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookType[] | ListEnumBookTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookType[] | ListEnumBookTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookTypeFilter<$PrismaModel> | $Enums.BookType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumPublicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PublicationStatus | EnumPublicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublicationStatusFilter<$PrismaModel> | $Enums.PublicationStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BookScalarRelationFilter = {
    is?: BookWhereInput
    isNot?: BookWhereInput
  }

  export type BookSummaryListRelationFilter = {
    every?: BookSummaryWhereInput
    some?: BookSummaryWhereInput
    none?: BookSummaryWhereInput
  }

  export type ChapterListRelationFilter = {
    every?: ChapterWhereInput
    some?: ChapterWhereInput
    none?: ChapterWhereInput
  }

  export type AudioChapterListRelationFilter = {
    every?: AudioChapterWhereInput
    some?: AudioChapterWhereInput
    none?: AudioChapterWhereInput
  }

  export type BookshelfListRelationFilter = {
    every?: BookshelfWhereInput
    some?: BookshelfWhereInput
    none?: BookshelfWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type LikeListRelationFilter = {
    every?: LikeWhereInput
    some?: LikeWhereInput
    none?: LikeWhereInput
  }

  export type BookCategoryListRelationFilter = {
    every?: BookCategoryWhereInput
    some?: BookCategoryWhereInput
    none?: BookCategoryWhereInput
  }

  export type BookTagListRelationFilter = {
    every?: BookTagWhereInput
    some?: BookTagWhereInput
    none?: BookTagWhereInput
  }

  export type ViewStatListRelationFilter = {
    every?: ViewStatWhereInput
    some?: ViewStatWhereInput
    none?: ViewStatWhereInput
  }

  export type ReadingProgressListRelationFilter = {
    every?: ReadingProgressWhereInput
    some?: ReadingProgressWhereInput
    none?: ReadingProgressWhereInput
  }

  export type SeoNullableScalarRelationFilter = {
    is?: SeoWhereInput | null
    isNot?: SeoWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BookSummaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChapterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AudioChapterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookshelfOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ViewStatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReadingProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookVersionBookIdLanguageCompoundUniqueInput = {
    bookId: string
    language: $Enums.Language
  }

  export type BookVersionCountOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    author?: SortOrder
    description?: SortOrder
    coverImageUrl?: SortOrder
    type?: SortOrder
    isFree?: SortOrder
    referralUrl?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seoId?: SortOrder
  }

  export type BookVersionAvgOrderByAggregateInput = {
    seoId?: SortOrder
  }

  export type BookVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    author?: SortOrder
    description?: SortOrder
    coverImageUrl?: SortOrder
    type?: SortOrder
    isFree?: SortOrder
    referralUrl?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seoId?: SortOrder
  }

  export type BookVersionMinOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    author?: SortOrder
    description?: SortOrder
    coverImageUrl?: SortOrder
    type?: SortOrder
    isFree?: SortOrder
    referralUrl?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seoId?: SortOrder
  }

  export type BookVersionSumOrderByAggregateInput = {
    seoId?: SortOrder
  }

  export type EnumLanguageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageWithAggregatesFilter<$PrismaModel> | $Enums.Language
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLanguageFilter<$PrismaModel>
    _max?: NestedEnumLanguageFilter<$PrismaModel>
  }

  export type EnumBookTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookType | EnumBookTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookType[] | ListEnumBookTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookType[] | ListEnumBookTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookTypeWithAggregatesFilter<$PrismaModel> | $Enums.BookType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookTypeFilter<$PrismaModel>
    _max?: NestedEnumBookTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumPublicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PublicationStatus | EnumPublicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.PublicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPublicationStatusFilter<$PrismaModel>
    _max?: NestedEnumPublicationStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BookVersionScalarRelationFilter = {
    is?: BookVersionWhereInput
    isNot?: BookVersionWhereInput
  }

  export type BookSummaryCountOrderByAggregateInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    summary?: SortOrder
    analysis?: SortOrder
    themes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookSummaryMaxOrderByAggregateInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    summary?: SortOrder
    analysis?: SortOrder
    themes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookSummaryMinOrderByAggregateInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    summary?: SortOrder
    analysis?: SortOrder
    themes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ChapterBookVersionIdNumberCompoundUniqueInput = {
    bookVersionId: string
    number: number
  }

  export type ChapterCountOrderByAggregateInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    number?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type ChapterAvgOrderByAggregateInput = {
    number?: SortOrder
  }

  export type ChapterMaxOrderByAggregateInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    number?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type ChapterMinOrderByAggregateInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    number?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type ChapterSumOrderByAggregateInput = {
    number?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type AudioChapterBookVersionIdNumberCompoundUniqueInput = {
    bookVersionId: string
    number: number
  }

  export type AudioChapterCountOrderByAggregateInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    number?: SortOrder
    title?: SortOrder
    audioUrl?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type AudioChapterAvgOrderByAggregateInput = {
    number?: SortOrder
    duration?: SortOrder
  }

  export type AudioChapterMaxOrderByAggregateInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    number?: SortOrder
    title?: SortOrder
    audioUrl?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type AudioChapterMinOrderByAggregateInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    number?: SortOrder
    title?: SortOrder
    audioUrl?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type AudioChapterSumOrderByAggregateInput = {
    number?: SortOrder
    duration?: SortOrder
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    languagePreference?: SortOrder
    createdAt?: SortOrder
    lastLogin?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    languagePreference?: SortOrder
    createdAt?: SortOrder
    lastLogin?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    languagePreference?: SortOrder
    createdAt?: SortOrder
    lastLogin?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BookshelfUserIdBookVersionIdCompoundUniqueInput = {
    userId: string
    bookVersionId: string
  }

  export type BookshelfCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookVersionId?: SortOrder
    addedAt?: SortOrder
  }

  export type BookshelfMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookVersionId?: SortOrder
    addedAt?: SortOrder
  }

  export type BookshelfMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookVersionId?: SortOrder
    addedAt?: SortOrder
  }

  export type BookVersionNullableScalarRelationFilter = {
    is?: BookVersionWhereInput | null
    isNot?: BookVersionWhereInput | null
  }

  export type ChapterNullableScalarRelationFilter = {
    is?: ChapterWhereInput | null
    isNot?: ChapterWhereInput | null
  }

  export type AudioChapterNullableScalarRelationFilter = {
    is?: AudioChapterWhereInput | null
    isNot?: AudioChapterWhereInput | null
  }

  export type CommentNullableScalarRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookVersionId?: SortOrder
    chapterId?: SortOrder
    audioChapterId?: SortOrder
    parentId?: SortOrder
    text?: SortOrder
    isDeleted?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookVersionId?: SortOrder
    chapterId?: SortOrder
    audioChapterId?: SortOrder
    parentId?: SortOrder
    text?: SortOrder
    isDeleted?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookVersionId?: SortOrder
    chapterId?: SortOrder
    audioChapterId?: SortOrder
    parentId?: SortOrder
    text?: SortOrder
    isDeleted?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LikeUserIdCommentIdCompoundUniqueInput = {
    userId: string
    commentId: string
  }

  export type LikeUserIdBookVersionIdCompoundUniqueInput = {
    userId: string
    bookVersionId: string
  }

  export type LikeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookVersionId?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookVersionId?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookVersionId?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCategoryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryType | EnumCategoryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryTypeFilter<$PrismaModel> | $Enums.CategoryType
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    parentId?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    parentId?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    parentId?: SortOrder
  }

  export type EnumCategoryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryType | EnumCategoryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryTypeWithAggregatesFilter<$PrismaModel> | $Enums.CategoryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryTypeFilter<$PrismaModel>
    _max?: NestedEnumCategoryTypeFilter<$PrismaModel>
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type BookCategoryBookVersionIdCategoryIdCompoundUniqueInput = {
    bookVersionId: string
    categoryId: string
  }

  export type BookCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    categoryId?: SortOrder
  }

  export type BookCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    categoryId?: SortOrder
  }

  export type BookCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    categoryId?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type BookTagBookVersionIdTagIdCompoundUniqueInput = {
    bookVersionId: string
    tagId: string
  }

  export type BookTagCountOrderByAggregateInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    tagId?: SortOrder
  }

  export type BookTagMaxOrderByAggregateInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    tagId?: SortOrder
  }

  export type BookTagMinOrderByAggregateInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    tagId?: SortOrder
  }

  export type EnumViewSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.ViewSource | EnumViewSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ViewSource[] | ListEnumViewSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ViewSource[] | ListEnumViewSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumViewSourceFilter<$PrismaModel> | $Enums.ViewSource
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ViewStatCountOrderByAggregateInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    userId?: SortOrder
    source?: SortOrder
    timestamp?: SortOrder
  }

  export type ViewStatMaxOrderByAggregateInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    userId?: SortOrder
    source?: SortOrder
    timestamp?: SortOrder
  }

  export type ViewStatMinOrderByAggregateInput = {
    id?: SortOrder
    bookVersionId?: SortOrder
    userId?: SortOrder
    source?: SortOrder
    timestamp?: SortOrder
  }

  export type EnumViewSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ViewSource | EnumViewSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ViewSource[] | ListEnumViewSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ViewSource[] | ListEnumViewSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumViewSourceWithAggregatesFilter<$PrismaModel> | $Enums.ViewSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumViewSourceFilter<$PrismaModel>
    _max?: NestedEnumViewSourceFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ReadingProgressUserIdBookVersionIdCompoundUniqueInput = {
    userId: string
    bookVersionId: string
  }

  export type ReadingProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookVersionId?: SortOrder
    chapterNumber?: SortOrder
    audioChapterNumber?: SortOrder
    position?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReadingProgressAvgOrderByAggregateInput = {
    chapterNumber?: SortOrder
    audioChapterNumber?: SortOrder
    position?: SortOrder
  }

  export type ReadingProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookVersionId?: SortOrder
    chapterNumber?: SortOrder
    audioChapterNumber?: SortOrder
    position?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReadingProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookVersionId?: SortOrder
    chapterNumber?: SortOrder
    audioChapterNumber?: SortOrder
    position?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReadingProgressSumOrderByAggregateInput = {
    chapterNumber?: SortOrder
    audioChapterNumber?: SortOrder
    position?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type SeoCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    canonicalUrl?: SortOrder
    robots?: SortOrder
    ogTitle?: SortOrder
    ogDescription?: SortOrder
    ogType?: SortOrder
    ogUrl?: SortOrder
    ogImageUrl?: SortOrder
    ogImageAlt?: SortOrder
    twitterCard?: SortOrder
    twitterSite?: SortOrder
    twitterCreator?: SortOrder
    eventName?: SortOrder
    eventDescription?: SortOrder
    eventStartDate?: SortOrder
    eventEndDate?: SortOrder
    eventUrl?: SortOrder
    eventImageUrl?: SortOrder
    eventLocationName?: SortOrder
    eventLocationStreet?: SortOrder
    eventLocationCity?: SortOrder
    eventLocationRegion?: SortOrder
    eventLocationPostal?: SortOrder
    eventLocationCountry?: SortOrder
  }

  export type SeoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SeoMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    canonicalUrl?: SortOrder
    robots?: SortOrder
    ogTitle?: SortOrder
    ogDescription?: SortOrder
    ogType?: SortOrder
    ogUrl?: SortOrder
    ogImageUrl?: SortOrder
    ogImageAlt?: SortOrder
    twitterCard?: SortOrder
    twitterSite?: SortOrder
    twitterCreator?: SortOrder
    eventName?: SortOrder
    eventDescription?: SortOrder
    eventStartDate?: SortOrder
    eventEndDate?: SortOrder
    eventUrl?: SortOrder
    eventImageUrl?: SortOrder
    eventLocationName?: SortOrder
    eventLocationStreet?: SortOrder
    eventLocationCity?: SortOrder
    eventLocationRegion?: SortOrder
    eventLocationPostal?: SortOrder
    eventLocationCountry?: SortOrder
  }

  export type SeoMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    canonicalUrl?: SortOrder
    robots?: SortOrder
    ogTitle?: SortOrder
    ogDescription?: SortOrder
    ogType?: SortOrder
    ogUrl?: SortOrder
    ogImageUrl?: SortOrder
    ogImageAlt?: SortOrder
    twitterCard?: SortOrder
    twitterSite?: SortOrder
    twitterCreator?: SortOrder
    eventName?: SortOrder
    eventDescription?: SortOrder
    eventStartDate?: SortOrder
    eventEndDate?: SortOrder
    eventUrl?: SortOrder
    eventImageUrl?: SortOrder
    eventLocationName?: SortOrder
    eventLocationStreet?: SortOrder
    eventLocationCity?: SortOrder
    eventLocationRegion?: SortOrder
    eventLocationPostal?: SortOrder
    eventLocationCountry?: SortOrder
  }

  export type SeoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumRoleNameFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameFilter<$PrismaModel> | $Enums.RoleName
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumRoleNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameWithAggregatesFilter<$PrismaModel> | $Enums.RoleName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleNameFilter<$PrismaModel>
    _max?: NestedEnumRoleNameFilter<$PrismaModel>
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: number
  }

  export type UserRoleCountOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleAvgOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleSumOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type BookVersionCreateNestedManyWithoutBookInput = {
    create?: XOR<BookVersionCreateWithoutBookInput, BookVersionUncheckedCreateWithoutBookInput> | BookVersionCreateWithoutBookInput[] | BookVersionUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BookVersionCreateOrConnectWithoutBookInput | BookVersionCreateOrConnectWithoutBookInput[]
    createMany?: BookVersionCreateManyBookInputEnvelope
    connect?: BookVersionWhereUniqueInput | BookVersionWhereUniqueInput[]
  }

  export type BookVersionUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<BookVersionCreateWithoutBookInput, BookVersionUncheckedCreateWithoutBookInput> | BookVersionCreateWithoutBookInput[] | BookVersionUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BookVersionCreateOrConnectWithoutBookInput | BookVersionCreateOrConnectWithoutBookInput[]
    createMany?: BookVersionCreateManyBookInputEnvelope
    connect?: BookVersionWhereUniqueInput | BookVersionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BookVersionUpdateManyWithoutBookNestedInput = {
    create?: XOR<BookVersionCreateWithoutBookInput, BookVersionUncheckedCreateWithoutBookInput> | BookVersionCreateWithoutBookInput[] | BookVersionUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BookVersionCreateOrConnectWithoutBookInput | BookVersionCreateOrConnectWithoutBookInput[]
    upsert?: BookVersionUpsertWithWhereUniqueWithoutBookInput | BookVersionUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: BookVersionCreateManyBookInputEnvelope
    set?: BookVersionWhereUniqueInput | BookVersionWhereUniqueInput[]
    disconnect?: BookVersionWhereUniqueInput | BookVersionWhereUniqueInput[]
    delete?: BookVersionWhereUniqueInput | BookVersionWhereUniqueInput[]
    connect?: BookVersionWhereUniqueInput | BookVersionWhereUniqueInput[]
    update?: BookVersionUpdateWithWhereUniqueWithoutBookInput | BookVersionUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: BookVersionUpdateManyWithWhereWithoutBookInput | BookVersionUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: BookVersionScalarWhereInput | BookVersionScalarWhereInput[]
  }

  export type BookVersionUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<BookVersionCreateWithoutBookInput, BookVersionUncheckedCreateWithoutBookInput> | BookVersionCreateWithoutBookInput[] | BookVersionUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BookVersionCreateOrConnectWithoutBookInput | BookVersionCreateOrConnectWithoutBookInput[]
    upsert?: BookVersionUpsertWithWhereUniqueWithoutBookInput | BookVersionUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: BookVersionCreateManyBookInputEnvelope
    set?: BookVersionWhereUniqueInput | BookVersionWhereUniqueInput[]
    disconnect?: BookVersionWhereUniqueInput | BookVersionWhereUniqueInput[]
    delete?: BookVersionWhereUniqueInput | BookVersionWhereUniqueInput[]
    connect?: BookVersionWhereUniqueInput | BookVersionWhereUniqueInput[]
    update?: BookVersionUpdateWithWhereUniqueWithoutBookInput | BookVersionUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: BookVersionUpdateManyWithWhereWithoutBookInput | BookVersionUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: BookVersionScalarWhereInput | BookVersionScalarWhereInput[]
  }

  export type BookCreateNestedOneWithoutVersionsInput = {
    create?: XOR<BookCreateWithoutVersionsInput, BookUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: BookCreateOrConnectWithoutVersionsInput
    connect?: BookWhereUniqueInput
  }

  export type BookSummaryCreateNestedManyWithoutBookVersionInput = {
    create?: XOR<BookSummaryCreateWithoutBookVersionInput, BookSummaryUncheckedCreateWithoutBookVersionInput> | BookSummaryCreateWithoutBookVersionInput[] | BookSummaryUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: BookSummaryCreateOrConnectWithoutBookVersionInput | BookSummaryCreateOrConnectWithoutBookVersionInput[]
    createMany?: BookSummaryCreateManyBookVersionInputEnvelope
    connect?: BookSummaryWhereUniqueInput | BookSummaryWhereUniqueInput[]
  }

  export type ChapterCreateNestedManyWithoutBookVersionInput = {
    create?: XOR<ChapterCreateWithoutBookVersionInput, ChapterUncheckedCreateWithoutBookVersionInput> | ChapterCreateWithoutBookVersionInput[] | ChapterUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutBookVersionInput | ChapterCreateOrConnectWithoutBookVersionInput[]
    createMany?: ChapterCreateManyBookVersionInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type AudioChapterCreateNestedManyWithoutBookVersionInput = {
    create?: XOR<AudioChapterCreateWithoutBookVersionInput, AudioChapterUncheckedCreateWithoutBookVersionInput> | AudioChapterCreateWithoutBookVersionInput[] | AudioChapterUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: AudioChapterCreateOrConnectWithoutBookVersionInput | AudioChapterCreateOrConnectWithoutBookVersionInput[]
    createMany?: AudioChapterCreateManyBookVersionInputEnvelope
    connect?: AudioChapterWhereUniqueInput | AudioChapterWhereUniqueInput[]
  }

  export type BookshelfCreateNestedManyWithoutBookVersionInput = {
    create?: XOR<BookshelfCreateWithoutBookVersionInput, BookshelfUncheckedCreateWithoutBookVersionInput> | BookshelfCreateWithoutBookVersionInput[] | BookshelfUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: BookshelfCreateOrConnectWithoutBookVersionInput | BookshelfCreateOrConnectWithoutBookVersionInput[]
    createMany?: BookshelfCreateManyBookVersionInputEnvelope
    connect?: BookshelfWhereUniqueInput | BookshelfWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutBookVersionInput = {
    create?: XOR<CommentCreateWithoutBookVersionInput, CommentUncheckedCreateWithoutBookVersionInput> | CommentCreateWithoutBookVersionInput[] | CommentUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutBookVersionInput | CommentCreateOrConnectWithoutBookVersionInput[]
    createMany?: CommentCreateManyBookVersionInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutBookVersionInput = {
    create?: XOR<LikeCreateWithoutBookVersionInput, LikeUncheckedCreateWithoutBookVersionInput> | LikeCreateWithoutBookVersionInput[] | LikeUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutBookVersionInput | LikeCreateOrConnectWithoutBookVersionInput[]
    createMany?: LikeCreateManyBookVersionInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type BookCategoryCreateNestedManyWithoutBookVersionInput = {
    create?: XOR<BookCategoryCreateWithoutBookVersionInput, BookCategoryUncheckedCreateWithoutBookVersionInput> | BookCategoryCreateWithoutBookVersionInput[] | BookCategoryUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: BookCategoryCreateOrConnectWithoutBookVersionInput | BookCategoryCreateOrConnectWithoutBookVersionInput[]
    createMany?: BookCategoryCreateManyBookVersionInputEnvelope
    connect?: BookCategoryWhereUniqueInput | BookCategoryWhereUniqueInput[]
  }

  export type BookTagCreateNestedManyWithoutBookVersionInput = {
    create?: XOR<BookTagCreateWithoutBookVersionInput, BookTagUncheckedCreateWithoutBookVersionInput> | BookTagCreateWithoutBookVersionInput[] | BookTagUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: BookTagCreateOrConnectWithoutBookVersionInput | BookTagCreateOrConnectWithoutBookVersionInput[]
    createMany?: BookTagCreateManyBookVersionInputEnvelope
    connect?: BookTagWhereUniqueInput | BookTagWhereUniqueInput[]
  }

  export type ViewStatCreateNestedManyWithoutBookVersionInput = {
    create?: XOR<ViewStatCreateWithoutBookVersionInput, ViewStatUncheckedCreateWithoutBookVersionInput> | ViewStatCreateWithoutBookVersionInput[] | ViewStatUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: ViewStatCreateOrConnectWithoutBookVersionInput | ViewStatCreateOrConnectWithoutBookVersionInput[]
    createMany?: ViewStatCreateManyBookVersionInputEnvelope
    connect?: ViewStatWhereUniqueInput | ViewStatWhereUniqueInput[]
  }

  export type ReadingProgressCreateNestedManyWithoutBookVersionInput = {
    create?: XOR<ReadingProgressCreateWithoutBookVersionInput, ReadingProgressUncheckedCreateWithoutBookVersionInput> | ReadingProgressCreateWithoutBookVersionInput[] | ReadingProgressUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: ReadingProgressCreateOrConnectWithoutBookVersionInput | ReadingProgressCreateOrConnectWithoutBookVersionInput[]
    createMany?: ReadingProgressCreateManyBookVersionInputEnvelope
    connect?: ReadingProgressWhereUniqueInput | ReadingProgressWhereUniqueInput[]
  }

  export type SeoCreateNestedOneWithoutBookVersionInput = {
    create?: XOR<SeoCreateWithoutBookVersionInput, SeoUncheckedCreateWithoutBookVersionInput>
    connectOrCreate?: SeoCreateOrConnectWithoutBookVersionInput
    connect?: SeoWhereUniqueInput
  }

  export type BookSummaryUncheckedCreateNestedManyWithoutBookVersionInput = {
    create?: XOR<BookSummaryCreateWithoutBookVersionInput, BookSummaryUncheckedCreateWithoutBookVersionInput> | BookSummaryCreateWithoutBookVersionInput[] | BookSummaryUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: BookSummaryCreateOrConnectWithoutBookVersionInput | BookSummaryCreateOrConnectWithoutBookVersionInput[]
    createMany?: BookSummaryCreateManyBookVersionInputEnvelope
    connect?: BookSummaryWhereUniqueInput | BookSummaryWhereUniqueInput[]
  }

  export type ChapterUncheckedCreateNestedManyWithoutBookVersionInput = {
    create?: XOR<ChapterCreateWithoutBookVersionInput, ChapterUncheckedCreateWithoutBookVersionInput> | ChapterCreateWithoutBookVersionInput[] | ChapterUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutBookVersionInput | ChapterCreateOrConnectWithoutBookVersionInput[]
    createMany?: ChapterCreateManyBookVersionInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type AudioChapterUncheckedCreateNestedManyWithoutBookVersionInput = {
    create?: XOR<AudioChapterCreateWithoutBookVersionInput, AudioChapterUncheckedCreateWithoutBookVersionInput> | AudioChapterCreateWithoutBookVersionInput[] | AudioChapterUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: AudioChapterCreateOrConnectWithoutBookVersionInput | AudioChapterCreateOrConnectWithoutBookVersionInput[]
    createMany?: AudioChapterCreateManyBookVersionInputEnvelope
    connect?: AudioChapterWhereUniqueInput | AudioChapterWhereUniqueInput[]
  }

  export type BookshelfUncheckedCreateNestedManyWithoutBookVersionInput = {
    create?: XOR<BookshelfCreateWithoutBookVersionInput, BookshelfUncheckedCreateWithoutBookVersionInput> | BookshelfCreateWithoutBookVersionInput[] | BookshelfUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: BookshelfCreateOrConnectWithoutBookVersionInput | BookshelfCreateOrConnectWithoutBookVersionInput[]
    createMany?: BookshelfCreateManyBookVersionInputEnvelope
    connect?: BookshelfWhereUniqueInput | BookshelfWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutBookVersionInput = {
    create?: XOR<CommentCreateWithoutBookVersionInput, CommentUncheckedCreateWithoutBookVersionInput> | CommentCreateWithoutBookVersionInput[] | CommentUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutBookVersionInput | CommentCreateOrConnectWithoutBookVersionInput[]
    createMany?: CommentCreateManyBookVersionInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutBookVersionInput = {
    create?: XOR<LikeCreateWithoutBookVersionInput, LikeUncheckedCreateWithoutBookVersionInput> | LikeCreateWithoutBookVersionInput[] | LikeUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutBookVersionInput | LikeCreateOrConnectWithoutBookVersionInput[]
    createMany?: LikeCreateManyBookVersionInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type BookCategoryUncheckedCreateNestedManyWithoutBookVersionInput = {
    create?: XOR<BookCategoryCreateWithoutBookVersionInput, BookCategoryUncheckedCreateWithoutBookVersionInput> | BookCategoryCreateWithoutBookVersionInput[] | BookCategoryUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: BookCategoryCreateOrConnectWithoutBookVersionInput | BookCategoryCreateOrConnectWithoutBookVersionInput[]
    createMany?: BookCategoryCreateManyBookVersionInputEnvelope
    connect?: BookCategoryWhereUniqueInput | BookCategoryWhereUniqueInput[]
  }

  export type BookTagUncheckedCreateNestedManyWithoutBookVersionInput = {
    create?: XOR<BookTagCreateWithoutBookVersionInput, BookTagUncheckedCreateWithoutBookVersionInput> | BookTagCreateWithoutBookVersionInput[] | BookTagUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: BookTagCreateOrConnectWithoutBookVersionInput | BookTagCreateOrConnectWithoutBookVersionInput[]
    createMany?: BookTagCreateManyBookVersionInputEnvelope
    connect?: BookTagWhereUniqueInput | BookTagWhereUniqueInput[]
  }

  export type ViewStatUncheckedCreateNestedManyWithoutBookVersionInput = {
    create?: XOR<ViewStatCreateWithoutBookVersionInput, ViewStatUncheckedCreateWithoutBookVersionInput> | ViewStatCreateWithoutBookVersionInput[] | ViewStatUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: ViewStatCreateOrConnectWithoutBookVersionInput | ViewStatCreateOrConnectWithoutBookVersionInput[]
    createMany?: ViewStatCreateManyBookVersionInputEnvelope
    connect?: ViewStatWhereUniqueInput | ViewStatWhereUniqueInput[]
  }

  export type ReadingProgressUncheckedCreateNestedManyWithoutBookVersionInput = {
    create?: XOR<ReadingProgressCreateWithoutBookVersionInput, ReadingProgressUncheckedCreateWithoutBookVersionInput> | ReadingProgressCreateWithoutBookVersionInput[] | ReadingProgressUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: ReadingProgressCreateOrConnectWithoutBookVersionInput | ReadingProgressCreateOrConnectWithoutBookVersionInput[]
    createMany?: ReadingProgressCreateManyBookVersionInputEnvelope
    connect?: ReadingProgressWhereUniqueInput | ReadingProgressWhereUniqueInput[]
  }

  export type EnumLanguageFieldUpdateOperationsInput = {
    set?: $Enums.Language
  }

  export type EnumBookTypeFieldUpdateOperationsInput = {
    set?: $Enums.BookType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumPublicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.PublicationStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BookUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<BookCreateWithoutVersionsInput, BookUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: BookCreateOrConnectWithoutVersionsInput
    upsert?: BookUpsertWithoutVersionsInput
    connect?: BookWhereUniqueInput
    update?: XOR<XOR<BookUpdateToOneWithWhereWithoutVersionsInput, BookUpdateWithoutVersionsInput>, BookUncheckedUpdateWithoutVersionsInput>
  }

  export type BookSummaryUpdateManyWithoutBookVersionNestedInput = {
    create?: XOR<BookSummaryCreateWithoutBookVersionInput, BookSummaryUncheckedCreateWithoutBookVersionInput> | BookSummaryCreateWithoutBookVersionInput[] | BookSummaryUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: BookSummaryCreateOrConnectWithoutBookVersionInput | BookSummaryCreateOrConnectWithoutBookVersionInput[]
    upsert?: BookSummaryUpsertWithWhereUniqueWithoutBookVersionInput | BookSummaryUpsertWithWhereUniqueWithoutBookVersionInput[]
    createMany?: BookSummaryCreateManyBookVersionInputEnvelope
    set?: BookSummaryWhereUniqueInput | BookSummaryWhereUniqueInput[]
    disconnect?: BookSummaryWhereUniqueInput | BookSummaryWhereUniqueInput[]
    delete?: BookSummaryWhereUniqueInput | BookSummaryWhereUniqueInput[]
    connect?: BookSummaryWhereUniqueInput | BookSummaryWhereUniqueInput[]
    update?: BookSummaryUpdateWithWhereUniqueWithoutBookVersionInput | BookSummaryUpdateWithWhereUniqueWithoutBookVersionInput[]
    updateMany?: BookSummaryUpdateManyWithWhereWithoutBookVersionInput | BookSummaryUpdateManyWithWhereWithoutBookVersionInput[]
    deleteMany?: BookSummaryScalarWhereInput | BookSummaryScalarWhereInput[]
  }

  export type ChapterUpdateManyWithoutBookVersionNestedInput = {
    create?: XOR<ChapterCreateWithoutBookVersionInput, ChapterUncheckedCreateWithoutBookVersionInput> | ChapterCreateWithoutBookVersionInput[] | ChapterUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutBookVersionInput | ChapterCreateOrConnectWithoutBookVersionInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutBookVersionInput | ChapterUpsertWithWhereUniqueWithoutBookVersionInput[]
    createMany?: ChapterCreateManyBookVersionInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutBookVersionInput | ChapterUpdateWithWhereUniqueWithoutBookVersionInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutBookVersionInput | ChapterUpdateManyWithWhereWithoutBookVersionInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type AudioChapterUpdateManyWithoutBookVersionNestedInput = {
    create?: XOR<AudioChapterCreateWithoutBookVersionInput, AudioChapterUncheckedCreateWithoutBookVersionInput> | AudioChapterCreateWithoutBookVersionInput[] | AudioChapterUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: AudioChapterCreateOrConnectWithoutBookVersionInput | AudioChapterCreateOrConnectWithoutBookVersionInput[]
    upsert?: AudioChapterUpsertWithWhereUniqueWithoutBookVersionInput | AudioChapterUpsertWithWhereUniqueWithoutBookVersionInput[]
    createMany?: AudioChapterCreateManyBookVersionInputEnvelope
    set?: AudioChapterWhereUniqueInput | AudioChapterWhereUniqueInput[]
    disconnect?: AudioChapterWhereUniqueInput | AudioChapterWhereUniqueInput[]
    delete?: AudioChapterWhereUniqueInput | AudioChapterWhereUniqueInput[]
    connect?: AudioChapterWhereUniqueInput | AudioChapterWhereUniqueInput[]
    update?: AudioChapterUpdateWithWhereUniqueWithoutBookVersionInput | AudioChapterUpdateWithWhereUniqueWithoutBookVersionInput[]
    updateMany?: AudioChapterUpdateManyWithWhereWithoutBookVersionInput | AudioChapterUpdateManyWithWhereWithoutBookVersionInput[]
    deleteMany?: AudioChapterScalarWhereInput | AudioChapterScalarWhereInput[]
  }

  export type BookshelfUpdateManyWithoutBookVersionNestedInput = {
    create?: XOR<BookshelfCreateWithoutBookVersionInput, BookshelfUncheckedCreateWithoutBookVersionInput> | BookshelfCreateWithoutBookVersionInput[] | BookshelfUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: BookshelfCreateOrConnectWithoutBookVersionInput | BookshelfCreateOrConnectWithoutBookVersionInput[]
    upsert?: BookshelfUpsertWithWhereUniqueWithoutBookVersionInput | BookshelfUpsertWithWhereUniqueWithoutBookVersionInput[]
    createMany?: BookshelfCreateManyBookVersionInputEnvelope
    set?: BookshelfWhereUniqueInput | BookshelfWhereUniqueInput[]
    disconnect?: BookshelfWhereUniqueInput | BookshelfWhereUniqueInput[]
    delete?: BookshelfWhereUniqueInput | BookshelfWhereUniqueInput[]
    connect?: BookshelfWhereUniqueInput | BookshelfWhereUniqueInput[]
    update?: BookshelfUpdateWithWhereUniqueWithoutBookVersionInput | BookshelfUpdateWithWhereUniqueWithoutBookVersionInput[]
    updateMany?: BookshelfUpdateManyWithWhereWithoutBookVersionInput | BookshelfUpdateManyWithWhereWithoutBookVersionInput[]
    deleteMany?: BookshelfScalarWhereInput | BookshelfScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutBookVersionNestedInput = {
    create?: XOR<CommentCreateWithoutBookVersionInput, CommentUncheckedCreateWithoutBookVersionInput> | CommentCreateWithoutBookVersionInput[] | CommentUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutBookVersionInput | CommentCreateOrConnectWithoutBookVersionInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutBookVersionInput | CommentUpsertWithWhereUniqueWithoutBookVersionInput[]
    createMany?: CommentCreateManyBookVersionInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutBookVersionInput | CommentUpdateWithWhereUniqueWithoutBookVersionInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutBookVersionInput | CommentUpdateManyWithWhereWithoutBookVersionInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutBookVersionNestedInput = {
    create?: XOR<LikeCreateWithoutBookVersionInput, LikeUncheckedCreateWithoutBookVersionInput> | LikeCreateWithoutBookVersionInput[] | LikeUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutBookVersionInput | LikeCreateOrConnectWithoutBookVersionInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutBookVersionInput | LikeUpsertWithWhereUniqueWithoutBookVersionInput[]
    createMany?: LikeCreateManyBookVersionInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutBookVersionInput | LikeUpdateWithWhereUniqueWithoutBookVersionInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutBookVersionInput | LikeUpdateManyWithWhereWithoutBookVersionInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type BookCategoryUpdateManyWithoutBookVersionNestedInput = {
    create?: XOR<BookCategoryCreateWithoutBookVersionInput, BookCategoryUncheckedCreateWithoutBookVersionInput> | BookCategoryCreateWithoutBookVersionInput[] | BookCategoryUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: BookCategoryCreateOrConnectWithoutBookVersionInput | BookCategoryCreateOrConnectWithoutBookVersionInput[]
    upsert?: BookCategoryUpsertWithWhereUniqueWithoutBookVersionInput | BookCategoryUpsertWithWhereUniqueWithoutBookVersionInput[]
    createMany?: BookCategoryCreateManyBookVersionInputEnvelope
    set?: BookCategoryWhereUniqueInput | BookCategoryWhereUniqueInput[]
    disconnect?: BookCategoryWhereUniqueInput | BookCategoryWhereUniqueInput[]
    delete?: BookCategoryWhereUniqueInput | BookCategoryWhereUniqueInput[]
    connect?: BookCategoryWhereUniqueInput | BookCategoryWhereUniqueInput[]
    update?: BookCategoryUpdateWithWhereUniqueWithoutBookVersionInput | BookCategoryUpdateWithWhereUniqueWithoutBookVersionInput[]
    updateMany?: BookCategoryUpdateManyWithWhereWithoutBookVersionInput | BookCategoryUpdateManyWithWhereWithoutBookVersionInput[]
    deleteMany?: BookCategoryScalarWhereInput | BookCategoryScalarWhereInput[]
  }

  export type BookTagUpdateManyWithoutBookVersionNestedInput = {
    create?: XOR<BookTagCreateWithoutBookVersionInput, BookTagUncheckedCreateWithoutBookVersionInput> | BookTagCreateWithoutBookVersionInput[] | BookTagUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: BookTagCreateOrConnectWithoutBookVersionInput | BookTagCreateOrConnectWithoutBookVersionInput[]
    upsert?: BookTagUpsertWithWhereUniqueWithoutBookVersionInput | BookTagUpsertWithWhereUniqueWithoutBookVersionInput[]
    createMany?: BookTagCreateManyBookVersionInputEnvelope
    set?: BookTagWhereUniqueInput | BookTagWhereUniqueInput[]
    disconnect?: BookTagWhereUniqueInput | BookTagWhereUniqueInput[]
    delete?: BookTagWhereUniqueInput | BookTagWhereUniqueInput[]
    connect?: BookTagWhereUniqueInput | BookTagWhereUniqueInput[]
    update?: BookTagUpdateWithWhereUniqueWithoutBookVersionInput | BookTagUpdateWithWhereUniqueWithoutBookVersionInput[]
    updateMany?: BookTagUpdateManyWithWhereWithoutBookVersionInput | BookTagUpdateManyWithWhereWithoutBookVersionInput[]
    deleteMany?: BookTagScalarWhereInput | BookTagScalarWhereInput[]
  }

  export type ViewStatUpdateManyWithoutBookVersionNestedInput = {
    create?: XOR<ViewStatCreateWithoutBookVersionInput, ViewStatUncheckedCreateWithoutBookVersionInput> | ViewStatCreateWithoutBookVersionInput[] | ViewStatUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: ViewStatCreateOrConnectWithoutBookVersionInput | ViewStatCreateOrConnectWithoutBookVersionInput[]
    upsert?: ViewStatUpsertWithWhereUniqueWithoutBookVersionInput | ViewStatUpsertWithWhereUniqueWithoutBookVersionInput[]
    createMany?: ViewStatCreateManyBookVersionInputEnvelope
    set?: ViewStatWhereUniqueInput | ViewStatWhereUniqueInput[]
    disconnect?: ViewStatWhereUniqueInput | ViewStatWhereUniqueInput[]
    delete?: ViewStatWhereUniqueInput | ViewStatWhereUniqueInput[]
    connect?: ViewStatWhereUniqueInput | ViewStatWhereUniqueInput[]
    update?: ViewStatUpdateWithWhereUniqueWithoutBookVersionInput | ViewStatUpdateWithWhereUniqueWithoutBookVersionInput[]
    updateMany?: ViewStatUpdateManyWithWhereWithoutBookVersionInput | ViewStatUpdateManyWithWhereWithoutBookVersionInput[]
    deleteMany?: ViewStatScalarWhereInput | ViewStatScalarWhereInput[]
  }

  export type ReadingProgressUpdateManyWithoutBookVersionNestedInput = {
    create?: XOR<ReadingProgressCreateWithoutBookVersionInput, ReadingProgressUncheckedCreateWithoutBookVersionInput> | ReadingProgressCreateWithoutBookVersionInput[] | ReadingProgressUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: ReadingProgressCreateOrConnectWithoutBookVersionInput | ReadingProgressCreateOrConnectWithoutBookVersionInput[]
    upsert?: ReadingProgressUpsertWithWhereUniqueWithoutBookVersionInput | ReadingProgressUpsertWithWhereUniqueWithoutBookVersionInput[]
    createMany?: ReadingProgressCreateManyBookVersionInputEnvelope
    set?: ReadingProgressWhereUniqueInput | ReadingProgressWhereUniqueInput[]
    disconnect?: ReadingProgressWhereUniqueInput | ReadingProgressWhereUniqueInput[]
    delete?: ReadingProgressWhereUniqueInput | ReadingProgressWhereUniqueInput[]
    connect?: ReadingProgressWhereUniqueInput | ReadingProgressWhereUniqueInput[]
    update?: ReadingProgressUpdateWithWhereUniqueWithoutBookVersionInput | ReadingProgressUpdateWithWhereUniqueWithoutBookVersionInput[]
    updateMany?: ReadingProgressUpdateManyWithWhereWithoutBookVersionInput | ReadingProgressUpdateManyWithWhereWithoutBookVersionInput[]
    deleteMany?: ReadingProgressScalarWhereInput | ReadingProgressScalarWhereInput[]
  }

  export type SeoUpdateOneWithoutBookVersionNestedInput = {
    create?: XOR<SeoCreateWithoutBookVersionInput, SeoUncheckedCreateWithoutBookVersionInput>
    connectOrCreate?: SeoCreateOrConnectWithoutBookVersionInput
    upsert?: SeoUpsertWithoutBookVersionInput
    disconnect?: SeoWhereInput | boolean
    delete?: SeoWhereInput | boolean
    connect?: SeoWhereUniqueInput
    update?: XOR<XOR<SeoUpdateToOneWithWhereWithoutBookVersionInput, SeoUpdateWithoutBookVersionInput>, SeoUncheckedUpdateWithoutBookVersionInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BookSummaryUncheckedUpdateManyWithoutBookVersionNestedInput = {
    create?: XOR<BookSummaryCreateWithoutBookVersionInput, BookSummaryUncheckedCreateWithoutBookVersionInput> | BookSummaryCreateWithoutBookVersionInput[] | BookSummaryUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: BookSummaryCreateOrConnectWithoutBookVersionInput | BookSummaryCreateOrConnectWithoutBookVersionInput[]
    upsert?: BookSummaryUpsertWithWhereUniqueWithoutBookVersionInput | BookSummaryUpsertWithWhereUniqueWithoutBookVersionInput[]
    createMany?: BookSummaryCreateManyBookVersionInputEnvelope
    set?: BookSummaryWhereUniqueInput | BookSummaryWhereUniqueInput[]
    disconnect?: BookSummaryWhereUniqueInput | BookSummaryWhereUniqueInput[]
    delete?: BookSummaryWhereUniqueInput | BookSummaryWhereUniqueInput[]
    connect?: BookSummaryWhereUniqueInput | BookSummaryWhereUniqueInput[]
    update?: BookSummaryUpdateWithWhereUniqueWithoutBookVersionInput | BookSummaryUpdateWithWhereUniqueWithoutBookVersionInput[]
    updateMany?: BookSummaryUpdateManyWithWhereWithoutBookVersionInput | BookSummaryUpdateManyWithWhereWithoutBookVersionInput[]
    deleteMany?: BookSummaryScalarWhereInput | BookSummaryScalarWhereInput[]
  }

  export type ChapterUncheckedUpdateManyWithoutBookVersionNestedInput = {
    create?: XOR<ChapterCreateWithoutBookVersionInput, ChapterUncheckedCreateWithoutBookVersionInput> | ChapterCreateWithoutBookVersionInput[] | ChapterUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutBookVersionInput | ChapterCreateOrConnectWithoutBookVersionInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutBookVersionInput | ChapterUpsertWithWhereUniqueWithoutBookVersionInput[]
    createMany?: ChapterCreateManyBookVersionInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutBookVersionInput | ChapterUpdateWithWhereUniqueWithoutBookVersionInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutBookVersionInput | ChapterUpdateManyWithWhereWithoutBookVersionInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type AudioChapterUncheckedUpdateManyWithoutBookVersionNestedInput = {
    create?: XOR<AudioChapterCreateWithoutBookVersionInput, AudioChapterUncheckedCreateWithoutBookVersionInput> | AudioChapterCreateWithoutBookVersionInput[] | AudioChapterUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: AudioChapterCreateOrConnectWithoutBookVersionInput | AudioChapterCreateOrConnectWithoutBookVersionInput[]
    upsert?: AudioChapterUpsertWithWhereUniqueWithoutBookVersionInput | AudioChapterUpsertWithWhereUniqueWithoutBookVersionInput[]
    createMany?: AudioChapterCreateManyBookVersionInputEnvelope
    set?: AudioChapterWhereUniqueInput | AudioChapterWhereUniqueInput[]
    disconnect?: AudioChapterWhereUniqueInput | AudioChapterWhereUniqueInput[]
    delete?: AudioChapterWhereUniqueInput | AudioChapterWhereUniqueInput[]
    connect?: AudioChapterWhereUniqueInput | AudioChapterWhereUniqueInput[]
    update?: AudioChapterUpdateWithWhereUniqueWithoutBookVersionInput | AudioChapterUpdateWithWhereUniqueWithoutBookVersionInput[]
    updateMany?: AudioChapterUpdateManyWithWhereWithoutBookVersionInput | AudioChapterUpdateManyWithWhereWithoutBookVersionInput[]
    deleteMany?: AudioChapterScalarWhereInput | AudioChapterScalarWhereInput[]
  }

  export type BookshelfUncheckedUpdateManyWithoutBookVersionNestedInput = {
    create?: XOR<BookshelfCreateWithoutBookVersionInput, BookshelfUncheckedCreateWithoutBookVersionInput> | BookshelfCreateWithoutBookVersionInput[] | BookshelfUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: BookshelfCreateOrConnectWithoutBookVersionInput | BookshelfCreateOrConnectWithoutBookVersionInput[]
    upsert?: BookshelfUpsertWithWhereUniqueWithoutBookVersionInput | BookshelfUpsertWithWhereUniqueWithoutBookVersionInput[]
    createMany?: BookshelfCreateManyBookVersionInputEnvelope
    set?: BookshelfWhereUniqueInput | BookshelfWhereUniqueInput[]
    disconnect?: BookshelfWhereUniqueInput | BookshelfWhereUniqueInput[]
    delete?: BookshelfWhereUniqueInput | BookshelfWhereUniqueInput[]
    connect?: BookshelfWhereUniqueInput | BookshelfWhereUniqueInput[]
    update?: BookshelfUpdateWithWhereUniqueWithoutBookVersionInput | BookshelfUpdateWithWhereUniqueWithoutBookVersionInput[]
    updateMany?: BookshelfUpdateManyWithWhereWithoutBookVersionInput | BookshelfUpdateManyWithWhereWithoutBookVersionInput[]
    deleteMany?: BookshelfScalarWhereInput | BookshelfScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutBookVersionNestedInput = {
    create?: XOR<CommentCreateWithoutBookVersionInput, CommentUncheckedCreateWithoutBookVersionInput> | CommentCreateWithoutBookVersionInput[] | CommentUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutBookVersionInput | CommentCreateOrConnectWithoutBookVersionInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutBookVersionInput | CommentUpsertWithWhereUniqueWithoutBookVersionInput[]
    createMany?: CommentCreateManyBookVersionInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutBookVersionInput | CommentUpdateWithWhereUniqueWithoutBookVersionInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutBookVersionInput | CommentUpdateManyWithWhereWithoutBookVersionInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutBookVersionNestedInput = {
    create?: XOR<LikeCreateWithoutBookVersionInput, LikeUncheckedCreateWithoutBookVersionInput> | LikeCreateWithoutBookVersionInput[] | LikeUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutBookVersionInput | LikeCreateOrConnectWithoutBookVersionInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutBookVersionInput | LikeUpsertWithWhereUniqueWithoutBookVersionInput[]
    createMany?: LikeCreateManyBookVersionInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutBookVersionInput | LikeUpdateWithWhereUniqueWithoutBookVersionInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutBookVersionInput | LikeUpdateManyWithWhereWithoutBookVersionInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type BookCategoryUncheckedUpdateManyWithoutBookVersionNestedInput = {
    create?: XOR<BookCategoryCreateWithoutBookVersionInput, BookCategoryUncheckedCreateWithoutBookVersionInput> | BookCategoryCreateWithoutBookVersionInput[] | BookCategoryUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: BookCategoryCreateOrConnectWithoutBookVersionInput | BookCategoryCreateOrConnectWithoutBookVersionInput[]
    upsert?: BookCategoryUpsertWithWhereUniqueWithoutBookVersionInput | BookCategoryUpsertWithWhereUniqueWithoutBookVersionInput[]
    createMany?: BookCategoryCreateManyBookVersionInputEnvelope
    set?: BookCategoryWhereUniqueInput | BookCategoryWhereUniqueInput[]
    disconnect?: BookCategoryWhereUniqueInput | BookCategoryWhereUniqueInput[]
    delete?: BookCategoryWhereUniqueInput | BookCategoryWhereUniqueInput[]
    connect?: BookCategoryWhereUniqueInput | BookCategoryWhereUniqueInput[]
    update?: BookCategoryUpdateWithWhereUniqueWithoutBookVersionInput | BookCategoryUpdateWithWhereUniqueWithoutBookVersionInput[]
    updateMany?: BookCategoryUpdateManyWithWhereWithoutBookVersionInput | BookCategoryUpdateManyWithWhereWithoutBookVersionInput[]
    deleteMany?: BookCategoryScalarWhereInput | BookCategoryScalarWhereInput[]
  }

  export type BookTagUncheckedUpdateManyWithoutBookVersionNestedInput = {
    create?: XOR<BookTagCreateWithoutBookVersionInput, BookTagUncheckedCreateWithoutBookVersionInput> | BookTagCreateWithoutBookVersionInput[] | BookTagUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: BookTagCreateOrConnectWithoutBookVersionInput | BookTagCreateOrConnectWithoutBookVersionInput[]
    upsert?: BookTagUpsertWithWhereUniqueWithoutBookVersionInput | BookTagUpsertWithWhereUniqueWithoutBookVersionInput[]
    createMany?: BookTagCreateManyBookVersionInputEnvelope
    set?: BookTagWhereUniqueInput | BookTagWhereUniqueInput[]
    disconnect?: BookTagWhereUniqueInput | BookTagWhereUniqueInput[]
    delete?: BookTagWhereUniqueInput | BookTagWhereUniqueInput[]
    connect?: BookTagWhereUniqueInput | BookTagWhereUniqueInput[]
    update?: BookTagUpdateWithWhereUniqueWithoutBookVersionInput | BookTagUpdateWithWhereUniqueWithoutBookVersionInput[]
    updateMany?: BookTagUpdateManyWithWhereWithoutBookVersionInput | BookTagUpdateManyWithWhereWithoutBookVersionInput[]
    deleteMany?: BookTagScalarWhereInput | BookTagScalarWhereInput[]
  }

  export type ViewStatUncheckedUpdateManyWithoutBookVersionNestedInput = {
    create?: XOR<ViewStatCreateWithoutBookVersionInput, ViewStatUncheckedCreateWithoutBookVersionInput> | ViewStatCreateWithoutBookVersionInput[] | ViewStatUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: ViewStatCreateOrConnectWithoutBookVersionInput | ViewStatCreateOrConnectWithoutBookVersionInput[]
    upsert?: ViewStatUpsertWithWhereUniqueWithoutBookVersionInput | ViewStatUpsertWithWhereUniqueWithoutBookVersionInput[]
    createMany?: ViewStatCreateManyBookVersionInputEnvelope
    set?: ViewStatWhereUniqueInput | ViewStatWhereUniqueInput[]
    disconnect?: ViewStatWhereUniqueInput | ViewStatWhereUniqueInput[]
    delete?: ViewStatWhereUniqueInput | ViewStatWhereUniqueInput[]
    connect?: ViewStatWhereUniqueInput | ViewStatWhereUniqueInput[]
    update?: ViewStatUpdateWithWhereUniqueWithoutBookVersionInput | ViewStatUpdateWithWhereUniqueWithoutBookVersionInput[]
    updateMany?: ViewStatUpdateManyWithWhereWithoutBookVersionInput | ViewStatUpdateManyWithWhereWithoutBookVersionInput[]
    deleteMany?: ViewStatScalarWhereInput | ViewStatScalarWhereInput[]
  }

  export type ReadingProgressUncheckedUpdateManyWithoutBookVersionNestedInput = {
    create?: XOR<ReadingProgressCreateWithoutBookVersionInput, ReadingProgressUncheckedCreateWithoutBookVersionInput> | ReadingProgressCreateWithoutBookVersionInput[] | ReadingProgressUncheckedCreateWithoutBookVersionInput[]
    connectOrCreate?: ReadingProgressCreateOrConnectWithoutBookVersionInput | ReadingProgressCreateOrConnectWithoutBookVersionInput[]
    upsert?: ReadingProgressUpsertWithWhereUniqueWithoutBookVersionInput | ReadingProgressUpsertWithWhereUniqueWithoutBookVersionInput[]
    createMany?: ReadingProgressCreateManyBookVersionInputEnvelope
    set?: ReadingProgressWhereUniqueInput | ReadingProgressWhereUniqueInput[]
    disconnect?: ReadingProgressWhereUniqueInput | ReadingProgressWhereUniqueInput[]
    delete?: ReadingProgressWhereUniqueInput | ReadingProgressWhereUniqueInput[]
    connect?: ReadingProgressWhereUniqueInput | ReadingProgressWhereUniqueInput[]
    update?: ReadingProgressUpdateWithWhereUniqueWithoutBookVersionInput | ReadingProgressUpdateWithWhereUniqueWithoutBookVersionInput[]
    updateMany?: ReadingProgressUpdateManyWithWhereWithoutBookVersionInput | ReadingProgressUpdateManyWithWhereWithoutBookVersionInput[]
    deleteMany?: ReadingProgressScalarWhereInput | ReadingProgressScalarWhereInput[]
  }

  export type BookVersionCreateNestedOneWithoutSummariesInput = {
    create?: XOR<BookVersionCreateWithoutSummariesInput, BookVersionUncheckedCreateWithoutSummariesInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutSummariesInput
    connect?: BookVersionWhereUniqueInput
  }

  export type BookVersionUpdateOneRequiredWithoutSummariesNestedInput = {
    create?: XOR<BookVersionCreateWithoutSummariesInput, BookVersionUncheckedCreateWithoutSummariesInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutSummariesInput
    upsert?: BookVersionUpsertWithoutSummariesInput
    connect?: BookVersionWhereUniqueInput
    update?: XOR<XOR<BookVersionUpdateToOneWithWhereWithoutSummariesInput, BookVersionUpdateWithoutSummariesInput>, BookVersionUncheckedUpdateWithoutSummariesInput>
  }

  export type BookVersionCreateNestedOneWithoutChaptersInput = {
    create?: XOR<BookVersionCreateWithoutChaptersInput, BookVersionUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutChaptersInput
    connect?: BookVersionWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutChapterInput = {
    create?: XOR<CommentCreateWithoutChapterInput, CommentUncheckedCreateWithoutChapterInput> | CommentCreateWithoutChapterInput[] | CommentUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutChapterInput | CommentCreateOrConnectWithoutChapterInput[]
    createMany?: CommentCreateManyChapterInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<CommentCreateWithoutChapterInput, CommentUncheckedCreateWithoutChapterInput> | CommentCreateWithoutChapterInput[] | CommentUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutChapterInput | CommentCreateOrConnectWithoutChapterInput[]
    createMany?: CommentCreateManyChapterInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BookVersionUpdateOneRequiredWithoutChaptersNestedInput = {
    create?: XOR<BookVersionCreateWithoutChaptersInput, BookVersionUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutChaptersInput
    upsert?: BookVersionUpsertWithoutChaptersInput
    connect?: BookVersionWhereUniqueInput
    update?: XOR<XOR<BookVersionUpdateToOneWithWhereWithoutChaptersInput, BookVersionUpdateWithoutChaptersInput>, BookVersionUncheckedUpdateWithoutChaptersInput>
  }

  export type CommentUpdateManyWithoutChapterNestedInput = {
    create?: XOR<CommentCreateWithoutChapterInput, CommentUncheckedCreateWithoutChapterInput> | CommentCreateWithoutChapterInput[] | CommentUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutChapterInput | CommentCreateOrConnectWithoutChapterInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutChapterInput | CommentUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: CommentCreateManyChapterInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutChapterInput | CommentUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutChapterInput | CommentUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<CommentCreateWithoutChapterInput, CommentUncheckedCreateWithoutChapterInput> | CommentCreateWithoutChapterInput[] | CommentUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutChapterInput | CommentCreateOrConnectWithoutChapterInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutChapterInput | CommentUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: CommentCreateManyChapterInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutChapterInput | CommentUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutChapterInput | CommentUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type BookVersionCreateNestedOneWithoutAudioChaptersInput = {
    create?: XOR<BookVersionCreateWithoutAudioChaptersInput, BookVersionUncheckedCreateWithoutAudioChaptersInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutAudioChaptersInput
    connect?: BookVersionWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutAudioChapterInput = {
    create?: XOR<CommentCreateWithoutAudioChapterInput, CommentUncheckedCreateWithoutAudioChapterInput> | CommentCreateWithoutAudioChapterInput[] | CommentUncheckedCreateWithoutAudioChapterInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAudioChapterInput | CommentCreateOrConnectWithoutAudioChapterInput[]
    createMany?: CommentCreateManyAudioChapterInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAudioChapterInput = {
    create?: XOR<CommentCreateWithoutAudioChapterInput, CommentUncheckedCreateWithoutAudioChapterInput> | CommentCreateWithoutAudioChapterInput[] | CommentUncheckedCreateWithoutAudioChapterInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAudioChapterInput | CommentCreateOrConnectWithoutAudioChapterInput[]
    createMany?: CommentCreateManyAudioChapterInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type BookVersionUpdateOneRequiredWithoutAudioChaptersNestedInput = {
    create?: XOR<BookVersionCreateWithoutAudioChaptersInput, BookVersionUncheckedCreateWithoutAudioChaptersInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutAudioChaptersInput
    upsert?: BookVersionUpsertWithoutAudioChaptersInput
    connect?: BookVersionWhereUniqueInput
    update?: XOR<XOR<BookVersionUpdateToOneWithWhereWithoutAudioChaptersInput, BookVersionUpdateWithoutAudioChaptersInput>, BookVersionUncheckedUpdateWithoutAudioChaptersInput>
  }

  export type CommentUpdateManyWithoutAudioChapterNestedInput = {
    create?: XOR<CommentCreateWithoutAudioChapterInput, CommentUncheckedCreateWithoutAudioChapterInput> | CommentCreateWithoutAudioChapterInput[] | CommentUncheckedCreateWithoutAudioChapterInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAudioChapterInput | CommentCreateOrConnectWithoutAudioChapterInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAudioChapterInput | CommentUpsertWithWhereUniqueWithoutAudioChapterInput[]
    createMany?: CommentCreateManyAudioChapterInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAudioChapterInput | CommentUpdateWithWhereUniqueWithoutAudioChapterInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAudioChapterInput | CommentUpdateManyWithWhereWithoutAudioChapterInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAudioChapterNestedInput = {
    create?: XOR<CommentCreateWithoutAudioChapterInput, CommentUncheckedCreateWithoutAudioChapterInput> | CommentCreateWithoutAudioChapterInput[] | CommentUncheckedCreateWithoutAudioChapterInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAudioChapterInput | CommentCreateOrConnectWithoutAudioChapterInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAudioChapterInput | CommentUpsertWithWhereUniqueWithoutAudioChapterInput[]
    createMany?: CommentCreateManyAudioChapterInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAudioChapterInput | CommentUpdateWithWhereUniqueWithoutAudioChapterInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAudioChapterInput | CommentUpdateManyWithWhereWithoutAudioChapterInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type BookshelfCreateNestedManyWithoutUserInput = {
    create?: XOR<BookshelfCreateWithoutUserInput, BookshelfUncheckedCreateWithoutUserInput> | BookshelfCreateWithoutUserInput[] | BookshelfUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookshelfCreateOrConnectWithoutUserInput | BookshelfCreateOrConnectWithoutUserInput[]
    createMany?: BookshelfCreateManyUserInputEnvelope
    connect?: BookshelfWhereUniqueInput | BookshelfWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type ViewStatCreateNestedManyWithoutUserInput = {
    create?: XOR<ViewStatCreateWithoutUserInput, ViewStatUncheckedCreateWithoutUserInput> | ViewStatCreateWithoutUserInput[] | ViewStatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewStatCreateOrConnectWithoutUserInput | ViewStatCreateOrConnectWithoutUserInput[]
    createMany?: ViewStatCreateManyUserInputEnvelope
    connect?: ViewStatWhereUniqueInput | ViewStatWhereUniqueInput[]
  }

  export type ReadingProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<ReadingProgressCreateWithoutUserInput, ReadingProgressUncheckedCreateWithoutUserInput> | ReadingProgressCreateWithoutUserInput[] | ReadingProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReadingProgressCreateOrConnectWithoutUserInput | ReadingProgressCreateOrConnectWithoutUserInput[]
    createMany?: ReadingProgressCreateManyUserInputEnvelope
    connect?: ReadingProgressWhereUniqueInput | ReadingProgressWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type BookshelfUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookshelfCreateWithoutUserInput, BookshelfUncheckedCreateWithoutUserInput> | BookshelfCreateWithoutUserInput[] | BookshelfUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookshelfCreateOrConnectWithoutUserInput | BookshelfCreateOrConnectWithoutUserInput[]
    createMany?: BookshelfCreateManyUserInputEnvelope
    connect?: BookshelfWhereUniqueInput | BookshelfWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type ViewStatUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ViewStatCreateWithoutUserInput, ViewStatUncheckedCreateWithoutUserInput> | ViewStatCreateWithoutUserInput[] | ViewStatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewStatCreateOrConnectWithoutUserInput | ViewStatCreateOrConnectWithoutUserInput[]
    createMany?: ViewStatCreateManyUserInputEnvelope
    connect?: ViewStatWhereUniqueInput | ViewStatWhereUniqueInput[]
  }

  export type ReadingProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReadingProgressCreateWithoutUserInput, ReadingProgressUncheckedCreateWithoutUserInput> | ReadingProgressCreateWithoutUserInput[] | ReadingProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReadingProgressCreateOrConnectWithoutUserInput | ReadingProgressCreateOrConnectWithoutUserInput[]
    createMany?: ReadingProgressCreateManyUserInputEnvelope
    connect?: ReadingProgressWhereUniqueInput | ReadingProgressWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type BookshelfUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookshelfCreateWithoutUserInput, BookshelfUncheckedCreateWithoutUserInput> | BookshelfCreateWithoutUserInput[] | BookshelfUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookshelfCreateOrConnectWithoutUserInput | BookshelfCreateOrConnectWithoutUserInput[]
    upsert?: BookshelfUpsertWithWhereUniqueWithoutUserInput | BookshelfUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookshelfCreateManyUserInputEnvelope
    set?: BookshelfWhereUniqueInput | BookshelfWhereUniqueInput[]
    disconnect?: BookshelfWhereUniqueInput | BookshelfWhereUniqueInput[]
    delete?: BookshelfWhereUniqueInput | BookshelfWhereUniqueInput[]
    connect?: BookshelfWhereUniqueInput | BookshelfWhereUniqueInput[]
    update?: BookshelfUpdateWithWhereUniqueWithoutUserInput | BookshelfUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookshelfUpdateManyWithWhereWithoutUserInput | BookshelfUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookshelfScalarWhereInput | BookshelfScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutUserInput | LikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutUserInput | LikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutUserInput | LikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type ViewStatUpdateManyWithoutUserNestedInput = {
    create?: XOR<ViewStatCreateWithoutUserInput, ViewStatUncheckedCreateWithoutUserInput> | ViewStatCreateWithoutUserInput[] | ViewStatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewStatCreateOrConnectWithoutUserInput | ViewStatCreateOrConnectWithoutUserInput[]
    upsert?: ViewStatUpsertWithWhereUniqueWithoutUserInput | ViewStatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ViewStatCreateManyUserInputEnvelope
    set?: ViewStatWhereUniqueInput | ViewStatWhereUniqueInput[]
    disconnect?: ViewStatWhereUniqueInput | ViewStatWhereUniqueInput[]
    delete?: ViewStatWhereUniqueInput | ViewStatWhereUniqueInput[]
    connect?: ViewStatWhereUniqueInput | ViewStatWhereUniqueInput[]
    update?: ViewStatUpdateWithWhereUniqueWithoutUserInput | ViewStatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ViewStatUpdateManyWithWhereWithoutUserInput | ViewStatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ViewStatScalarWhereInput | ViewStatScalarWhereInput[]
  }

  export type ReadingProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReadingProgressCreateWithoutUserInput, ReadingProgressUncheckedCreateWithoutUserInput> | ReadingProgressCreateWithoutUserInput[] | ReadingProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReadingProgressCreateOrConnectWithoutUserInput | ReadingProgressCreateOrConnectWithoutUserInput[]
    upsert?: ReadingProgressUpsertWithWhereUniqueWithoutUserInput | ReadingProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReadingProgressCreateManyUserInputEnvelope
    set?: ReadingProgressWhereUniqueInput | ReadingProgressWhereUniqueInput[]
    disconnect?: ReadingProgressWhereUniqueInput | ReadingProgressWhereUniqueInput[]
    delete?: ReadingProgressWhereUniqueInput | ReadingProgressWhereUniqueInput[]
    connect?: ReadingProgressWhereUniqueInput | ReadingProgressWhereUniqueInput[]
    update?: ReadingProgressUpdateWithWhereUniqueWithoutUserInput | ReadingProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReadingProgressUpdateManyWithWhereWithoutUserInput | ReadingProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReadingProgressScalarWhereInput | ReadingProgressScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type BookshelfUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookshelfCreateWithoutUserInput, BookshelfUncheckedCreateWithoutUserInput> | BookshelfCreateWithoutUserInput[] | BookshelfUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookshelfCreateOrConnectWithoutUserInput | BookshelfCreateOrConnectWithoutUserInput[]
    upsert?: BookshelfUpsertWithWhereUniqueWithoutUserInput | BookshelfUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookshelfCreateManyUserInputEnvelope
    set?: BookshelfWhereUniqueInput | BookshelfWhereUniqueInput[]
    disconnect?: BookshelfWhereUniqueInput | BookshelfWhereUniqueInput[]
    delete?: BookshelfWhereUniqueInput | BookshelfWhereUniqueInput[]
    connect?: BookshelfWhereUniqueInput | BookshelfWhereUniqueInput[]
    update?: BookshelfUpdateWithWhereUniqueWithoutUserInput | BookshelfUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookshelfUpdateManyWithWhereWithoutUserInput | BookshelfUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookshelfScalarWhereInput | BookshelfScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutUserInput | LikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutUserInput | LikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutUserInput | LikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type ViewStatUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ViewStatCreateWithoutUserInput, ViewStatUncheckedCreateWithoutUserInput> | ViewStatCreateWithoutUserInput[] | ViewStatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewStatCreateOrConnectWithoutUserInput | ViewStatCreateOrConnectWithoutUserInput[]
    upsert?: ViewStatUpsertWithWhereUniqueWithoutUserInput | ViewStatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ViewStatCreateManyUserInputEnvelope
    set?: ViewStatWhereUniqueInput | ViewStatWhereUniqueInput[]
    disconnect?: ViewStatWhereUniqueInput | ViewStatWhereUniqueInput[]
    delete?: ViewStatWhereUniqueInput | ViewStatWhereUniqueInput[]
    connect?: ViewStatWhereUniqueInput | ViewStatWhereUniqueInput[]
    update?: ViewStatUpdateWithWhereUniqueWithoutUserInput | ViewStatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ViewStatUpdateManyWithWhereWithoutUserInput | ViewStatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ViewStatScalarWhereInput | ViewStatScalarWhereInput[]
  }

  export type ReadingProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReadingProgressCreateWithoutUserInput, ReadingProgressUncheckedCreateWithoutUserInput> | ReadingProgressCreateWithoutUserInput[] | ReadingProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReadingProgressCreateOrConnectWithoutUserInput | ReadingProgressCreateOrConnectWithoutUserInput[]
    upsert?: ReadingProgressUpsertWithWhereUniqueWithoutUserInput | ReadingProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReadingProgressCreateManyUserInputEnvelope
    set?: ReadingProgressWhereUniqueInput | ReadingProgressWhereUniqueInput[]
    disconnect?: ReadingProgressWhereUniqueInput | ReadingProgressWhereUniqueInput[]
    delete?: ReadingProgressWhereUniqueInput | ReadingProgressWhereUniqueInput[]
    connect?: ReadingProgressWhereUniqueInput | ReadingProgressWhereUniqueInput[]
    update?: ReadingProgressUpdateWithWhereUniqueWithoutUserInput | ReadingProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReadingProgressUpdateManyWithWhereWithoutUserInput | ReadingProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReadingProgressScalarWhereInput | ReadingProgressScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBookshelvesInput = {
    create?: XOR<UserCreateWithoutBookshelvesInput, UserUncheckedCreateWithoutBookshelvesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookshelvesInput
    connect?: UserWhereUniqueInput
  }

  export type BookVersionCreateNestedOneWithoutBookshelfInput = {
    create?: XOR<BookVersionCreateWithoutBookshelfInput, BookVersionUncheckedCreateWithoutBookshelfInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutBookshelfInput
    connect?: BookVersionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBookshelvesNestedInput = {
    create?: XOR<UserCreateWithoutBookshelvesInput, UserUncheckedCreateWithoutBookshelvesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookshelvesInput
    upsert?: UserUpsertWithoutBookshelvesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookshelvesInput, UserUpdateWithoutBookshelvesInput>, UserUncheckedUpdateWithoutBookshelvesInput>
  }

  export type BookVersionUpdateOneRequiredWithoutBookshelfNestedInput = {
    create?: XOR<BookVersionCreateWithoutBookshelfInput, BookVersionUncheckedCreateWithoutBookshelfInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutBookshelfInput
    upsert?: BookVersionUpsertWithoutBookshelfInput
    connect?: BookVersionWhereUniqueInput
    update?: XOR<XOR<BookVersionUpdateToOneWithWhereWithoutBookshelfInput, BookVersionUpdateWithoutBookshelfInput>, BookVersionUncheckedUpdateWithoutBookshelfInput>
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type BookVersionCreateNestedOneWithoutCommentsInput = {
    create?: XOR<BookVersionCreateWithoutCommentsInput, BookVersionUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutCommentsInput
    connect?: BookVersionWhereUniqueInput
  }

  export type ChapterCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ChapterCreateWithoutCommentsInput, ChapterUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutCommentsInput
    connect?: ChapterWhereUniqueInput
  }

  export type AudioChapterCreateNestedOneWithoutCommentsInput = {
    create?: XOR<AudioChapterCreateWithoutCommentsInput, AudioChapterUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: AudioChapterCreateOrConnectWithoutCommentsInput
    connect?: AudioChapterWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CommentCreateWithoutChildrenInput, CommentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CommentCreateOrConnectWithoutChildrenInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutCommentInput = {
    create?: XOR<LikeCreateWithoutCommentInput, LikeUncheckedCreateWithoutCommentInput> | LikeCreateWithoutCommentInput[] | LikeUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutCommentInput | LikeCreateOrConnectWithoutCommentInput[]
    createMany?: LikeCreateManyCommentInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<LikeCreateWithoutCommentInput, LikeUncheckedCreateWithoutCommentInput> | LikeCreateWithoutCommentInput[] | LikeUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutCommentInput | LikeCreateOrConnectWithoutCommentInput[]
    createMany?: LikeCreateManyCommentInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type BookVersionUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<BookVersionCreateWithoutCommentsInput, BookVersionUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutCommentsInput
    upsert?: BookVersionUpsertWithoutCommentsInput
    disconnect?: BookVersionWhereInput | boolean
    delete?: BookVersionWhereInput | boolean
    connect?: BookVersionWhereUniqueInput
    update?: XOR<XOR<BookVersionUpdateToOneWithWhereWithoutCommentsInput, BookVersionUpdateWithoutCommentsInput>, BookVersionUncheckedUpdateWithoutCommentsInput>
  }

  export type ChapterUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<ChapterCreateWithoutCommentsInput, ChapterUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutCommentsInput
    upsert?: ChapterUpsertWithoutCommentsInput
    disconnect?: ChapterWhereInput | boolean
    delete?: ChapterWhereInput | boolean
    connect?: ChapterWhereUniqueInput
    update?: XOR<XOR<ChapterUpdateToOneWithWhereWithoutCommentsInput, ChapterUpdateWithoutCommentsInput>, ChapterUncheckedUpdateWithoutCommentsInput>
  }

  export type AudioChapterUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<AudioChapterCreateWithoutCommentsInput, AudioChapterUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: AudioChapterCreateOrConnectWithoutCommentsInput
    upsert?: AudioChapterUpsertWithoutCommentsInput
    disconnect?: AudioChapterWhereInput | boolean
    delete?: AudioChapterWhereInput | boolean
    connect?: AudioChapterWhereUniqueInput
    update?: XOR<XOR<AudioChapterUpdateToOneWithWhereWithoutCommentsInput, AudioChapterUpdateWithoutCommentsInput>, AudioChapterUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CommentCreateWithoutChildrenInput, CommentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CommentCreateOrConnectWithoutChildrenInput
    upsert?: CommentUpsertWithoutChildrenInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutChildrenInput, CommentUpdateWithoutChildrenInput>, CommentUncheckedUpdateWithoutChildrenInput>
  }

  export type CommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutCommentNestedInput = {
    create?: XOR<LikeCreateWithoutCommentInput, LikeUncheckedCreateWithoutCommentInput> | LikeCreateWithoutCommentInput[] | LikeUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutCommentInput | LikeCreateOrConnectWithoutCommentInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutCommentInput | LikeUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: LikeCreateManyCommentInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutCommentInput | LikeUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutCommentInput | LikeUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<LikeCreateWithoutCommentInput, LikeUncheckedCreateWithoutCommentInput> | LikeCreateWithoutCommentInput[] | LikeUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutCommentInput | LikeCreateOrConnectWithoutCommentInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutCommentInput | LikeUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: LikeCreateManyCommentInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutCommentInput | LikeUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutCommentInput | LikeUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLikesInput = {
    create?: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesInput
    connect?: UserWhereUniqueInput
  }

  export type BookVersionCreateNestedOneWithoutLikesInput = {
    create?: XOR<BookVersionCreateWithoutLikesInput, BookVersionUncheckedCreateWithoutLikesInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutLikesInput
    connect?: BookVersionWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutLikesInput = {
    create?: XOR<CommentCreateWithoutLikesInput, CommentUncheckedCreateWithoutLikesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutLikesInput
    connect?: CommentWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesInput
    upsert?: UserUpsertWithoutLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikesInput, UserUpdateWithoutLikesInput>, UserUncheckedUpdateWithoutLikesInput>
  }

  export type BookVersionUpdateOneWithoutLikesNestedInput = {
    create?: XOR<BookVersionCreateWithoutLikesInput, BookVersionUncheckedCreateWithoutLikesInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutLikesInput
    upsert?: BookVersionUpsertWithoutLikesInput
    disconnect?: BookVersionWhereInput | boolean
    delete?: BookVersionWhereInput | boolean
    connect?: BookVersionWhereUniqueInput
    update?: XOR<XOR<BookVersionUpdateToOneWithWhereWithoutLikesInput, BookVersionUpdateWithoutLikesInput>, BookVersionUncheckedUpdateWithoutLikesInput>
  }

  export type CommentUpdateOneWithoutLikesNestedInput = {
    create?: XOR<CommentCreateWithoutLikesInput, CommentUncheckedCreateWithoutLikesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutLikesInput
    upsert?: CommentUpsertWithoutLikesInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutLikesInput, CommentUpdateWithoutLikesInput>, CommentUncheckedUpdateWithoutLikesInput>
  }

  export type BookCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BookCategoryCreateWithoutCategoryInput, BookCategoryUncheckedCreateWithoutCategoryInput> | BookCategoryCreateWithoutCategoryInput[] | BookCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BookCategoryCreateOrConnectWithoutCategoryInput | BookCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: BookCategoryCreateManyCategoryInputEnvelope
    connect?: BookCategoryWhereUniqueInput | BookCategoryWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type BookCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BookCategoryCreateWithoutCategoryInput, BookCategoryUncheckedCreateWithoutCategoryInput> | BookCategoryCreateWithoutCategoryInput[] | BookCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BookCategoryCreateOrConnectWithoutCategoryInput | BookCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: BookCategoryCreateManyCategoryInputEnvelope
    connect?: BookCategoryWhereUniqueInput | BookCategoryWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type EnumCategoryTypeFieldUpdateOperationsInput = {
    set?: $Enums.CategoryType
  }

  export type BookCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BookCategoryCreateWithoutCategoryInput, BookCategoryUncheckedCreateWithoutCategoryInput> | BookCategoryCreateWithoutCategoryInput[] | BookCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BookCategoryCreateOrConnectWithoutCategoryInput | BookCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: BookCategoryUpsertWithWhereUniqueWithoutCategoryInput | BookCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BookCategoryCreateManyCategoryInputEnvelope
    set?: BookCategoryWhereUniqueInput | BookCategoryWhereUniqueInput[]
    disconnect?: BookCategoryWhereUniqueInput | BookCategoryWhereUniqueInput[]
    delete?: BookCategoryWhereUniqueInput | BookCategoryWhereUniqueInput[]
    connect?: BookCategoryWhereUniqueInput | BookCategoryWhereUniqueInput[]
    update?: BookCategoryUpdateWithWhereUniqueWithoutCategoryInput | BookCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BookCategoryUpdateManyWithWhereWithoutCategoryInput | BookCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BookCategoryScalarWhereInput | BookCategoryScalarWhereInput[]
  }

  export type CategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    upsert?: CategoryUpsertWithoutChildrenInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutChildrenInput, CategoryUpdateWithoutChildrenInput>, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type BookCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BookCategoryCreateWithoutCategoryInput, BookCategoryUncheckedCreateWithoutCategoryInput> | BookCategoryCreateWithoutCategoryInput[] | BookCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BookCategoryCreateOrConnectWithoutCategoryInput | BookCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: BookCategoryUpsertWithWhereUniqueWithoutCategoryInput | BookCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BookCategoryCreateManyCategoryInputEnvelope
    set?: BookCategoryWhereUniqueInput | BookCategoryWhereUniqueInput[]
    disconnect?: BookCategoryWhereUniqueInput | BookCategoryWhereUniqueInput[]
    delete?: BookCategoryWhereUniqueInput | BookCategoryWhereUniqueInput[]
    connect?: BookCategoryWhereUniqueInput | BookCategoryWhereUniqueInput[]
    update?: BookCategoryUpdateWithWhereUniqueWithoutCategoryInput | BookCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BookCategoryUpdateManyWithWhereWithoutCategoryInput | BookCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BookCategoryScalarWhereInput | BookCategoryScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type BookVersionCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<BookVersionCreateWithoutCategoriesInput, BookVersionUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutCategoriesInput
    connect?: BookVersionWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutBooksInput = {
    create?: XOR<CategoryCreateWithoutBooksInput, CategoryUncheckedCreateWithoutBooksInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutBooksInput
    connect?: CategoryWhereUniqueInput
  }

  export type BookVersionUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<BookVersionCreateWithoutCategoriesInput, BookVersionUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutCategoriesInput
    upsert?: BookVersionUpsertWithoutCategoriesInput
    connect?: BookVersionWhereUniqueInput
    update?: XOR<XOR<BookVersionUpdateToOneWithWhereWithoutCategoriesInput, BookVersionUpdateWithoutCategoriesInput>, BookVersionUncheckedUpdateWithoutCategoriesInput>
  }

  export type CategoryUpdateOneRequiredWithoutBooksNestedInput = {
    create?: XOR<CategoryCreateWithoutBooksInput, CategoryUncheckedCreateWithoutBooksInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutBooksInput
    upsert?: CategoryUpsertWithoutBooksInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutBooksInput, CategoryUpdateWithoutBooksInput>, CategoryUncheckedUpdateWithoutBooksInput>
  }

  export type BookTagCreateNestedManyWithoutTagInput = {
    create?: XOR<BookTagCreateWithoutTagInput, BookTagUncheckedCreateWithoutTagInput> | BookTagCreateWithoutTagInput[] | BookTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: BookTagCreateOrConnectWithoutTagInput | BookTagCreateOrConnectWithoutTagInput[]
    createMany?: BookTagCreateManyTagInputEnvelope
    connect?: BookTagWhereUniqueInput | BookTagWhereUniqueInput[]
  }

  export type BookTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<BookTagCreateWithoutTagInput, BookTagUncheckedCreateWithoutTagInput> | BookTagCreateWithoutTagInput[] | BookTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: BookTagCreateOrConnectWithoutTagInput | BookTagCreateOrConnectWithoutTagInput[]
    createMany?: BookTagCreateManyTagInputEnvelope
    connect?: BookTagWhereUniqueInput | BookTagWhereUniqueInput[]
  }

  export type BookTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<BookTagCreateWithoutTagInput, BookTagUncheckedCreateWithoutTagInput> | BookTagCreateWithoutTagInput[] | BookTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: BookTagCreateOrConnectWithoutTagInput | BookTagCreateOrConnectWithoutTagInput[]
    upsert?: BookTagUpsertWithWhereUniqueWithoutTagInput | BookTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: BookTagCreateManyTagInputEnvelope
    set?: BookTagWhereUniqueInput | BookTagWhereUniqueInput[]
    disconnect?: BookTagWhereUniqueInput | BookTagWhereUniqueInput[]
    delete?: BookTagWhereUniqueInput | BookTagWhereUniqueInput[]
    connect?: BookTagWhereUniqueInput | BookTagWhereUniqueInput[]
    update?: BookTagUpdateWithWhereUniqueWithoutTagInput | BookTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: BookTagUpdateManyWithWhereWithoutTagInput | BookTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: BookTagScalarWhereInput | BookTagScalarWhereInput[]
  }

  export type BookTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<BookTagCreateWithoutTagInput, BookTagUncheckedCreateWithoutTagInput> | BookTagCreateWithoutTagInput[] | BookTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: BookTagCreateOrConnectWithoutTagInput | BookTagCreateOrConnectWithoutTagInput[]
    upsert?: BookTagUpsertWithWhereUniqueWithoutTagInput | BookTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: BookTagCreateManyTagInputEnvelope
    set?: BookTagWhereUniqueInput | BookTagWhereUniqueInput[]
    disconnect?: BookTagWhereUniqueInput | BookTagWhereUniqueInput[]
    delete?: BookTagWhereUniqueInput | BookTagWhereUniqueInput[]
    connect?: BookTagWhereUniqueInput | BookTagWhereUniqueInput[]
    update?: BookTagUpdateWithWhereUniqueWithoutTagInput | BookTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: BookTagUpdateManyWithWhereWithoutTagInput | BookTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: BookTagScalarWhereInput | BookTagScalarWhereInput[]
  }

  export type BookVersionCreateNestedOneWithoutTagsInput = {
    create?: XOR<BookVersionCreateWithoutTagsInput, BookVersionUncheckedCreateWithoutTagsInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutTagsInput
    connect?: BookVersionWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutBooksInput = {
    create?: XOR<TagCreateWithoutBooksInput, TagUncheckedCreateWithoutBooksInput>
    connectOrCreate?: TagCreateOrConnectWithoutBooksInput
    connect?: TagWhereUniqueInput
  }

  export type BookVersionUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<BookVersionCreateWithoutTagsInput, BookVersionUncheckedCreateWithoutTagsInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutTagsInput
    upsert?: BookVersionUpsertWithoutTagsInput
    connect?: BookVersionWhereUniqueInput
    update?: XOR<XOR<BookVersionUpdateToOneWithWhereWithoutTagsInput, BookVersionUpdateWithoutTagsInput>, BookVersionUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutBooksNestedInput = {
    create?: XOR<TagCreateWithoutBooksInput, TagUncheckedCreateWithoutBooksInput>
    connectOrCreate?: TagCreateOrConnectWithoutBooksInput
    upsert?: TagUpsertWithoutBooksInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutBooksInput, TagUpdateWithoutBooksInput>, TagUncheckedUpdateWithoutBooksInput>
  }

  export type BookVersionCreateNestedOneWithoutViewStatsInput = {
    create?: XOR<BookVersionCreateWithoutViewStatsInput, BookVersionUncheckedCreateWithoutViewStatsInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutViewStatsInput
    connect?: BookVersionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutViewStatsInput = {
    create?: XOR<UserCreateWithoutViewStatsInput, UserUncheckedCreateWithoutViewStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutViewStatsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumViewSourceFieldUpdateOperationsInput = {
    set?: $Enums.ViewSource
  }

  export type BookVersionUpdateOneRequiredWithoutViewStatsNestedInput = {
    create?: XOR<BookVersionCreateWithoutViewStatsInput, BookVersionUncheckedCreateWithoutViewStatsInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutViewStatsInput
    upsert?: BookVersionUpsertWithoutViewStatsInput
    connect?: BookVersionWhereUniqueInput
    update?: XOR<XOR<BookVersionUpdateToOneWithWhereWithoutViewStatsInput, BookVersionUpdateWithoutViewStatsInput>, BookVersionUncheckedUpdateWithoutViewStatsInput>
  }

  export type UserUpdateOneWithoutViewStatsNestedInput = {
    create?: XOR<UserCreateWithoutViewStatsInput, UserUncheckedCreateWithoutViewStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutViewStatsInput
    upsert?: UserUpsertWithoutViewStatsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutViewStatsInput, UserUpdateWithoutViewStatsInput>, UserUncheckedUpdateWithoutViewStatsInput>
  }

  export type UserCreateNestedOneWithoutReadingProgressInput = {
    create?: XOR<UserCreateWithoutReadingProgressInput, UserUncheckedCreateWithoutReadingProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutReadingProgressInput
    connect?: UserWhereUniqueInput
  }

  export type BookVersionCreateNestedOneWithoutReadingProgressInput = {
    create?: XOR<BookVersionCreateWithoutReadingProgressInput, BookVersionUncheckedCreateWithoutReadingProgressInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutReadingProgressInput
    connect?: BookVersionWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutReadingProgressNestedInput = {
    create?: XOR<UserCreateWithoutReadingProgressInput, UserUncheckedCreateWithoutReadingProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutReadingProgressInput
    upsert?: UserUpsertWithoutReadingProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReadingProgressInput, UserUpdateWithoutReadingProgressInput>, UserUncheckedUpdateWithoutReadingProgressInput>
  }

  export type BookVersionUpdateOneRequiredWithoutReadingProgressNestedInput = {
    create?: XOR<BookVersionCreateWithoutReadingProgressInput, BookVersionUncheckedCreateWithoutReadingProgressInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutReadingProgressInput
    upsert?: BookVersionUpsertWithoutReadingProgressInput
    connect?: BookVersionWhereUniqueInput
    update?: XOR<XOR<BookVersionUpdateToOneWithWhereWithoutReadingProgressInput, BookVersionUpdateWithoutReadingProgressInput>, BookVersionUncheckedUpdateWithoutReadingProgressInput>
  }

  export type BookVersionCreateNestedOneWithoutSeoInput = {
    create?: XOR<BookVersionCreateWithoutSeoInput, BookVersionUncheckedCreateWithoutSeoInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutSeoInput
    connect?: BookVersionWhereUniqueInput
  }

  export type BookVersionUncheckedCreateNestedOneWithoutSeoInput = {
    create?: XOR<BookVersionCreateWithoutSeoInput, BookVersionUncheckedCreateWithoutSeoInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutSeoInput
    connect?: BookVersionWhereUniqueInput
  }

  export type BookVersionUpdateOneWithoutSeoNestedInput = {
    create?: XOR<BookVersionCreateWithoutSeoInput, BookVersionUncheckedCreateWithoutSeoInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutSeoInput
    upsert?: BookVersionUpsertWithoutSeoInput
    disconnect?: BookVersionWhereInput | boolean
    delete?: BookVersionWhereInput | boolean
    connect?: BookVersionWhereUniqueInput
    update?: XOR<XOR<BookVersionUpdateToOneWithWhereWithoutSeoInput, BookVersionUpdateWithoutSeoInput>, BookVersionUncheckedUpdateWithoutSeoInput>
  }

  export type BookVersionUncheckedUpdateOneWithoutSeoNestedInput = {
    create?: XOR<BookVersionCreateWithoutSeoInput, BookVersionUncheckedCreateWithoutSeoInput>
    connectOrCreate?: BookVersionCreateOrConnectWithoutSeoInput
    upsert?: BookVersionUpsertWithoutSeoInput
    disconnect?: BookVersionWhereInput | boolean
    delete?: BookVersionWhereInput | boolean
    connect?: BookVersionWhereUniqueInput
    update?: XOR<XOR<BookVersionUpdateToOneWithWhereWithoutSeoInput, BookVersionUpdateWithoutSeoInput>, BookVersionUncheckedUpdateWithoutSeoInput>
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type EnumRoleNameFieldUpdateOperationsInput = {
    set?: $Enums.RoleName
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    upsert?: UserUpsertWithoutRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRolesInput, UserUpdateWithoutRolesInput>, UserUncheckedUpdateWithoutRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumLanguageFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageFilter<$PrismaModel> | $Enums.Language
  }

  export type NestedEnumBookTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BookType | EnumBookTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookType[] | ListEnumBookTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookType[] | ListEnumBookTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookTypeFilter<$PrismaModel> | $Enums.BookType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumPublicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PublicationStatus | EnumPublicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublicationStatusFilter<$PrismaModel> | $Enums.PublicationStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumLanguageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageWithAggregatesFilter<$PrismaModel> | $Enums.Language
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLanguageFilter<$PrismaModel>
    _max?: NestedEnumLanguageFilter<$PrismaModel>
  }

  export type NestedEnumBookTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookType | EnumBookTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookType[] | ListEnumBookTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookType[] | ListEnumBookTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookTypeWithAggregatesFilter<$PrismaModel> | $Enums.BookType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookTypeFilter<$PrismaModel>
    _max?: NestedEnumBookTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumPublicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PublicationStatus | EnumPublicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublicationStatus[] | ListEnumPublicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.PublicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPublicationStatusFilter<$PrismaModel>
    _max?: NestedEnumPublicationStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumCategoryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryType | EnumCategoryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryTypeFilter<$PrismaModel> | $Enums.CategoryType
  }

  export type NestedEnumCategoryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategoryType | EnumCategoryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategoryType[] | ListEnumCategoryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryTypeWithAggregatesFilter<$PrismaModel> | $Enums.CategoryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryTypeFilter<$PrismaModel>
    _max?: NestedEnumCategoryTypeFilter<$PrismaModel>
  }

  export type NestedEnumViewSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.ViewSource | EnumViewSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ViewSource[] | ListEnumViewSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ViewSource[] | ListEnumViewSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumViewSourceFilter<$PrismaModel> | $Enums.ViewSource
  }

  export type NestedEnumViewSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ViewSource | EnumViewSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ViewSource[] | ListEnumViewSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ViewSource[] | ListEnumViewSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumViewSourceWithAggregatesFilter<$PrismaModel> | $Enums.ViewSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumViewSourceFilter<$PrismaModel>
    _max?: NestedEnumViewSourceFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumRoleNameFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameFilter<$PrismaModel> | $Enums.RoleName
  }

  export type NestedEnumRoleNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameWithAggregatesFilter<$PrismaModel> | $Enums.RoleName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleNameFilter<$PrismaModel>
    _max?: NestedEnumRoleNameFilter<$PrismaModel>
  }

  export type BookVersionCreateWithoutBookInput = {
    id?: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    summaries?: BookSummaryCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfCreateNestedManyWithoutBookVersionInput
    comments?: CommentCreateNestedManyWithoutBookVersionInput
    likes?: LikeCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryCreateNestedManyWithoutBookVersionInput
    tags?: BookTagCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressCreateNestedManyWithoutBookVersionInput
    seo?: SeoCreateNestedOneWithoutBookVersionInput
  }

  export type BookVersionUncheckedCreateWithoutBookInput = {
    id?: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seoId?: number | null
    summaries?: BookSummaryUncheckedCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterUncheckedCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfUncheckedCreateNestedManyWithoutBookVersionInput
    comments?: CommentUncheckedCreateNestedManyWithoutBookVersionInput
    likes?: LikeUncheckedCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryUncheckedCreateNestedManyWithoutBookVersionInput
    tags?: BookTagUncheckedCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatUncheckedCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressUncheckedCreateNestedManyWithoutBookVersionInput
  }

  export type BookVersionCreateOrConnectWithoutBookInput = {
    where: BookVersionWhereUniqueInput
    create: XOR<BookVersionCreateWithoutBookInput, BookVersionUncheckedCreateWithoutBookInput>
  }

  export type BookVersionCreateManyBookInputEnvelope = {
    data: BookVersionCreateManyBookInput | BookVersionCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type BookVersionUpsertWithWhereUniqueWithoutBookInput = {
    where: BookVersionWhereUniqueInput
    update: XOR<BookVersionUpdateWithoutBookInput, BookVersionUncheckedUpdateWithoutBookInput>
    create: XOR<BookVersionCreateWithoutBookInput, BookVersionUncheckedCreateWithoutBookInput>
  }

  export type BookVersionUpdateWithWhereUniqueWithoutBookInput = {
    where: BookVersionWhereUniqueInput
    data: XOR<BookVersionUpdateWithoutBookInput, BookVersionUncheckedUpdateWithoutBookInput>
  }

  export type BookVersionUpdateManyWithWhereWithoutBookInput = {
    where: BookVersionScalarWhereInput
    data: XOR<BookVersionUpdateManyMutationInput, BookVersionUncheckedUpdateManyWithoutBookInput>
  }

  export type BookVersionScalarWhereInput = {
    AND?: BookVersionScalarWhereInput | BookVersionScalarWhereInput[]
    OR?: BookVersionScalarWhereInput[]
    NOT?: BookVersionScalarWhereInput | BookVersionScalarWhereInput[]
    id?: StringFilter<"BookVersion"> | string
    bookId?: StringFilter<"BookVersion"> | string
    language?: EnumLanguageFilter<"BookVersion"> | $Enums.Language
    title?: StringFilter<"BookVersion"> | string
    author?: StringFilter<"BookVersion"> | string
    description?: StringFilter<"BookVersion"> | string
    coverImageUrl?: StringFilter<"BookVersion"> | string
    type?: EnumBookTypeFilter<"BookVersion"> | $Enums.BookType
    isFree?: BoolFilter<"BookVersion"> | boolean
    referralUrl?: StringNullableFilter<"BookVersion"> | string | null
    status?: EnumPublicationStatusFilter<"BookVersion"> | $Enums.PublicationStatus
    publishedAt?: DateTimeNullableFilter<"BookVersion"> | Date | string | null
    createdAt?: DateTimeFilter<"BookVersion"> | Date | string
    updatedAt?: DateTimeFilter<"BookVersion"> | Date | string
    seoId?: IntNullableFilter<"BookVersion"> | number | null
  }

  export type BookCreateWithoutVersionsInput = {
    id?: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookUncheckedCreateWithoutVersionsInput = {
    id?: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookCreateOrConnectWithoutVersionsInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutVersionsInput, BookUncheckedCreateWithoutVersionsInput>
  }

  export type BookSummaryCreateWithoutBookVersionInput = {
    id?: string
    summary: string
    analysis?: string | null
    themes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookSummaryUncheckedCreateWithoutBookVersionInput = {
    id?: string
    summary: string
    analysis?: string | null
    themes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookSummaryCreateOrConnectWithoutBookVersionInput = {
    where: BookSummaryWhereUniqueInput
    create: XOR<BookSummaryCreateWithoutBookVersionInput, BookSummaryUncheckedCreateWithoutBookVersionInput>
  }

  export type BookSummaryCreateManyBookVersionInputEnvelope = {
    data: BookSummaryCreateManyBookVersionInput | BookSummaryCreateManyBookVersionInput[]
    skipDuplicates?: boolean
  }

  export type ChapterCreateWithoutBookVersionInput = {
    id?: string
    number: number
    title: string
    content: string
    createdAt?: Date | string
    comments?: CommentCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutBookVersionInput = {
    id?: string
    number: number
    title: string
    content: string
    createdAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutBookVersionInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutBookVersionInput, ChapterUncheckedCreateWithoutBookVersionInput>
  }

  export type ChapterCreateManyBookVersionInputEnvelope = {
    data: ChapterCreateManyBookVersionInput | ChapterCreateManyBookVersionInput[]
    skipDuplicates?: boolean
  }

  export type AudioChapterCreateWithoutBookVersionInput = {
    id?: string
    number: number
    title: string
    audioUrl: string
    duration: number
    createdAt?: Date | string
    comments?: CommentCreateNestedManyWithoutAudioChapterInput
  }

  export type AudioChapterUncheckedCreateWithoutBookVersionInput = {
    id?: string
    number: number
    title: string
    audioUrl: string
    duration: number
    createdAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutAudioChapterInput
  }

  export type AudioChapterCreateOrConnectWithoutBookVersionInput = {
    where: AudioChapterWhereUniqueInput
    create: XOR<AudioChapterCreateWithoutBookVersionInput, AudioChapterUncheckedCreateWithoutBookVersionInput>
  }

  export type AudioChapterCreateManyBookVersionInputEnvelope = {
    data: AudioChapterCreateManyBookVersionInput | AudioChapterCreateManyBookVersionInput[]
    skipDuplicates?: boolean
  }

  export type BookshelfCreateWithoutBookVersionInput = {
    id?: string
    addedAt?: Date | string
    user: UserCreateNestedOneWithoutBookshelvesInput
  }

  export type BookshelfUncheckedCreateWithoutBookVersionInput = {
    id?: string
    userId: string
    addedAt?: Date | string
  }

  export type BookshelfCreateOrConnectWithoutBookVersionInput = {
    where: BookshelfWhereUniqueInput
    create: XOR<BookshelfCreateWithoutBookVersionInput, BookshelfUncheckedCreateWithoutBookVersionInput>
  }

  export type BookshelfCreateManyBookVersionInputEnvelope = {
    data: BookshelfCreateManyBookVersionInput | BookshelfCreateManyBookVersionInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutBookVersionInput = {
    id?: string
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    chapter?: ChapterCreateNestedOneWithoutCommentsInput
    audioChapter?: AudioChapterCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutChildrenInput
    children?: CommentCreateNestedManyWithoutParentInput
    likes?: LikeCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutBookVersionInput = {
    id?: string
    userId: string
    chapterId?: string | null
    audioChapterId?: string | null
    parentId?: string | null
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
    likes?: LikeUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutBookVersionInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutBookVersionInput, CommentUncheckedCreateWithoutBookVersionInput>
  }

  export type CommentCreateManyBookVersionInputEnvelope = {
    data: CommentCreateManyBookVersionInput | CommentCreateManyBookVersionInput[]
    skipDuplicates?: boolean
  }

  export type LikeCreateWithoutBookVersionInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLikesInput
    comment?: CommentCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutBookVersionInput = {
    id?: string
    userId: string
    commentId?: string | null
    createdAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutBookVersionInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutBookVersionInput, LikeUncheckedCreateWithoutBookVersionInput>
  }

  export type LikeCreateManyBookVersionInputEnvelope = {
    data: LikeCreateManyBookVersionInput | LikeCreateManyBookVersionInput[]
    skipDuplicates?: boolean
  }

  export type BookCategoryCreateWithoutBookVersionInput = {
    id?: string
    category: CategoryCreateNestedOneWithoutBooksInput
  }

  export type BookCategoryUncheckedCreateWithoutBookVersionInput = {
    id?: string
    categoryId: string
  }

  export type BookCategoryCreateOrConnectWithoutBookVersionInput = {
    where: BookCategoryWhereUniqueInput
    create: XOR<BookCategoryCreateWithoutBookVersionInput, BookCategoryUncheckedCreateWithoutBookVersionInput>
  }

  export type BookCategoryCreateManyBookVersionInputEnvelope = {
    data: BookCategoryCreateManyBookVersionInput | BookCategoryCreateManyBookVersionInput[]
    skipDuplicates?: boolean
  }

  export type BookTagCreateWithoutBookVersionInput = {
    id?: string
    tag: TagCreateNestedOneWithoutBooksInput
  }

  export type BookTagUncheckedCreateWithoutBookVersionInput = {
    id?: string
    tagId: string
  }

  export type BookTagCreateOrConnectWithoutBookVersionInput = {
    where: BookTagWhereUniqueInput
    create: XOR<BookTagCreateWithoutBookVersionInput, BookTagUncheckedCreateWithoutBookVersionInput>
  }

  export type BookTagCreateManyBookVersionInputEnvelope = {
    data: BookTagCreateManyBookVersionInput | BookTagCreateManyBookVersionInput[]
    skipDuplicates?: boolean
  }

  export type ViewStatCreateWithoutBookVersionInput = {
    id?: string
    source: $Enums.ViewSource
    timestamp?: Date | string
    user?: UserCreateNestedOneWithoutViewStatsInput
  }

  export type ViewStatUncheckedCreateWithoutBookVersionInput = {
    id?: string
    userId?: string | null
    source: $Enums.ViewSource
    timestamp?: Date | string
  }

  export type ViewStatCreateOrConnectWithoutBookVersionInput = {
    where: ViewStatWhereUniqueInput
    create: XOR<ViewStatCreateWithoutBookVersionInput, ViewStatUncheckedCreateWithoutBookVersionInput>
  }

  export type ViewStatCreateManyBookVersionInputEnvelope = {
    data: ViewStatCreateManyBookVersionInput | ViewStatCreateManyBookVersionInput[]
    skipDuplicates?: boolean
  }

  export type ReadingProgressCreateWithoutBookVersionInput = {
    id?: string
    chapterNumber?: number | null
    audioChapterNumber?: number | null
    position: number
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReadingProgressInput
  }

  export type ReadingProgressUncheckedCreateWithoutBookVersionInput = {
    id?: string
    userId: string
    chapterNumber?: number | null
    audioChapterNumber?: number | null
    position: number
    updatedAt?: Date | string
  }

  export type ReadingProgressCreateOrConnectWithoutBookVersionInput = {
    where: ReadingProgressWhereUniqueInput
    create: XOR<ReadingProgressCreateWithoutBookVersionInput, ReadingProgressUncheckedCreateWithoutBookVersionInput>
  }

  export type ReadingProgressCreateManyBookVersionInputEnvelope = {
    data: ReadingProgressCreateManyBookVersionInput | ReadingProgressCreateManyBookVersionInput[]
    skipDuplicates?: boolean
  }

  export type SeoCreateWithoutBookVersionInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    metaTitle?: string | null
    metaDescription?: string | null
    canonicalUrl?: string | null
    robots?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogType?: string | null
    ogUrl?: string | null
    ogImageUrl?: string | null
    ogImageAlt?: string | null
    twitterCard?: string | null
    twitterSite?: string | null
    twitterCreator?: string | null
    eventName?: string | null
    eventDescription?: string | null
    eventStartDate?: Date | string | null
    eventEndDate?: Date | string | null
    eventUrl?: string | null
    eventImageUrl?: string | null
    eventLocationName?: string | null
    eventLocationStreet?: string | null
    eventLocationCity?: string | null
    eventLocationRegion?: string | null
    eventLocationPostal?: string | null
    eventLocationCountry?: string | null
  }

  export type SeoUncheckedCreateWithoutBookVersionInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    metaTitle?: string | null
    metaDescription?: string | null
    canonicalUrl?: string | null
    robots?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogType?: string | null
    ogUrl?: string | null
    ogImageUrl?: string | null
    ogImageAlt?: string | null
    twitterCard?: string | null
    twitterSite?: string | null
    twitterCreator?: string | null
    eventName?: string | null
    eventDescription?: string | null
    eventStartDate?: Date | string | null
    eventEndDate?: Date | string | null
    eventUrl?: string | null
    eventImageUrl?: string | null
    eventLocationName?: string | null
    eventLocationStreet?: string | null
    eventLocationCity?: string | null
    eventLocationRegion?: string | null
    eventLocationPostal?: string | null
    eventLocationCountry?: string | null
  }

  export type SeoCreateOrConnectWithoutBookVersionInput = {
    where: SeoWhereUniqueInput
    create: XOR<SeoCreateWithoutBookVersionInput, SeoUncheckedCreateWithoutBookVersionInput>
  }

  export type BookUpsertWithoutVersionsInput = {
    update: XOR<BookUpdateWithoutVersionsInput, BookUncheckedUpdateWithoutVersionsInput>
    create: XOR<BookCreateWithoutVersionsInput, BookUncheckedCreateWithoutVersionsInput>
    where?: BookWhereInput
  }

  export type BookUpdateToOneWithWhereWithoutVersionsInput = {
    where?: BookWhereInput
    data: XOR<BookUpdateWithoutVersionsInput, BookUncheckedUpdateWithoutVersionsInput>
  }

  export type BookUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookSummaryUpsertWithWhereUniqueWithoutBookVersionInput = {
    where: BookSummaryWhereUniqueInput
    update: XOR<BookSummaryUpdateWithoutBookVersionInput, BookSummaryUncheckedUpdateWithoutBookVersionInput>
    create: XOR<BookSummaryCreateWithoutBookVersionInput, BookSummaryUncheckedCreateWithoutBookVersionInput>
  }

  export type BookSummaryUpdateWithWhereUniqueWithoutBookVersionInput = {
    where: BookSummaryWhereUniqueInput
    data: XOR<BookSummaryUpdateWithoutBookVersionInput, BookSummaryUncheckedUpdateWithoutBookVersionInput>
  }

  export type BookSummaryUpdateManyWithWhereWithoutBookVersionInput = {
    where: BookSummaryScalarWhereInput
    data: XOR<BookSummaryUpdateManyMutationInput, BookSummaryUncheckedUpdateManyWithoutBookVersionInput>
  }

  export type BookSummaryScalarWhereInput = {
    AND?: BookSummaryScalarWhereInput | BookSummaryScalarWhereInput[]
    OR?: BookSummaryScalarWhereInput[]
    NOT?: BookSummaryScalarWhereInput | BookSummaryScalarWhereInput[]
    id?: StringFilter<"BookSummary"> | string
    bookVersionId?: StringFilter<"BookSummary"> | string
    summary?: StringFilter<"BookSummary"> | string
    analysis?: StringNullableFilter<"BookSummary"> | string | null
    themes?: StringNullableFilter<"BookSummary"> | string | null
    createdAt?: DateTimeFilter<"BookSummary"> | Date | string
    updatedAt?: DateTimeFilter<"BookSummary"> | Date | string
  }

  export type ChapterUpsertWithWhereUniqueWithoutBookVersionInput = {
    where: ChapterWhereUniqueInput
    update: XOR<ChapterUpdateWithoutBookVersionInput, ChapterUncheckedUpdateWithoutBookVersionInput>
    create: XOR<ChapterCreateWithoutBookVersionInput, ChapterUncheckedCreateWithoutBookVersionInput>
  }

  export type ChapterUpdateWithWhereUniqueWithoutBookVersionInput = {
    where: ChapterWhereUniqueInput
    data: XOR<ChapterUpdateWithoutBookVersionInput, ChapterUncheckedUpdateWithoutBookVersionInput>
  }

  export type ChapterUpdateManyWithWhereWithoutBookVersionInput = {
    where: ChapterScalarWhereInput
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyWithoutBookVersionInput>
  }

  export type ChapterScalarWhereInput = {
    AND?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
    OR?: ChapterScalarWhereInput[]
    NOT?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
    id?: StringFilter<"Chapter"> | string
    bookVersionId?: StringFilter<"Chapter"> | string
    number?: IntFilter<"Chapter"> | number
    title?: StringFilter<"Chapter"> | string
    content?: StringFilter<"Chapter"> | string
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
  }

  export type AudioChapterUpsertWithWhereUniqueWithoutBookVersionInput = {
    where: AudioChapterWhereUniqueInput
    update: XOR<AudioChapterUpdateWithoutBookVersionInput, AudioChapterUncheckedUpdateWithoutBookVersionInput>
    create: XOR<AudioChapterCreateWithoutBookVersionInput, AudioChapterUncheckedCreateWithoutBookVersionInput>
  }

  export type AudioChapterUpdateWithWhereUniqueWithoutBookVersionInput = {
    where: AudioChapterWhereUniqueInput
    data: XOR<AudioChapterUpdateWithoutBookVersionInput, AudioChapterUncheckedUpdateWithoutBookVersionInput>
  }

  export type AudioChapterUpdateManyWithWhereWithoutBookVersionInput = {
    where: AudioChapterScalarWhereInput
    data: XOR<AudioChapterUpdateManyMutationInput, AudioChapterUncheckedUpdateManyWithoutBookVersionInput>
  }

  export type AudioChapterScalarWhereInput = {
    AND?: AudioChapterScalarWhereInput | AudioChapterScalarWhereInput[]
    OR?: AudioChapterScalarWhereInput[]
    NOT?: AudioChapterScalarWhereInput | AudioChapterScalarWhereInput[]
    id?: StringFilter<"AudioChapter"> | string
    bookVersionId?: StringFilter<"AudioChapter"> | string
    number?: IntFilter<"AudioChapter"> | number
    title?: StringFilter<"AudioChapter"> | string
    audioUrl?: StringFilter<"AudioChapter"> | string
    duration?: IntFilter<"AudioChapter"> | number
    createdAt?: DateTimeFilter<"AudioChapter"> | Date | string
  }

  export type BookshelfUpsertWithWhereUniqueWithoutBookVersionInput = {
    where: BookshelfWhereUniqueInput
    update: XOR<BookshelfUpdateWithoutBookVersionInput, BookshelfUncheckedUpdateWithoutBookVersionInput>
    create: XOR<BookshelfCreateWithoutBookVersionInput, BookshelfUncheckedCreateWithoutBookVersionInput>
  }

  export type BookshelfUpdateWithWhereUniqueWithoutBookVersionInput = {
    where: BookshelfWhereUniqueInput
    data: XOR<BookshelfUpdateWithoutBookVersionInput, BookshelfUncheckedUpdateWithoutBookVersionInput>
  }

  export type BookshelfUpdateManyWithWhereWithoutBookVersionInput = {
    where: BookshelfScalarWhereInput
    data: XOR<BookshelfUpdateManyMutationInput, BookshelfUncheckedUpdateManyWithoutBookVersionInput>
  }

  export type BookshelfScalarWhereInput = {
    AND?: BookshelfScalarWhereInput | BookshelfScalarWhereInput[]
    OR?: BookshelfScalarWhereInput[]
    NOT?: BookshelfScalarWhereInput | BookshelfScalarWhereInput[]
    id?: StringFilter<"Bookshelf"> | string
    userId?: StringFilter<"Bookshelf"> | string
    bookVersionId?: StringFilter<"Bookshelf"> | string
    addedAt?: DateTimeFilter<"Bookshelf"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutBookVersionInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutBookVersionInput, CommentUncheckedUpdateWithoutBookVersionInput>
    create: XOR<CommentCreateWithoutBookVersionInput, CommentUncheckedCreateWithoutBookVersionInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutBookVersionInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutBookVersionInput, CommentUncheckedUpdateWithoutBookVersionInput>
  }

  export type CommentUpdateManyWithWhereWithoutBookVersionInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutBookVersionInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    bookVersionId?: StringNullableFilter<"Comment"> | string | null
    chapterId?: StringNullableFilter<"Comment"> | string | null
    audioChapterId?: StringNullableFilter<"Comment"> | string | null
    parentId?: StringNullableFilter<"Comment"> | string | null
    text?: StringFilter<"Comment"> | string
    isDeleted?: BoolFilter<"Comment"> | boolean
    isHidden?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type LikeUpsertWithWhereUniqueWithoutBookVersionInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutBookVersionInput, LikeUncheckedUpdateWithoutBookVersionInput>
    create: XOR<LikeCreateWithoutBookVersionInput, LikeUncheckedCreateWithoutBookVersionInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutBookVersionInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutBookVersionInput, LikeUncheckedUpdateWithoutBookVersionInput>
  }

  export type LikeUpdateManyWithWhereWithoutBookVersionInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutBookVersionInput>
  }

  export type LikeScalarWhereInput = {
    AND?: LikeScalarWhereInput | LikeScalarWhereInput[]
    OR?: LikeScalarWhereInput[]
    NOT?: LikeScalarWhereInput | LikeScalarWhereInput[]
    id?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
    bookVersionId?: StringNullableFilter<"Like"> | string | null
    commentId?: StringNullableFilter<"Like"> | string | null
    createdAt?: DateTimeFilter<"Like"> | Date | string
  }

  export type BookCategoryUpsertWithWhereUniqueWithoutBookVersionInput = {
    where: BookCategoryWhereUniqueInput
    update: XOR<BookCategoryUpdateWithoutBookVersionInput, BookCategoryUncheckedUpdateWithoutBookVersionInput>
    create: XOR<BookCategoryCreateWithoutBookVersionInput, BookCategoryUncheckedCreateWithoutBookVersionInput>
  }

  export type BookCategoryUpdateWithWhereUniqueWithoutBookVersionInput = {
    where: BookCategoryWhereUniqueInput
    data: XOR<BookCategoryUpdateWithoutBookVersionInput, BookCategoryUncheckedUpdateWithoutBookVersionInput>
  }

  export type BookCategoryUpdateManyWithWhereWithoutBookVersionInput = {
    where: BookCategoryScalarWhereInput
    data: XOR<BookCategoryUpdateManyMutationInput, BookCategoryUncheckedUpdateManyWithoutBookVersionInput>
  }

  export type BookCategoryScalarWhereInput = {
    AND?: BookCategoryScalarWhereInput | BookCategoryScalarWhereInput[]
    OR?: BookCategoryScalarWhereInput[]
    NOT?: BookCategoryScalarWhereInput | BookCategoryScalarWhereInput[]
    id?: StringFilter<"BookCategory"> | string
    bookVersionId?: StringFilter<"BookCategory"> | string
    categoryId?: StringFilter<"BookCategory"> | string
  }

  export type BookTagUpsertWithWhereUniqueWithoutBookVersionInput = {
    where: BookTagWhereUniqueInput
    update: XOR<BookTagUpdateWithoutBookVersionInput, BookTagUncheckedUpdateWithoutBookVersionInput>
    create: XOR<BookTagCreateWithoutBookVersionInput, BookTagUncheckedCreateWithoutBookVersionInput>
  }

  export type BookTagUpdateWithWhereUniqueWithoutBookVersionInput = {
    where: BookTagWhereUniqueInput
    data: XOR<BookTagUpdateWithoutBookVersionInput, BookTagUncheckedUpdateWithoutBookVersionInput>
  }

  export type BookTagUpdateManyWithWhereWithoutBookVersionInput = {
    where: BookTagScalarWhereInput
    data: XOR<BookTagUpdateManyMutationInput, BookTagUncheckedUpdateManyWithoutBookVersionInput>
  }

  export type BookTagScalarWhereInput = {
    AND?: BookTagScalarWhereInput | BookTagScalarWhereInput[]
    OR?: BookTagScalarWhereInput[]
    NOT?: BookTagScalarWhereInput | BookTagScalarWhereInput[]
    id?: StringFilter<"BookTag"> | string
    bookVersionId?: StringFilter<"BookTag"> | string
    tagId?: StringFilter<"BookTag"> | string
  }

  export type ViewStatUpsertWithWhereUniqueWithoutBookVersionInput = {
    where: ViewStatWhereUniqueInput
    update: XOR<ViewStatUpdateWithoutBookVersionInput, ViewStatUncheckedUpdateWithoutBookVersionInput>
    create: XOR<ViewStatCreateWithoutBookVersionInput, ViewStatUncheckedCreateWithoutBookVersionInput>
  }

  export type ViewStatUpdateWithWhereUniqueWithoutBookVersionInput = {
    where: ViewStatWhereUniqueInput
    data: XOR<ViewStatUpdateWithoutBookVersionInput, ViewStatUncheckedUpdateWithoutBookVersionInput>
  }

  export type ViewStatUpdateManyWithWhereWithoutBookVersionInput = {
    where: ViewStatScalarWhereInput
    data: XOR<ViewStatUpdateManyMutationInput, ViewStatUncheckedUpdateManyWithoutBookVersionInput>
  }

  export type ViewStatScalarWhereInput = {
    AND?: ViewStatScalarWhereInput | ViewStatScalarWhereInput[]
    OR?: ViewStatScalarWhereInput[]
    NOT?: ViewStatScalarWhereInput | ViewStatScalarWhereInput[]
    id?: StringFilter<"ViewStat"> | string
    bookVersionId?: StringFilter<"ViewStat"> | string
    userId?: StringNullableFilter<"ViewStat"> | string | null
    source?: EnumViewSourceFilter<"ViewStat"> | $Enums.ViewSource
    timestamp?: DateTimeFilter<"ViewStat"> | Date | string
  }

  export type ReadingProgressUpsertWithWhereUniqueWithoutBookVersionInput = {
    where: ReadingProgressWhereUniqueInput
    update: XOR<ReadingProgressUpdateWithoutBookVersionInput, ReadingProgressUncheckedUpdateWithoutBookVersionInput>
    create: XOR<ReadingProgressCreateWithoutBookVersionInput, ReadingProgressUncheckedCreateWithoutBookVersionInput>
  }

  export type ReadingProgressUpdateWithWhereUniqueWithoutBookVersionInput = {
    where: ReadingProgressWhereUniqueInput
    data: XOR<ReadingProgressUpdateWithoutBookVersionInput, ReadingProgressUncheckedUpdateWithoutBookVersionInput>
  }

  export type ReadingProgressUpdateManyWithWhereWithoutBookVersionInput = {
    where: ReadingProgressScalarWhereInput
    data: XOR<ReadingProgressUpdateManyMutationInput, ReadingProgressUncheckedUpdateManyWithoutBookVersionInput>
  }

  export type ReadingProgressScalarWhereInput = {
    AND?: ReadingProgressScalarWhereInput | ReadingProgressScalarWhereInput[]
    OR?: ReadingProgressScalarWhereInput[]
    NOT?: ReadingProgressScalarWhereInput | ReadingProgressScalarWhereInput[]
    id?: StringFilter<"ReadingProgress"> | string
    userId?: StringFilter<"ReadingProgress"> | string
    bookVersionId?: StringFilter<"ReadingProgress"> | string
    chapterNumber?: IntNullableFilter<"ReadingProgress"> | number | null
    audioChapterNumber?: IntNullableFilter<"ReadingProgress"> | number | null
    position?: FloatFilter<"ReadingProgress"> | number
    updatedAt?: DateTimeFilter<"ReadingProgress"> | Date | string
  }

  export type SeoUpsertWithoutBookVersionInput = {
    update: XOR<SeoUpdateWithoutBookVersionInput, SeoUncheckedUpdateWithoutBookVersionInput>
    create: XOR<SeoCreateWithoutBookVersionInput, SeoUncheckedCreateWithoutBookVersionInput>
    where?: SeoWhereInput
  }

  export type SeoUpdateToOneWithWhereWithoutBookVersionInput = {
    where?: SeoWhereInput
    data: XOR<SeoUpdateWithoutBookVersionInput, SeoUncheckedUpdateWithoutBookVersionInput>
  }

  export type SeoUpdateWithoutBookVersionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    robots?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogType?: NullableStringFieldUpdateOperationsInput | string | null
    ogUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCard?: NullableStringFieldUpdateOperationsInput | string | null
    twitterSite?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCreator?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    eventStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationName?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationStreet?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationCity?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationRegion?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationPostal?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationCountry?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeoUncheckedUpdateWithoutBookVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    robots?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogType?: NullableStringFieldUpdateOperationsInput | string | null
    ogUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCard?: NullableStringFieldUpdateOperationsInput | string | null
    twitterSite?: NullableStringFieldUpdateOperationsInput | string | null
    twitterCreator?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: NullableStringFieldUpdateOperationsInput | string | null
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    eventStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationName?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationStreet?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationCity?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationRegion?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationPostal?: NullableStringFieldUpdateOperationsInput | string | null
    eventLocationCountry?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookVersionCreateWithoutSummariesInput = {
    id?: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    book: BookCreateNestedOneWithoutVersionsInput
    chapters?: ChapterCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfCreateNestedManyWithoutBookVersionInput
    comments?: CommentCreateNestedManyWithoutBookVersionInput
    likes?: LikeCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryCreateNestedManyWithoutBookVersionInput
    tags?: BookTagCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressCreateNestedManyWithoutBookVersionInput
    seo?: SeoCreateNestedOneWithoutBookVersionInput
  }

  export type BookVersionUncheckedCreateWithoutSummariesInput = {
    id?: string
    bookId: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seoId?: number | null
    chapters?: ChapterUncheckedCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterUncheckedCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfUncheckedCreateNestedManyWithoutBookVersionInput
    comments?: CommentUncheckedCreateNestedManyWithoutBookVersionInput
    likes?: LikeUncheckedCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryUncheckedCreateNestedManyWithoutBookVersionInput
    tags?: BookTagUncheckedCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatUncheckedCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressUncheckedCreateNestedManyWithoutBookVersionInput
  }

  export type BookVersionCreateOrConnectWithoutSummariesInput = {
    where: BookVersionWhereUniqueInput
    create: XOR<BookVersionCreateWithoutSummariesInput, BookVersionUncheckedCreateWithoutSummariesInput>
  }

  export type BookVersionUpsertWithoutSummariesInput = {
    update: XOR<BookVersionUpdateWithoutSummariesInput, BookVersionUncheckedUpdateWithoutSummariesInput>
    create: XOR<BookVersionCreateWithoutSummariesInput, BookVersionUncheckedCreateWithoutSummariesInput>
    where?: BookVersionWhereInput
  }

  export type BookVersionUpdateToOneWithWhereWithoutSummariesInput = {
    where?: BookVersionWhereInput
    data: XOR<BookVersionUpdateWithoutSummariesInput, BookVersionUncheckedUpdateWithoutSummariesInput>
  }

  export type BookVersionUpdateWithoutSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BookUpdateOneRequiredWithoutVersionsNestedInput
    chapters?: ChapterUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUpdateManyWithoutBookVersionNestedInput
    seo?: SeoUpdateOneWithoutBookVersionNestedInput
  }

  export type BookVersionUncheckedUpdateWithoutSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seoId?: NullableIntFieldUpdateOperationsInput | number | null
    chapters?: ChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUncheckedUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUncheckedUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUncheckedUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUncheckedUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUncheckedUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUncheckedUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUncheckedUpdateManyWithoutBookVersionNestedInput
  }

  export type BookVersionCreateWithoutChaptersInput = {
    id?: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    book: BookCreateNestedOneWithoutVersionsInput
    summaries?: BookSummaryCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfCreateNestedManyWithoutBookVersionInput
    comments?: CommentCreateNestedManyWithoutBookVersionInput
    likes?: LikeCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryCreateNestedManyWithoutBookVersionInput
    tags?: BookTagCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressCreateNestedManyWithoutBookVersionInput
    seo?: SeoCreateNestedOneWithoutBookVersionInput
  }

  export type BookVersionUncheckedCreateWithoutChaptersInput = {
    id?: string
    bookId: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seoId?: number | null
    summaries?: BookSummaryUncheckedCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterUncheckedCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfUncheckedCreateNestedManyWithoutBookVersionInput
    comments?: CommentUncheckedCreateNestedManyWithoutBookVersionInput
    likes?: LikeUncheckedCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryUncheckedCreateNestedManyWithoutBookVersionInput
    tags?: BookTagUncheckedCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatUncheckedCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressUncheckedCreateNestedManyWithoutBookVersionInput
  }

  export type BookVersionCreateOrConnectWithoutChaptersInput = {
    where: BookVersionWhereUniqueInput
    create: XOR<BookVersionCreateWithoutChaptersInput, BookVersionUncheckedCreateWithoutChaptersInput>
  }

  export type CommentCreateWithoutChapterInput = {
    id?: string
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    bookVersion?: BookVersionCreateNestedOneWithoutCommentsInput
    audioChapter?: AudioChapterCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutChildrenInput
    children?: CommentCreateNestedManyWithoutParentInput
    likes?: LikeCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutChapterInput = {
    id?: string
    userId: string
    bookVersionId?: string | null
    audioChapterId?: string | null
    parentId?: string | null
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
    likes?: LikeUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutChapterInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutChapterInput, CommentUncheckedCreateWithoutChapterInput>
  }

  export type CommentCreateManyChapterInputEnvelope = {
    data: CommentCreateManyChapterInput | CommentCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type BookVersionUpsertWithoutChaptersInput = {
    update: XOR<BookVersionUpdateWithoutChaptersInput, BookVersionUncheckedUpdateWithoutChaptersInput>
    create: XOR<BookVersionCreateWithoutChaptersInput, BookVersionUncheckedCreateWithoutChaptersInput>
    where?: BookVersionWhereInput
  }

  export type BookVersionUpdateToOneWithWhereWithoutChaptersInput = {
    where?: BookVersionWhereInput
    data: XOR<BookVersionUpdateWithoutChaptersInput, BookVersionUncheckedUpdateWithoutChaptersInput>
  }

  export type BookVersionUpdateWithoutChaptersInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BookUpdateOneRequiredWithoutVersionsNestedInput
    summaries?: BookSummaryUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUpdateManyWithoutBookVersionNestedInput
    seo?: SeoUpdateOneWithoutBookVersionNestedInput
  }

  export type BookVersionUncheckedUpdateWithoutChaptersInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seoId?: NullableIntFieldUpdateOperationsInput | number | null
    summaries?: BookSummaryUncheckedUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUncheckedUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUncheckedUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUncheckedUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUncheckedUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUncheckedUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUncheckedUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUncheckedUpdateManyWithoutBookVersionNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutChapterInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutChapterInput, CommentUncheckedUpdateWithoutChapterInput>
    create: XOR<CommentCreateWithoutChapterInput, CommentUncheckedCreateWithoutChapterInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutChapterInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutChapterInput, CommentUncheckedUpdateWithoutChapterInput>
  }

  export type CommentUpdateManyWithWhereWithoutChapterInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutChapterInput>
  }

  export type BookVersionCreateWithoutAudioChaptersInput = {
    id?: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    book: BookCreateNestedOneWithoutVersionsInput
    summaries?: BookSummaryCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfCreateNestedManyWithoutBookVersionInput
    comments?: CommentCreateNestedManyWithoutBookVersionInput
    likes?: LikeCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryCreateNestedManyWithoutBookVersionInput
    tags?: BookTagCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressCreateNestedManyWithoutBookVersionInput
    seo?: SeoCreateNestedOneWithoutBookVersionInput
  }

  export type BookVersionUncheckedCreateWithoutAudioChaptersInput = {
    id?: string
    bookId: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seoId?: number | null
    summaries?: BookSummaryUncheckedCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfUncheckedCreateNestedManyWithoutBookVersionInput
    comments?: CommentUncheckedCreateNestedManyWithoutBookVersionInput
    likes?: LikeUncheckedCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryUncheckedCreateNestedManyWithoutBookVersionInput
    tags?: BookTagUncheckedCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatUncheckedCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressUncheckedCreateNestedManyWithoutBookVersionInput
  }

  export type BookVersionCreateOrConnectWithoutAudioChaptersInput = {
    where: BookVersionWhereUniqueInput
    create: XOR<BookVersionCreateWithoutAudioChaptersInput, BookVersionUncheckedCreateWithoutAudioChaptersInput>
  }

  export type CommentCreateWithoutAudioChapterInput = {
    id?: string
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    bookVersion?: BookVersionCreateNestedOneWithoutCommentsInput
    chapter?: ChapterCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutChildrenInput
    children?: CommentCreateNestedManyWithoutParentInput
    likes?: LikeCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutAudioChapterInput = {
    id?: string
    userId: string
    bookVersionId?: string | null
    chapterId?: string | null
    parentId?: string | null
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
    likes?: LikeUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutAudioChapterInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAudioChapterInput, CommentUncheckedCreateWithoutAudioChapterInput>
  }

  export type CommentCreateManyAudioChapterInputEnvelope = {
    data: CommentCreateManyAudioChapterInput | CommentCreateManyAudioChapterInput[]
    skipDuplicates?: boolean
  }

  export type BookVersionUpsertWithoutAudioChaptersInput = {
    update: XOR<BookVersionUpdateWithoutAudioChaptersInput, BookVersionUncheckedUpdateWithoutAudioChaptersInput>
    create: XOR<BookVersionCreateWithoutAudioChaptersInput, BookVersionUncheckedCreateWithoutAudioChaptersInput>
    where?: BookVersionWhereInput
  }

  export type BookVersionUpdateToOneWithWhereWithoutAudioChaptersInput = {
    where?: BookVersionWhereInput
    data: XOR<BookVersionUpdateWithoutAudioChaptersInput, BookVersionUncheckedUpdateWithoutAudioChaptersInput>
  }

  export type BookVersionUpdateWithoutAudioChaptersInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BookUpdateOneRequiredWithoutVersionsNestedInput
    summaries?: BookSummaryUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUpdateManyWithoutBookVersionNestedInput
    seo?: SeoUpdateOneWithoutBookVersionNestedInput
  }

  export type BookVersionUncheckedUpdateWithoutAudioChaptersInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seoId?: NullableIntFieldUpdateOperationsInput | number | null
    summaries?: BookSummaryUncheckedUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUncheckedUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUncheckedUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUncheckedUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUncheckedUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUncheckedUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUncheckedUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUncheckedUpdateManyWithoutBookVersionNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutAudioChapterInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAudioChapterInput, CommentUncheckedUpdateWithoutAudioChapterInput>
    create: XOR<CommentCreateWithoutAudioChapterInput, CommentUncheckedCreateWithoutAudioChapterInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAudioChapterInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAudioChapterInput, CommentUncheckedUpdateWithoutAudioChapterInput>
  }

  export type CommentUpdateManyWithWhereWithoutAudioChapterInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAudioChapterInput>
  }

  export type BookshelfCreateWithoutUserInput = {
    id?: string
    addedAt?: Date | string
    bookVersion: BookVersionCreateNestedOneWithoutBookshelfInput
  }

  export type BookshelfUncheckedCreateWithoutUserInput = {
    id?: string
    bookVersionId: string
    addedAt?: Date | string
  }

  export type BookshelfCreateOrConnectWithoutUserInput = {
    where: BookshelfWhereUniqueInput
    create: XOR<BookshelfCreateWithoutUserInput, BookshelfUncheckedCreateWithoutUserInput>
  }

  export type BookshelfCreateManyUserInputEnvelope = {
    data: BookshelfCreateManyUserInput | BookshelfCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    id?: string
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookVersion?: BookVersionCreateNestedOneWithoutCommentsInput
    chapter?: ChapterCreateNestedOneWithoutCommentsInput
    audioChapter?: AudioChapterCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutChildrenInput
    children?: CommentCreateNestedManyWithoutParentInput
    likes?: LikeCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: string
    bookVersionId?: string | null
    chapterId?: string | null
    audioChapterId?: string | null
    parentId?: string | null
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
    likes?: LikeUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LikeCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    bookVersion?: BookVersionCreateNestedOneWithoutLikesInput
    comment?: CommentCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutUserInput = {
    id?: string
    bookVersionId?: string | null
    commentId?: string | null
    createdAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutUserInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput>
  }

  export type LikeCreateManyUserInputEnvelope = {
    data: LikeCreateManyUserInput | LikeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ViewStatCreateWithoutUserInput = {
    id?: string
    source: $Enums.ViewSource
    timestamp?: Date | string
    bookVersion: BookVersionCreateNestedOneWithoutViewStatsInput
  }

  export type ViewStatUncheckedCreateWithoutUserInput = {
    id?: string
    bookVersionId: string
    source: $Enums.ViewSource
    timestamp?: Date | string
  }

  export type ViewStatCreateOrConnectWithoutUserInput = {
    where: ViewStatWhereUniqueInput
    create: XOR<ViewStatCreateWithoutUserInput, ViewStatUncheckedCreateWithoutUserInput>
  }

  export type ViewStatCreateManyUserInputEnvelope = {
    data: ViewStatCreateManyUserInput | ViewStatCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReadingProgressCreateWithoutUserInput = {
    id?: string
    chapterNumber?: number | null
    audioChapterNumber?: number | null
    position: number
    updatedAt?: Date | string
    bookVersion: BookVersionCreateNestedOneWithoutReadingProgressInput
  }

  export type ReadingProgressUncheckedCreateWithoutUserInput = {
    id?: string
    bookVersionId: string
    chapterNumber?: number | null
    audioChapterNumber?: number | null
    position: number
    updatedAt?: Date | string
  }

  export type ReadingProgressCreateOrConnectWithoutUserInput = {
    where: ReadingProgressWhereUniqueInput
    create: XOR<ReadingProgressCreateWithoutUserInput, ReadingProgressUncheckedCreateWithoutUserInput>
  }

  export type ReadingProgressCreateManyUserInputEnvelope = {
    data: ReadingProgressCreateManyUserInput | ReadingProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutUserInput = {
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    roleId: number
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BookshelfUpsertWithWhereUniqueWithoutUserInput = {
    where: BookshelfWhereUniqueInput
    update: XOR<BookshelfUpdateWithoutUserInput, BookshelfUncheckedUpdateWithoutUserInput>
    create: XOR<BookshelfCreateWithoutUserInput, BookshelfUncheckedCreateWithoutUserInput>
  }

  export type BookshelfUpdateWithWhereUniqueWithoutUserInput = {
    where: BookshelfWhereUniqueInput
    data: XOR<BookshelfUpdateWithoutUserInput, BookshelfUncheckedUpdateWithoutUserInput>
  }

  export type BookshelfUpdateManyWithWhereWithoutUserInput = {
    where: BookshelfScalarWhereInput
    data: XOR<BookshelfUpdateManyMutationInput, BookshelfUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type LikeUpsertWithWhereUniqueWithoutUserInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutUserInput, LikeUncheckedUpdateWithoutUserInput>
    create: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutUserInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutUserInput, LikeUncheckedUpdateWithoutUserInput>
  }

  export type LikeUpdateManyWithWhereWithoutUserInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutUserInput>
  }

  export type ViewStatUpsertWithWhereUniqueWithoutUserInput = {
    where: ViewStatWhereUniqueInput
    update: XOR<ViewStatUpdateWithoutUserInput, ViewStatUncheckedUpdateWithoutUserInput>
    create: XOR<ViewStatCreateWithoutUserInput, ViewStatUncheckedCreateWithoutUserInput>
  }

  export type ViewStatUpdateWithWhereUniqueWithoutUserInput = {
    where: ViewStatWhereUniqueInput
    data: XOR<ViewStatUpdateWithoutUserInput, ViewStatUncheckedUpdateWithoutUserInput>
  }

  export type ViewStatUpdateManyWithWhereWithoutUserInput = {
    where: ViewStatScalarWhereInput
    data: XOR<ViewStatUpdateManyMutationInput, ViewStatUncheckedUpdateManyWithoutUserInput>
  }

  export type ReadingProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: ReadingProgressWhereUniqueInput
    update: XOR<ReadingProgressUpdateWithoutUserInput, ReadingProgressUncheckedUpdateWithoutUserInput>
    create: XOR<ReadingProgressCreateWithoutUserInput, ReadingProgressUncheckedCreateWithoutUserInput>
  }

  export type ReadingProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: ReadingProgressWhereUniqueInput
    data: XOR<ReadingProgressUpdateWithoutUserInput, ReadingProgressUncheckedUpdateWithoutUserInput>
  }

  export type ReadingProgressUpdateManyWithWhereWithoutUserInput = {
    where: ReadingProgressScalarWhereInput
    data: XOR<ReadingProgressUpdateManyMutationInput, ReadingProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: IntFilter<"UserRole"> | number
  }

  export type UserCreateWithoutBookshelvesInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    languagePreference: $Enums.Language
    createdAt?: Date | string
    lastLogin?: Date | string | null
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    viewStats?: ViewStatCreateNestedManyWithoutUserInput
    readingProgress?: ReadingProgressCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookshelvesInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    languagePreference: $Enums.Language
    createdAt?: Date | string
    lastLogin?: Date | string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    viewStats?: ViewStatUncheckedCreateNestedManyWithoutUserInput
    readingProgress?: ReadingProgressUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookshelvesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookshelvesInput, UserUncheckedCreateWithoutBookshelvesInput>
  }

  export type BookVersionCreateWithoutBookshelfInput = {
    id?: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    book: BookCreateNestedOneWithoutVersionsInput
    summaries?: BookSummaryCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterCreateNestedManyWithoutBookVersionInput
    comments?: CommentCreateNestedManyWithoutBookVersionInput
    likes?: LikeCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryCreateNestedManyWithoutBookVersionInput
    tags?: BookTagCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressCreateNestedManyWithoutBookVersionInput
    seo?: SeoCreateNestedOneWithoutBookVersionInput
  }

  export type BookVersionUncheckedCreateWithoutBookshelfInput = {
    id?: string
    bookId: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seoId?: number | null
    summaries?: BookSummaryUncheckedCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterUncheckedCreateNestedManyWithoutBookVersionInput
    comments?: CommentUncheckedCreateNestedManyWithoutBookVersionInput
    likes?: LikeUncheckedCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryUncheckedCreateNestedManyWithoutBookVersionInput
    tags?: BookTagUncheckedCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatUncheckedCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressUncheckedCreateNestedManyWithoutBookVersionInput
  }

  export type BookVersionCreateOrConnectWithoutBookshelfInput = {
    where: BookVersionWhereUniqueInput
    create: XOR<BookVersionCreateWithoutBookshelfInput, BookVersionUncheckedCreateWithoutBookshelfInput>
  }

  export type UserUpsertWithoutBookshelvesInput = {
    update: XOR<UserUpdateWithoutBookshelvesInput, UserUncheckedUpdateWithoutBookshelvesInput>
    create: XOR<UserCreateWithoutBookshelvesInput, UserUncheckedCreateWithoutBookshelvesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookshelvesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookshelvesInput, UserUncheckedUpdateWithoutBookshelvesInput>
  }

  export type UserUpdateWithoutBookshelvesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    viewStats?: ViewStatUpdateManyWithoutUserNestedInput
    readingProgress?: ReadingProgressUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookshelvesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    viewStats?: ViewStatUncheckedUpdateManyWithoutUserNestedInput
    readingProgress?: ReadingProgressUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookVersionUpsertWithoutBookshelfInput = {
    update: XOR<BookVersionUpdateWithoutBookshelfInput, BookVersionUncheckedUpdateWithoutBookshelfInput>
    create: XOR<BookVersionCreateWithoutBookshelfInput, BookVersionUncheckedCreateWithoutBookshelfInput>
    where?: BookVersionWhereInput
  }

  export type BookVersionUpdateToOneWithWhereWithoutBookshelfInput = {
    where?: BookVersionWhereInput
    data: XOR<BookVersionUpdateWithoutBookshelfInput, BookVersionUncheckedUpdateWithoutBookshelfInput>
  }

  export type BookVersionUpdateWithoutBookshelfInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BookUpdateOneRequiredWithoutVersionsNestedInput
    summaries?: BookSummaryUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUpdateManyWithoutBookVersionNestedInput
    seo?: SeoUpdateOneWithoutBookVersionNestedInput
  }

  export type BookVersionUncheckedUpdateWithoutBookshelfInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seoId?: NullableIntFieldUpdateOperationsInput | number | null
    summaries?: BookSummaryUncheckedUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUncheckedUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUncheckedUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUncheckedUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUncheckedUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUncheckedUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUncheckedUpdateManyWithoutBookVersionNestedInput
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    languagePreference: $Enums.Language
    createdAt?: Date | string
    lastLogin?: Date | string | null
    bookshelves?: BookshelfCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    viewStats?: ViewStatCreateNestedManyWithoutUserInput
    readingProgress?: ReadingProgressCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    languagePreference: $Enums.Language
    createdAt?: Date | string
    lastLogin?: Date | string | null
    bookshelves?: BookshelfUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    viewStats?: ViewStatUncheckedCreateNestedManyWithoutUserInput
    readingProgress?: ReadingProgressUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type BookVersionCreateWithoutCommentsInput = {
    id?: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    book: BookCreateNestedOneWithoutVersionsInput
    summaries?: BookSummaryCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfCreateNestedManyWithoutBookVersionInput
    likes?: LikeCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryCreateNestedManyWithoutBookVersionInput
    tags?: BookTagCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressCreateNestedManyWithoutBookVersionInput
    seo?: SeoCreateNestedOneWithoutBookVersionInput
  }

  export type BookVersionUncheckedCreateWithoutCommentsInput = {
    id?: string
    bookId: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seoId?: number | null
    summaries?: BookSummaryUncheckedCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterUncheckedCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfUncheckedCreateNestedManyWithoutBookVersionInput
    likes?: LikeUncheckedCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryUncheckedCreateNestedManyWithoutBookVersionInput
    tags?: BookTagUncheckedCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatUncheckedCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressUncheckedCreateNestedManyWithoutBookVersionInput
  }

  export type BookVersionCreateOrConnectWithoutCommentsInput = {
    where: BookVersionWhereUniqueInput
    create: XOR<BookVersionCreateWithoutCommentsInput, BookVersionUncheckedCreateWithoutCommentsInput>
  }

  export type ChapterCreateWithoutCommentsInput = {
    id?: string
    number: number
    title: string
    content: string
    createdAt?: Date | string
    bookVersion: BookVersionCreateNestedOneWithoutChaptersInput
  }

  export type ChapterUncheckedCreateWithoutCommentsInput = {
    id?: string
    bookVersionId: string
    number: number
    title: string
    content: string
    createdAt?: Date | string
  }

  export type ChapterCreateOrConnectWithoutCommentsInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutCommentsInput, ChapterUncheckedCreateWithoutCommentsInput>
  }

  export type AudioChapterCreateWithoutCommentsInput = {
    id?: string
    number: number
    title: string
    audioUrl: string
    duration: number
    createdAt?: Date | string
    bookVersion: BookVersionCreateNestedOneWithoutAudioChaptersInput
  }

  export type AudioChapterUncheckedCreateWithoutCommentsInput = {
    id?: string
    bookVersionId: string
    number: number
    title: string
    audioUrl: string
    duration: number
    createdAt?: Date | string
  }

  export type AudioChapterCreateOrConnectWithoutCommentsInput = {
    where: AudioChapterWhereUniqueInput
    create: XOR<AudioChapterCreateWithoutCommentsInput, AudioChapterUncheckedCreateWithoutCommentsInput>
  }

  export type CommentCreateWithoutChildrenInput = {
    id?: string
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    bookVersion?: BookVersionCreateNestedOneWithoutCommentsInput
    chapter?: ChapterCreateNestedOneWithoutCommentsInput
    audioChapter?: AudioChapterCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutChildrenInput
    likes?: LikeCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutChildrenInput = {
    id?: string
    userId: string
    bookVersionId?: string | null
    chapterId?: string | null
    audioChapterId?: string | null
    parentId?: string | null
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: LikeUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutChildrenInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutChildrenInput, CommentUncheckedCreateWithoutChildrenInput>
  }

  export type CommentCreateWithoutParentInput = {
    id?: string
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    bookVersion?: BookVersionCreateNestedOneWithoutCommentsInput
    chapter?: ChapterCreateNestedOneWithoutCommentsInput
    audioChapter?: AudioChapterCreateNestedOneWithoutCommentsInput
    children?: CommentCreateNestedManyWithoutParentInput
    likes?: LikeCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutParentInput = {
    id?: string
    userId: string
    bookVersionId?: string | null
    chapterId?: string | null
    audioChapterId?: string | null
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
    likes?: LikeUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutParentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentCreateManyParentInputEnvelope = {
    data: CommentCreateManyParentInput | CommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type LikeCreateWithoutCommentInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLikesInput
    bookVersion?: BookVersionCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutCommentInput = {
    id?: string
    userId: string
    bookVersionId?: string | null
    createdAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutCommentInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutCommentInput, LikeUncheckedCreateWithoutCommentInput>
  }

  export type LikeCreateManyCommentInputEnvelope = {
    data: LikeCreateManyCommentInput | LikeCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookshelves?: BookshelfUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    viewStats?: ViewStatUpdateManyWithoutUserNestedInput
    readingProgress?: ReadingProgressUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookshelves?: BookshelfUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    viewStats?: ViewStatUncheckedUpdateManyWithoutUserNestedInput
    readingProgress?: ReadingProgressUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookVersionUpsertWithoutCommentsInput = {
    update: XOR<BookVersionUpdateWithoutCommentsInput, BookVersionUncheckedUpdateWithoutCommentsInput>
    create: XOR<BookVersionCreateWithoutCommentsInput, BookVersionUncheckedCreateWithoutCommentsInput>
    where?: BookVersionWhereInput
  }

  export type BookVersionUpdateToOneWithWhereWithoutCommentsInput = {
    where?: BookVersionWhereInput
    data: XOR<BookVersionUpdateWithoutCommentsInput, BookVersionUncheckedUpdateWithoutCommentsInput>
  }

  export type BookVersionUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BookUpdateOneRequiredWithoutVersionsNestedInput
    summaries?: BookSummaryUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUpdateManyWithoutBookVersionNestedInput
    seo?: SeoUpdateOneWithoutBookVersionNestedInput
  }

  export type BookVersionUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seoId?: NullableIntFieldUpdateOperationsInput | number | null
    summaries?: BookSummaryUncheckedUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUncheckedUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUncheckedUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUncheckedUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUncheckedUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUncheckedUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUncheckedUpdateManyWithoutBookVersionNestedInput
  }

  export type ChapterUpsertWithoutCommentsInput = {
    update: XOR<ChapterUpdateWithoutCommentsInput, ChapterUncheckedUpdateWithoutCommentsInput>
    create: XOR<ChapterCreateWithoutCommentsInput, ChapterUncheckedCreateWithoutCommentsInput>
    where?: ChapterWhereInput
  }

  export type ChapterUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ChapterWhereInput
    data: XOR<ChapterUpdateWithoutCommentsInput, ChapterUncheckedUpdateWithoutCommentsInput>
  }

  export type ChapterUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookVersion?: BookVersionUpdateOneRequiredWithoutChaptersNestedInput
  }

  export type ChapterUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioChapterUpsertWithoutCommentsInput = {
    update: XOR<AudioChapterUpdateWithoutCommentsInput, AudioChapterUncheckedUpdateWithoutCommentsInput>
    create: XOR<AudioChapterCreateWithoutCommentsInput, AudioChapterUncheckedCreateWithoutCommentsInput>
    where?: AudioChapterWhereInput
  }

  export type AudioChapterUpdateToOneWithWhereWithoutCommentsInput = {
    where?: AudioChapterWhereInput
    data: XOR<AudioChapterUpdateWithoutCommentsInput, AudioChapterUncheckedUpdateWithoutCommentsInput>
  }

  export type AudioChapterUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookVersion?: BookVersionUpdateOneRequiredWithoutAudioChaptersNestedInput
  }

  export type AudioChapterUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithoutChildrenInput = {
    update: XOR<CommentUpdateWithoutChildrenInput, CommentUncheckedUpdateWithoutChildrenInput>
    create: XOR<CommentCreateWithoutChildrenInput, CommentUncheckedCreateWithoutChildrenInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutChildrenInput, CommentUncheckedUpdateWithoutChildrenInput>
  }

  export type CommentUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    bookVersion?: BookVersionUpdateOneWithoutCommentsNestedInput
    chapter?: ChapterUpdateOneWithoutCommentsNestedInput
    audioChapter?: AudioChapterUpdateOneWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    likes?: LikeUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    audioChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: LikeUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentInput>
  }

  export type LikeUpsertWithWhereUniqueWithoutCommentInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutCommentInput, LikeUncheckedUpdateWithoutCommentInput>
    create: XOR<LikeCreateWithoutCommentInput, LikeUncheckedCreateWithoutCommentInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutCommentInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutCommentInput, LikeUncheckedUpdateWithoutCommentInput>
  }

  export type LikeUpdateManyWithWhereWithoutCommentInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutCommentInput>
  }

  export type UserCreateWithoutLikesInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    languagePreference: $Enums.Language
    createdAt?: Date | string
    lastLogin?: Date | string | null
    bookshelves?: BookshelfCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    viewStats?: ViewStatCreateNestedManyWithoutUserInput
    readingProgress?: ReadingProgressCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLikesInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    languagePreference: $Enums.Language
    createdAt?: Date | string
    lastLogin?: Date | string | null
    bookshelves?: BookshelfUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    viewStats?: ViewStatUncheckedCreateNestedManyWithoutUserInput
    readingProgress?: ReadingProgressUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
  }

  export type BookVersionCreateWithoutLikesInput = {
    id?: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    book: BookCreateNestedOneWithoutVersionsInput
    summaries?: BookSummaryCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfCreateNestedManyWithoutBookVersionInput
    comments?: CommentCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryCreateNestedManyWithoutBookVersionInput
    tags?: BookTagCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressCreateNestedManyWithoutBookVersionInput
    seo?: SeoCreateNestedOneWithoutBookVersionInput
  }

  export type BookVersionUncheckedCreateWithoutLikesInput = {
    id?: string
    bookId: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seoId?: number | null
    summaries?: BookSummaryUncheckedCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterUncheckedCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfUncheckedCreateNestedManyWithoutBookVersionInput
    comments?: CommentUncheckedCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryUncheckedCreateNestedManyWithoutBookVersionInput
    tags?: BookTagUncheckedCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatUncheckedCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressUncheckedCreateNestedManyWithoutBookVersionInput
  }

  export type BookVersionCreateOrConnectWithoutLikesInput = {
    where: BookVersionWhereUniqueInput
    create: XOR<BookVersionCreateWithoutLikesInput, BookVersionUncheckedCreateWithoutLikesInput>
  }

  export type CommentCreateWithoutLikesInput = {
    id?: string
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    bookVersion?: BookVersionCreateNestedOneWithoutCommentsInput
    chapter?: ChapterCreateNestedOneWithoutCommentsInput
    audioChapter?: AudioChapterCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutChildrenInput
    children?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutLikesInput = {
    id?: string
    userId: string
    bookVersionId?: string | null
    chapterId?: string | null
    audioChapterId?: string | null
    parentId?: string | null
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutLikesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutLikesInput, CommentUncheckedCreateWithoutLikesInput>
  }

  export type UserUpsertWithoutLikesInput = {
    update: XOR<UserUpdateWithoutLikesInput, UserUncheckedUpdateWithoutLikesInput>
    create: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikesInput, UserUncheckedUpdateWithoutLikesInput>
  }

  export type UserUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookshelves?: BookshelfUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    viewStats?: ViewStatUpdateManyWithoutUserNestedInput
    readingProgress?: ReadingProgressUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookshelves?: BookshelfUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    viewStats?: ViewStatUncheckedUpdateManyWithoutUserNestedInput
    readingProgress?: ReadingProgressUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookVersionUpsertWithoutLikesInput = {
    update: XOR<BookVersionUpdateWithoutLikesInput, BookVersionUncheckedUpdateWithoutLikesInput>
    create: XOR<BookVersionCreateWithoutLikesInput, BookVersionUncheckedCreateWithoutLikesInput>
    where?: BookVersionWhereInput
  }

  export type BookVersionUpdateToOneWithWhereWithoutLikesInput = {
    where?: BookVersionWhereInput
    data: XOR<BookVersionUpdateWithoutLikesInput, BookVersionUncheckedUpdateWithoutLikesInput>
  }

  export type BookVersionUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BookUpdateOneRequiredWithoutVersionsNestedInput
    summaries?: BookSummaryUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUpdateManyWithoutBookVersionNestedInput
    seo?: SeoUpdateOneWithoutBookVersionNestedInput
  }

  export type BookVersionUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seoId?: NullableIntFieldUpdateOperationsInput | number | null
    summaries?: BookSummaryUncheckedUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUncheckedUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUncheckedUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUncheckedUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUncheckedUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUncheckedUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUncheckedUpdateManyWithoutBookVersionNestedInput
  }

  export type CommentUpsertWithoutLikesInput = {
    update: XOR<CommentUpdateWithoutLikesInput, CommentUncheckedUpdateWithoutLikesInput>
    create: XOR<CommentCreateWithoutLikesInput, CommentUncheckedCreateWithoutLikesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutLikesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutLikesInput, CommentUncheckedUpdateWithoutLikesInput>
  }

  export type CommentUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    bookVersion?: BookVersionUpdateOneWithoutCommentsNestedInput
    chapter?: ChapterUpdateOneWithoutCommentsNestedInput
    audioChapter?: AudioChapterUpdateOneWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    audioChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type BookCategoryCreateWithoutCategoryInput = {
    id?: string
    bookVersion: BookVersionCreateNestedOneWithoutCategoriesInput
  }

  export type BookCategoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    bookVersionId: string
  }

  export type BookCategoryCreateOrConnectWithoutCategoryInput = {
    where: BookCategoryWhereUniqueInput
    create: XOR<BookCategoryCreateWithoutCategoryInput, BookCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type BookCategoryCreateManyCategoryInputEnvelope = {
    data: BookCategoryCreateManyCategoryInput | BookCategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutChildrenInput = {
    id?: string
    type: $Enums.CategoryType
    name: string
    slug: string
    books?: BookCategoryCreateNestedManyWithoutCategoryInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
  }

  export type CategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    type: $Enums.CategoryType
    name: string
    slug: string
    parentId?: string | null
    books?: BookCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutChildrenInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
  }

  export type CategoryCreateWithoutParentInput = {
    id?: string
    type: $Enums.CategoryType
    name: string
    slug: string
    books?: BookCategoryCreateNestedManyWithoutCategoryInput
    children?: CategoryCreateNestedManyWithoutParentInput
  }

  export type CategoryUncheckedCreateWithoutParentInput = {
    id?: string
    type: $Enums.CategoryType
    name: string
    slug: string
    books?: BookCategoryUncheckedCreateNestedManyWithoutCategoryInput
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type CategoryCreateOrConnectWithoutParentInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryCreateManyParentInputEnvelope = {
    data: CategoryCreateManyParentInput | CategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type BookCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: BookCategoryWhereUniqueInput
    update: XOR<BookCategoryUpdateWithoutCategoryInput, BookCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<BookCategoryCreateWithoutCategoryInput, BookCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type BookCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: BookCategoryWhereUniqueInput
    data: XOR<BookCategoryUpdateWithoutCategoryInput, BookCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type BookCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: BookCategoryScalarWhereInput
    data: XOR<BookCategoryUpdateManyMutationInput, BookCategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CategoryUpsertWithoutChildrenInput = {
    update: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    books?: BookCategoryUpdateManyWithoutCategoryNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
  }

  export type CategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    books?: BookCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
  }

  export type CategoryUpdateManyWithWhereWithoutParentInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    type?: EnumCategoryTypeFilter<"Category"> | $Enums.CategoryType
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    parentId?: StringNullableFilter<"Category"> | string | null
  }

  export type BookVersionCreateWithoutCategoriesInput = {
    id?: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    book: BookCreateNestedOneWithoutVersionsInput
    summaries?: BookSummaryCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfCreateNestedManyWithoutBookVersionInput
    comments?: CommentCreateNestedManyWithoutBookVersionInput
    likes?: LikeCreateNestedManyWithoutBookVersionInput
    tags?: BookTagCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressCreateNestedManyWithoutBookVersionInput
    seo?: SeoCreateNestedOneWithoutBookVersionInput
  }

  export type BookVersionUncheckedCreateWithoutCategoriesInput = {
    id?: string
    bookId: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seoId?: number | null
    summaries?: BookSummaryUncheckedCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterUncheckedCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfUncheckedCreateNestedManyWithoutBookVersionInput
    comments?: CommentUncheckedCreateNestedManyWithoutBookVersionInput
    likes?: LikeUncheckedCreateNestedManyWithoutBookVersionInput
    tags?: BookTagUncheckedCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatUncheckedCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressUncheckedCreateNestedManyWithoutBookVersionInput
  }

  export type BookVersionCreateOrConnectWithoutCategoriesInput = {
    where: BookVersionWhereUniqueInput
    create: XOR<BookVersionCreateWithoutCategoriesInput, BookVersionUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryCreateWithoutBooksInput = {
    id?: string
    type: $Enums.CategoryType
    name: string
    slug: string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
  }

  export type CategoryUncheckedCreateWithoutBooksInput = {
    id?: string
    type: $Enums.CategoryType
    name: string
    slug: string
    parentId?: string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type CategoryCreateOrConnectWithoutBooksInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutBooksInput, CategoryUncheckedCreateWithoutBooksInput>
  }

  export type BookVersionUpsertWithoutCategoriesInput = {
    update: XOR<BookVersionUpdateWithoutCategoriesInput, BookVersionUncheckedUpdateWithoutCategoriesInput>
    create: XOR<BookVersionCreateWithoutCategoriesInput, BookVersionUncheckedCreateWithoutCategoriesInput>
    where?: BookVersionWhereInput
  }

  export type BookVersionUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: BookVersionWhereInput
    data: XOR<BookVersionUpdateWithoutCategoriesInput, BookVersionUncheckedUpdateWithoutCategoriesInput>
  }

  export type BookVersionUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BookUpdateOneRequiredWithoutVersionsNestedInput
    summaries?: BookSummaryUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUpdateManyWithoutBookVersionNestedInput
    seo?: SeoUpdateOneWithoutBookVersionNestedInput
  }

  export type BookVersionUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seoId?: NullableIntFieldUpdateOperationsInput | number | null
    summaries?: BookSummaryUncheckedUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUncheckedUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUncheckedUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUncheckedUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUncheckedUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUncheckedUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUncheckedUpdateManyWithoutBookVersionNestedInput
  }

  export type CategoryUpsertWithoutBooksInput = {
    update: XOR<CategoryUpdateWithoutBooksInput, CategoryUncheckedUpdateWithoutBooksInput>
    create: XOR<CategoryCreateWithoutBooksInput, CategoryUncheckedCreateWithoutBooksInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutBooksInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutBooksInput, CategoryUncheckedUpdateWithoutBooksInput>
  }

  export type CategoryUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
  }

  export type CategoryUncheckedUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type BookTagCreateWithoutTagInput = {
    id?: string
    bookVersion: BookVersionCreateNestedOneWithoutTagsInput
  }

  export type BookTagUncheckedCreateWithoutTagInput = {
    id?: string
    bookVersionId: string
  }

  export type BookTagCreateOrConnectWithoutTagInput = {
    where: BookTagWhereUniqueInput
    create: XOR<BookTagCreateWithoutTagInput, BookTagUncheckedCreateWithoutTagInput>
  }

  export type BookTagCreateManyTagInputEnvelope = {
    data: BookTagCreateManyTagInput | BookTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type BookTagUpsertWithWhereUniqueWithoutTagInput = {
    where: BookTagWhereUniqueInput
    update: XOR<BookTagUpdateWithoutTagInput, BookTagUncheckedUpdateWithoutTagInput>
    create: XOR<BookTagCreateWithoutTagInput, BookTagUncheckedCreateWithoutTagInput>
  }

  export type BookTagUpdateWithWhereUniqueWithoutTagInput = {
    where: BookTagWhereUniqueInput
    data: XOR<BookTagUpdateWithoutTagInput, BookTagUncheckedUpdateWithoutTagInput>
  }

  export type BookTagUpdateManyWithWhereWithoutTagInput = {
    where: BookTagScalarWhereInput
    data: XOR<BookTagUpdateManyMutationInput, BookTagUncheckedUpdateManyWithoutTagInput>
  }

  export type BookVersionCreateWithoutTagsInput = {
    id?: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    book: BookCreateNestedOneWithoutVersionsInput
    summaries?: BookSummaryCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfCreateNestedManyWithoutBookVersionInput
    comments?: CommentCreateNestedManyWithoutBookVersionInput
    likes?: LikeCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressCreateNestedManyWithoutBookVersionInput
    seo?: SeoCreateNestedOneWithoutBookVersionInput
  }

  export type BookVersionUncheckedCreateWithoutTagsInput = {
    id?: string
    bookId: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seoId?: number | null
    summaries?: BookSummaryUncheckedCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterUncheckedCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfUncheckedCreateNestedManyWithoutBookVersionInput
    comments?: CommentUncheckedCreateNestedManyWithoutBookVersionInput
    likes?: LikeUncheckedCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryUncheckedCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatUncheckedCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressUncheckedCreateNestedManyWithoutBookVersionInput
  }

  export type BookVersionCreateOrConnectWithoutTagsInput = {
    where: BookVersionWhereUniqueInput
    create: XOR<BookVersionCreateWithoutTagsInput, BookVersionUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutBooksInput = {
    id?: string
    name: string
    slug: string
  }

  export type TagUncheckedCreateWithoutBooksInput = {
    id?: string
    name: string
    slug: string
  }

  export type TagCreateOrConnectWithoutBooksInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutBooksInput, TagUncheckedCreateWithoutBooksInput>
  }

  export type BookVersionUpsertWithoutTagsInput = {
    update: XOR<BookVersionUpdateWithoutTagsInput, BookVersionUncheckedUpdateWithoutTagsInput>
    create: XOR<BookVersionCreateWithoutTagsInput, BookVersionUncheckedCreateWithoutTagsInput>
    where?: BookVersionWhereInput
  }

  export type BookVersionUpdateToOneWithWhereWithoutTagsInput = {
    where?: BookVersionWhereInput
    data: XOR<BookVersionUpdateWithoutTagsInput, BookVersionUncheckedUpdateWithoutTagsInput>
  }

  export type BookVersionUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BookUpdateOneRequiredWithoutVersionsNestedInput
    summaries?: BookSummaryUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUpdateManyWithoutBookVersionNestedInput
    seo?: SeoUpdateOneWithoutBookVersionNestedInput
  }

  export type BookVersionUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seoId?: NullableIntFieldUpdateOperationsInput | number | null
    summaries?: BookSummaryUncheckedUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUncheckedUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUncheckedUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUncheckedUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUncheckedUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUncheckedUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUncheckedUpdateManyWithoutBookVersionNestedInput
  }

  export type TagUpsertWithoutBooksInput = {
    update: XOR<TagUpdateWithoutBooksInput, TagUncheckedUpdateWithoutBooksInput>
    create: XOR<TagCreateWithoutBooksInput, TagUncheckedCreateWithoutBooksInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutBooksInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutBooksInput, TagUncheckedUpdateWithoutBooksInput>
  }

  export type TagUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type BookVersionCreateWithoutViewStatsInput = {
    id?: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    book: BookCreateNestedOneWithoutVersionsInput
    summaries?: BookSummaryCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfCreateNestedManyWithoutBookVersionInput
    comments?: CommentCreateNestedManyWithoutBookVersionInput
    likes?: LikeCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryCreateNestedManyWithoutBookVersionInput
    tags?: BookTagCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressCreateNestedManyWithoutBookVersionInput
    seo?: SeoCreateNestedOneWithoutBookVersionInput
  }

  export type BookVersionUncheckedCreateWithoutViewStatsInput = {
    id?: string
    bookId: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seoId?: number | null
    summaries?: BookSummaryUncheckedCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterUncheckedCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfUncheckedCreateNestedManyWithoutBookVersionInput
    comments?: CommentUncheckedCreateNestedManyWithoutBookVersionInput
    likes?: LikeUncheckedCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryUncheckedCreateNestedManyWithoutBookVersionInput
    tags?: BookTagUncheckedCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressUncheckedCreateNestedManyWithoutBookVersionInput
  }

  export type BookVersionCreateOrConnectWithoutViewStatsInput = {
    where: BookVersionWhereUniqueInput
    create: XOR<BookVersionCreateWithoutViewStatsInput, BookVersionUncheckedCreateWithoutViewStatsInput>
  }

  export type UserCreateWithoutViewStatsInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    languagePreference: $Enums.Language
    createdAt?: Date | string
    lastLogin?: Date | string | null
    bookshelves?: BookshelfCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    readingProgress?: ReadingProgressCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutViewStatsInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    languagePreference: $Enums.Language
    createdAt?: Date | string
    lastLogin?: Date | string | null
    bookshelves?: BookshelfUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    readingProgress?: ReadingProgressUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutViewStatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutViewStatsInput, UserUncheckedCreateWithoutViewStatsInput>
  }

  export type BookVersionUpsertWithoutViewStatsInput = {
    update: XOR<BookVersionUpdateWithoutViewStatsInput, BookVersionUncheckedUpdateWithoutViewStatsInput>
    create: XOR<BookVersionCreateWithoutViewStatsInput, BookVersionUncheckedCreateWithoutViewStatsInput>
    where?: BookVersionWhereInput
  }

  export type BookVersionUpdateToOneWithWhereWithoutViewStatsInput = {
    where?: BookVersionWhereInput
    data: XOR<BookVersionUpdateWithoutViewStatsInput, BookVersionUncheckedUpdateWithoutViewStatsInput>
  }

  export type BookVersionUpdateWithoutViewStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BookUpdateOneRequiredWithoutVersionsNestedInput
    summaries?: BookSummaryUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUpdateManyWithoutBookVersionNestedInput
    seo?: SeoUpdateOneWithoutBookVersionNestedInput
  }

  export type BookVersionUncheckedUpdateWithoutViewStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seoId?: NullableIntFieldUpdateOperationsInput | number | null
    summaries?: BookSummaryUncheckedUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUncheckedUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUncheckedUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUncheckedUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUncheckedUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUncheckedUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUncheckedUpdateManyWithoutBookVersionNestedInput
  }

  export type UserUpsertWithoutViewStatsInput = {
    update: XOR<UserUpdateWithoutViewStatsInput, UserUncheckedUpdateWithoutViewStatsInput>
    create: XOR<UserCreateWithoutViewStatsInput, UserUncheckedCreateWithoutViewStatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutViewStatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutViewStatsInput, UserUncheckedUpdateWithoutViewStatsInput>
  }

  export type UserUpdateWithoutViewStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookshelves?: BookshelfUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    readingProgress?: ReadingProgressUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutViewStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookshelves?: BookshelfUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    readingProgress?: ReadingProgressUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutReadingProgressInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    languagePreference: $Enums.Language
    createdAt?: Date | string
    lastLogin?: Date | string | null
    bookshelves?: BookshelfCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    viewStats?: ViewStatCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReadingProgressInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    languagePreference: $Enums.Language
    createdAt?: Date | string
    lastLogin?: Date | string | null
    bookshelves?: BookshelfUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    viewStats?: ViewStatUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReadingProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReadingProgressInput, UserUncheckedCreateWithoutReadingProgressInput>
  }

  export type BookVersionCreateWithoutReadingProgressInput = {
    id?: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    book: BookCreateNestedOneWithoutVersionsInput
    summaries?: BookSummaryCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfCreateNestedManyWithoutBookVersionInput
    comments?: CommentCreateNestedManyWithoutBookVersionInput
    likes?: LikeCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryCreateNestedManyWithoutBookVersionInput
    tags?: BookTagCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatCreateNestedManyWithoutBookVersionInput
    seo?: SeoCreateNestedOneWithoutBookVersionInput
  }

  export type BookVersionUncheckedCreateWithoutReadingProgressInput = {
    id?: string
    bookId: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seoId?: number | null
    summaries?: BookSummaryUncheckedCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterUncheckedCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfUncheckedCreateNestedManyWithoutBookVersionInput
    comments?: CommentUncheckedCreateNestedManyWithoutBookVersionInput
    likes?: LikeUncheckedCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryUncheckedCreateNestedManyWithoutBookVersionInput
    tags?: BookTagUncheckedCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatUncheckedCreateNestedManyWithoutBookVersionInput
  }

  export type BookVersionCreateOrConnectWithoutReadingProgressInput = {
    where: BookVersionWhereUniqueInput
    create: XOR<BookVersionCreateWithoutReadingProgressInput, BookVersionUncheckedCreateWithoutReadingProgressInput>
  }

  export type UserUpsertWithoutReadingProgressInput = {
    update: XOR<UserUpdateWithoutReadingProgressInput, UserUncheckedUpdateWithoutReadingProgressInput>
    create: XOR<UserCreateWithoutReadingProgressInput, UserUncheckedCreateWithoutReadingProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReadingProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReadingProgressInput, UserUncheckedUpdateWithoutReadingProgressInput>
  }

  export type UserUpdateWithoutReadingProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookshelves?: BookshelfUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    viewStats?: ViewStatUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReadingProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookshelves?: BookshelfUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    viewStats?: ViewStatUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookVersionUpsertWithoutReadingProgressInput = {
    update: XOR<BookVersionUpdateWithoutReadingProgressInput, BookVersionUncheckedUpdateWithoutReadingProgressInput>
    create: XOR<BookVersionCreateWithoutReadingProgressInput, BookVersionUncheckedCreateWithoutReadingProgressInput>
    where?: BookVersionWhereInput
  }

  export type BookVersionUpdateToOneWithWhereWithoutReadingProgressInput = {
    where?: BookVersionWhereInput
    data: XOR<BookVersionUpdateWithoutReadingProgressInput, BookVersionUncheckedUpdateWithoutReadingProgressInput>
  }

  export type BookVersionUpdateWithoutReadingProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BookUpdateOneRequiredWithoutVersionsNestedInput
    summaries?: BookSummaryUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUpdateManyWithoutBookVersionNestedInput
    seo?: SeoUpdateOneWithoutBookVersionNestedInput
  }

  export type BookVersionUncheckedUpdateWithoutReadingProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seoId?: NullableIntFieldUpdateOperationsInput | number | null
    summaries?: BookSummaryUncheckedUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUncheckedUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUncheckedUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUncheckedUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUncheckedUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUncheckedUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUncheckedUpdateManyWithoutBookVersionNestedInput
  }

  export type BookVersionCreateWithoutSeoInput = {
    id?: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    book: BookCreateNestedOneWithoutVersionsInput
    summaries?: BookSummaryCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfCreateNestedManyWithoutBookVersionInput
    comments?: CommentCreateNestedManyWithoutBookVersionInput
    likes?: LikeCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryCreateNestedManyWithoutBookVersionInput
    tags?: BookTagCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressCreateNestedManyWithoutBookVersionInput
  }

  export type BookVersionUncheckedCreateWithoutSeoInput = {
    id?: string
    bookId: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    summaries?: BookSummaryUncheckedCreateNestedManyWithoutBookVersionInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutBookVersionInput
    audioChapters?: AudioChapterUncheckedCreateNestedManyWithoutBookVersionInput
    bookshelf?: BookshelfUncheckedCreateNestedManyWithoutBookVersionInput
    comments?: CommentUncheckedCreateNestedManyWithoutBookVersionInput
    likes?: LikeUncheckedCreateNestedManyWithoutBookVersionInput
    categories?: BookCategoryUncheckedCreateNestedManyWithoutBookVersionInput
    tags?: BookTagUncheckedCreateNestedManyWithoutBookVersionInput
    viewStats?: ViewStatUncheckedCreateNestedManyWithoutBookVersionInput
    readingProgress?: ReadingProgressUncheckedCreateNestedManyWithoutBookVersionInput
  }

  export type BookVersionCreateOrConnectWithoutSeoInput = {
    where: BookVersionWhereUniqueInput
    create: XOR<BookVersionCreateWithoutSeoInput, BookVersionUncheckedCreateWithoutSeoInput>
  }

  export type BookVersionUpsertWithoutSeoInput = {
    update: XOR<BookVersionUpdateWithoutSeoInput, BookVersionUncheckedUpdateWithoutSeoInput>
    create: XOR<BookVersionCreateWithoutSeoInput, BookVersionUncheckedCreateWithoutSeoInput>
    where?: BookVersionWhereInput
  }

  export type BookVersionUpdateToOneWithWhereWithoutSeoInput = {
    where?: BookVersionWhereInput
    data: XOR<BookVersionUpdateWithoutSeoInput, BookVersionUncheckedUpdateWithoutSeoInput>
  }

  export type BookVersionUpdateWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BookUpdateOneRequiredWithoutVersionsNestedInput
    summaries?: BookSummaryUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUpdateManyWithoutBookVersionNestedInput
  }

  export type BookVersionUncheckedUpdateWithoutSeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summaries?: BookSummaryUncheckedUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUncheckedUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUncheckedUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUncheckedUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUncheckedUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUncheckedUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUncheckedUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUncheckedUpdateManyWithoutBookVersionNestedInput
  }

  export type UserRoleCreateWithoutRoleInput = {
    user: UserCreateNestedOneWithoutRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    userId: string
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserCreateWithoutRolesInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    languagePreference: $Enums.Language
    createdAt?: Date | string
    lastLogin?: Date | string | null
    bookshelves?: BookshelfCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    viewStats?: ViewStatCreateNestedManyWithoutUserInput
    readingProgress?: ReadingProgressCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: string
    email: string
    passwordHash: string
    name?: string | null
    avatarUrl?: string | null
    languagePreference: $Enums.Language
    createdAt?: Date | string
    lastLogin?: Date | string | null
    bookshelves?: BookshelfUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    viewStats?: ViewStatUncheckedCreateNestedManyWithoutUserInput
    readingProgress?: ReadingProgressUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type RoleCreateWithoutUsersInput = {
    name: $Enums.RoleName
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: number
    name: $Enums.RoleName
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutRolesInput = {
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookshelves?: BookshelfUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    viewStats?: ViewStatUpdateManyWithoutUserNestedInput
    readingProgress?: ReadingProgressUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languagePreference?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookshelves?: BookshelfUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    viewStats?: ViewStatUncheckedUpdateManyWithoutUserNestedInput
    readingProgress?: ReadingProgressUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
  }

  export type BookVersionCreateManyBookInput = {
    id?: string
    language: $Enums.Language
    title: string
    author: string
    description: string
    coverImageUrl: string
    type: $Enums.BookType
    isFree: boolean
    referralUrl?: string | null
    status?: $Enums.PublicationStatus
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seoId?: number | null
  }

  export type BookVersionUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summaries?: BookSummaryUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUpdateManyWithoutBookVersionNestedInput
    seo?: SeoUpdateOneWithoutBookVersionNestedInput
  }

  export type BookVersionUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seoId?: NullableIntFieldUpdateOperationsInput | number | null
    summaries?: BookSummaryUncheckedUpdateManyWithoutBookVersionNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    audioChapters?: AudioChapterUncheckedUpdateManyWithoutBookVersionNestedInput
    bookshelf?: BookshelfUncheckedUpdateManyWithoutBookVersionNestedInput
    comments?: CommentUncheckedUpdateManyWithoutBookVersionNestedInput
    likes?: LikeUncheckedUpdateManyWithoutBookVersionNestedInput
    categories?: BookCategoryUncheckedUpdateManyWithoutBookVersionNestedInput
    tags?: BookTagUncheckedUpdateManyWithoutBookVersionNestedInput
    viewStats?: ViewStatUncheckedUpdateManyWithoutBookVersionNestedInput
    readingProgress?: ReadingProgressUncheckedUpdateManyWithoutBookVersionNestedInput
  }

  export type BookVersionUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    coverImageUrl?: StringFieldUpdateOperationsInput | string
    type?: EnumBookTypeFieldUpdateOperationsInput | $Enums.BookType
    isFree?: BoolFieldUpdateOperationsInput | boolean
    referralUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPublicationStatusFieldUpdateOperationsInput | $Enums.PublicationStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BookSummaryCreateManyBookVersionInput = {
    id?: string
    summary: string
    analysis?: string | null
    themes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChapterCreateManyBookVersionInput = {
    id?: string
    number: number
    title: string
    content: string
    createdAt?: Date | string
  }

  export type AudioChapterCreateManyBookVersionInput = {
    id?: string
    number: number
    title: string
    audioUrl: string
    duration: number
    createdAt?: Date | string
  }

  export type BookshelfCreateManyBookVersionInput = {
    id?: string
    userId: string
    addedAt?: Date | string
  }

  export type CommentCreateManyBookVersionInput = {
    id?: string
    userId: string
    chapterId?: string | null
    audioChapterId?: string | null
    parentId?: string | null
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeCreateManyBookVersionInput = {
    id?: string
    userId: string
    commentId?: string | null
    createdAt?: Date | string
  }

  export type BookCategoryCreateManyBookVersionInput = {
    id?: string
    categoryId: string
  }

  export type BookTagCreateManyBookVersionInput = {
    id?: string
    tagId: string
  }

  export type ViewStatCreateManyBookVersionInput = {
    id?: string
    userId?: string | null
    source: $Enums.ViewSource
    timestamp?: Date | string
  }

  export type ReadingProgressCreateManyBookVersionInput = {
    id?: string
    userId: string
    chapterNumber?: number | null
    audioChapterNumber?: number | null
    position: number
    updatedAt?: Date | string
  }

  export type BookSummaryUpdateWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    analysis?: NullableStringFieldUpdateOperationsInput | string | null
    themes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookSummaryUncheckedUpdateWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    analysis?: NullableStringFieldUpdateOperationsInput | string | null
    themes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookSummaryUncheckedUpdateManyWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    analysis?: NullableStringFieldUpdateOperationsInput | string | null
    themes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterUpdateWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateManyWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioChapterUpdateWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutAudioChapterNestedInput
  }

  export type AudioChapterUncheckedUpdateWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutAudioChapterNestedInput
  }

  export type AudioChapterUncheckedUpdateManyWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookshelfUpdateWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookshelvesNestedInput
  }

  export type BookshelfUncheckedUpdateWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookshelfUncheckedUpdateManyWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    chapter?: ChapterUpdateOneWithoutCommentsNestedInput
    audioChapter?: AudioChapterUpdateOneWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
    likes?: LikeUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    audioChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
    likes?: LikeUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    audioChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpdateWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikesNestedInput
    comment?: CommentUpdateOneWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCategoryUpdateWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: CategoryUpdateOneRequiredWithoutBooksNestedInput
  }

  export type BookCategoryUncheckedUpdateWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type BookCategoryUncheckedUpdateManyWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type BookTagUpdateWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: TagUpdateOneRequiredWithoutBooksNestedInput
  }

  export type BookTagUncheckedUpdateWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type BookTagUncheckedUpdateManyWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ViewStatUpdateWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumViewSourceFieldUpdateOperationsInput | $Enums.ViewSource
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutViewStatsNestedInput
  }

  export type ViewStatUncheckedUpdateWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumViewSourceFieldUpdateOperationsInput | $Enums.ViewSource
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewStatUncheckedUpdateManyWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumViewSourceFieldUpdateOperationsInput | $Enums.ViewSource
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingProgressUpdateWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterNumber?: NullableIntFieldUpdateOperationsInput | number | null
    audioChapterNumber?: NullableIntFieldUpdateOperationsInput | number | null
    position?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReadingProgressNestedInput
  }

  export type ReadingProgressUncheckedUpdateWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    chapterNumber?: NullableIntFieldUpdateOperationsInput | number | null
    audioChapterNumber?: NullableIntFieldUpdateOperationsInput | number | null
    position?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingProgressUncheckedUpdateManyWithoutBookVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    chapterNumber?: NullableIntFieldUpdateOperationsInput | number | null
    audioChapterNumber?: NullableIntFieldUpdateOperationsInput | number | null
    position?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyChapterInput = {
    id?: string
    userId: string
    bookVersionId?: string | null
    audioChapterId?: string | null
    parentId?: string | null
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    bookVersion?: BookVersionUpdateOneWithoutCommentsNestedInput
    audioChapter?: AudioChapterUpdateOneWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
    likes?: LikeUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    audioChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
    likes?: LikeUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    audioChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyAudioChapterInput = {
    id?: string
    userId: string
    bookVersionId?: string | null
    chapterId?: string | null
    parentId?: string | null
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutAudioChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    bookVersion?: BookVersionUpdateOneWithoutCommentsNestedInput
    chapter?: ChapterUpdateOneWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
    likes?: LikeUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutAudioChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
    likes?: LikeUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutAudioChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookshelfCreateManyUserInput = {
    id?: string
    bookVersionId: string
    addedAt?: Date | string
  }

  export type CommentCreateManyUserInput = {
    id?: string
    bookVersionId?: string | null
    chapterId?: string | null
    audioChapterId?: string | null
    parentId?: string | null
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeCreateManyUserInput = {
    id?: string
    bookVersionId?: string | null
    commentId?: string | null
    createdAt?: Date | string
  }

  export type ViewStatCreateManyUserInput = {
    id?: string
    bookVersionId: string
    source: $Enums.ViewSource
    timestamp?: Date | string
  }

  export type ReadingProgressCreateManyUserInput = {
    id?: string
    bookVersionId: string
    chapterNumber?: number | null
    audioChapterNumber?: number | null
    position: number
    updatedAt?: Date | string
  }

  export type UserRoleCreateManyUserInput = {
    roleId: number
  }

  export type BookshelfUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookVersion?: BookVersionUpdateOneRequiredWithoutBookshelfNestedInput
  }

  export type BookshelfUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookshelfUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookVersion?: BookVersionUpdateOneWithoutCommentsNestedInput
    chapter?: ChapterUpdateOneWithoutCommentsNestedInput
    audioChapter?: AudioChapterUpdateOneWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
    likes?: LikeUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    audioChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
    likes?: LikeUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    audioChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookVersion?: BookVersionUpdateOneWithoutLikesNestedInput
    comment?: CommentUpdateOneWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewStatUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumViewSourceFieldUpdateOperationsInput | $Enums.ViewSource
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    bookVersion?: BookVersionUpdateOneRequiredWithoutViewStatsNestedInput
  }

  export type ViewStatUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    source?: EnumViewSourceFieldUpdateOperationsInput | $Enums.ViewSource
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewStatUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    source?: EnumViewSourceFieldUpdateOperationsInput | $Enums.ViewSource
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterNumber?: NullableIntFieldUpdateOperationsInput | number | null
    audioChapterNumber?: NullableIntFieldUpdateOperationsInput | number | null
    position?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookVersion?: BookVersionUpdateOneRequiredWithoutReadingProgressNestedInput
  }

  export type ReadingProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    chapterNumber?: NullableIntFieldUpdateOperationsInput | number | null
    audioChapterNumber?: NullableIntFieldUpdateOperationsInput | number | null
    position?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingProgressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
    chapterNumber?: NullableIntFieldUpdateOperationsInput | number | null
    audioChapterNumber?: NullableIntFieldUpdateOperationsInput | number | null
    position?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUpdateWithoutUserInput = {
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type CommentCreateManyParentInput = {
    id?: string
    userId: string
    bookVersionId?: string | null
    chapterId?: string | null
    audioChapterId?: string | null
    text: string
    isDeleted?: boolean
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeCreateManyCommentInput = {
    id?: string
    userId: string
    bookVersionId?: string | null
    createdAt?: Date | string
  }

  export type CommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    bookVersion?: BookVersionUpdateOneWithoutCommentsNestedInput
    chapter?: ChapterUpdateOneWithoutCommentsNestedInput
    audioChapter?: AudioChapterUpdateOneWithoutCommentsNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
    likes?: LikeUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    audioChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
    likes?: LikeUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: NullableStringFieldUpdateOperationsInput | string | null
    audioChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikesNestedInput
    bookVersion?: BookVersionUpdateOneWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCategoryCreateManyCategoryInput = {
    id?: string
    bookVersionId: string
  }

  export type CategoryCreateManyParentInput = {
    id?: string
    type: $Enums.CategoryType
    name: string
    slug: string
  }

  export type BookCategoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersion?: BookVersionUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type BookCategoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
  }

  export type BookCategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    books?: BookCategoryUpdateManyWithoutCategoryNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
  }

  export type CategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    books?: BookCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCategoryTypeFieldUpdateOperationsInput | $Enums.CategoryType
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type BookTagCreateManyTagInput = {
    id?: string
    bookVersionId: string
  }

  export type BookTagUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersion?: BookVersionUpdateOneRequiredWithoutTagsNestedInput
  }

  export type BookTagUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
  }

  export type BookTagUncheckedUpdateManyWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookVersionId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleCreateManyRoleInput = {
    userId: string
  }

  export type UserRoleUpdateWithoutRoleInput = {
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}